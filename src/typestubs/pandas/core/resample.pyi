"""
This type stub file was generated by pyright.
"""

import pandas.compat as compat
from pandas.core.base import GroupByMixin
from pandas.core.groupby import GroupBy, Grouper, _GroupBy, groupby
from pandas.util._decorators import Appender
from pandas.core.generic import _shared_docs
from typing import Any, Optional

_shared_docs_kwargs = dict()
class Resampler(_GroupBy):
    """
    Class for resampling datetimelike data, a groupby-like operation.
    See aggregate, transform, and apply functions on this object.

    It's easiest to use obj.resample(...) to use Resampler.

    Parameters
    ----------
    obj : pandas object
    groupby : a TimeGrouper object
    axis : int, default 0
    kind : str or None
        'period', 'timestamp' to override default index treatement

    Notes
    -----
    After resampling, see aggregate, apply, and transform functions.

    Returns
    -------
    a Resampler of the appropriate type
    """
    _attributes = ...
    _deprecated_valids = ...
    _deprecated_valid_patterns = ...
    _deprecated_invalids = ...
    def __init__(self, obj, groupby: Optional[Any] = ..., axis=..., kind: Optional[Any] = ..., **kwargs):
        self.groupby = ...
        self.keys = ...
        self.sort = ...
        self.axis = ...
        self.kind = ...
        self.squeeze = ...
        self.group_keys = ...
        self.as_index = ...
        self.exclusions = ...
        self.binner = ...
        self.grouper = ...
    
    def __unicode__(self):
        """ provide a nice str repr of our rolling object """
        ...
    
    @property
    def obj(self):
        ...
    
    @property
    def ax(self):
        ...
    
    @property
    def _typ(self):
        """ masquerade for compat as a Series or a DataFrame """
        ...
    
    @property
    def _from_selection(self):
        """ is the resampling from a DataFrame column or MultiIndex level """
        ...
    
    def _deprecated(self, op):
        ...
    
    def _make_deprecated_binop(op):
        ...
    
    def _make_deprecated_unary(op, name):
        ...
    
    def __array__(self):
        ...
    
    __gt__ = ...
    __ge__ = ...
    __lt__ = ...
    __le__ = ...
    __eq__ = ...
    __ne__ = ...
    __add__ = ...
    __sub__ = ...
    __mul__ = ...
    __floordiv__ = ...
    __truediv__ = ...
    if not compat.PY3:
        __div__ = ...
    __neg__ = ...
    __pos__ = ...
    __abs__ = ...
    __inv__ = ...
    def __getattr__(self, attr):
        ...
    
    def __setattr__(self, attr, value):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, attr, value):
        ...
    
    def _convert_obj(self, obj):
        """
        provide any conversions for the object in order to correctly handle

        Parameters
        ----------
        obj : the object to be resampled

        Returns
        -------
        obj : converted object
        """
        ...
    
    def _get_binner_for_time(self):
        ...
    
    def _set_binner(self):
        """
        setup our binners
        cache these as we are an immutable object
        """
        ...
    
    def _get_binner(self):
        """
        create the BinGrouper, assume that self.set_grouper(obj)
        has already been called
        """
        ...
    
    def _assure_grouper(self):
        """ make sure that we are creating our binner & grouper """
        ...
    
    def plot(self, *args, **kwargs):
        ...
    
    _agg_doc = ...
    @Appender(_agg_doc)
    @Appender(_shared_docs['aggregate'] % dict(klass='DataFrame', versionadded=''))
    def aggregate(self, arg, *args, **kwargs):
        ...
    
    agg = ...
    apply = ...
    def transform(self, arg, *args, **kwargs):
        """
        Call function producing a like-indexed Series on each group and return
        a Series with the transformed values

        Parameters
        ----------
        func : function
            To apply to each group. Should return a Series with the same index

        Examples
        --------
        >>> resampled.transform(lambda x: (x - x.mean()) / x.std())

        Returns
        -------
        transformed : Series
        """
        ...
    
    def _downsample(self, f):
        ...
    
    def _upsample(self, f, limit: Optional[Any] = ..., fill_value: Optional[Any] = ...):
        ...
    
    def _gotitem(self, key, ndim, subset: Optional[Any] = ...):
        """
        sub-classes to define
        return a sliced object

        Parameters
        ----------
        key : string / list of selections
        ndim : 1,2
            requested ndim of result
        subset : object, default None
            subset to act on
        """
        ...
    
    def _groupby_and_aggregate(self, how, grouper: Optional[Any] = ..., *args, **kwargs):
        """ re-evaluate the obj with a groupby aggregation """
        ...
    
    def _apply_loffset(self, result):
        """
        if loffset is set, offset the result index

        This is NOT an idempotent routine, it will be applied
        exactly once to the result.

        Parameters
        ----------
        result : Series or DataFrame
            the result of resample
        """
        self.loffset = ...
    
    def _get_resampler_for_grouping(self, groupby, **kwargs):
        """ return the correct class for resampling with groupby """
        ...
    
    def _wrap_result(self, result):
        """ potentially wrap any results """
        ...
    
    def pad(self, limit: Optional[Any] = ...):
        """
        Forward fill the values

        Parameters
        ----------
        limit : integer, optional
            limit of how many values to fill

        Returns
        -------
        an upsampled Series

        See Also
        --------
        Series.fillna
        DataFrame.fillna
        """
        ...
    
    ffill = ...
    def nearest(self, limit: Optional[Any] = ...):
        """
        Fill values with nearest neighbor starting from center

        Parameters
        ----------
        limit : integer, optional
            limit of how many values to fill

            .. versionadded:: 0.21.0

        Returns
        -------
        an upsampled Series

        See Also
        --------
        Series.fillna
        DataFrame.fillna
        """
        ...
    
    def backfill(self, limit: Optional[Any] = ...):
        """
        Backward fill the values

        Parameters
        ----------
        limit : integer, optional
            limit of how many values to fill

        Returns
        -------
        an upsampled Series

        See Also
        --------
        Series.fillna
        DataFrame.fillna
        """
        ...
    
    bfill = ...
    def fillna(self, method, limit: Optional[Any] = ...):
        """
        Fill missing values

        Parameters
        ----------
        method : str, method of resampling ('ffill', 'bfill')
        limit : integer, optional
            limit of how many values to fill

        See Also
        --------
        Series.fillna
        DataFrame.fillna
        """
        ...
    
    @Appender(_shared_docs['interpolate'] % _shared_docs_kwargs)
    def interpolate(self, method=..., axis=..., limit: Optional[Any] = ..., inplace: bool = ..., limit_direction=..., downcast: Optional[Any] = ..., **kwargs):
        """
        Interpolate values according to different methods.

        .. versionadded:: 0.18.1
        """
        ...
    
    def asfreq(self, fill_value: Optional[Any] = ...):
        """
        return the values at the new freq,
        essentially a reindex

        Parameters
        ----------
        fill_value: scalar, optional
            Value to use for missing values, applied during upsampling (note
            this does not fill NaNs that already were present).

            .. versionadded:: 0.20.0

        See Also
        --------
        Series.asfreq
        DataFrame.asfreq
        """
        ...
    
    def std(self, ddof=..., *args, **kwargs):
        """
        Compute standard deviation of groups, excluding missing values

        Parameters
        ----------
        ddof : integer, default 1
        degrees of freedom
        """
        ...
    
    def var(self, ddof=..., *args, **kwargs):
        """
        Compute variance of groups, excluding missing values

        Parameters
        ----------
        ddof : integer, default 1
        degrees of freedom
        """
        ...
    
    @Appender(GroupBy.size.__doc__)
    def size(self):
        ...
    


def _maybe_process_deprecations(r, how: Optional[Any] = ..., fill_method: Optional[Any] = ..., limit: Optional[Any] = ...):
    """ potentially we might have a deprecation warning, show it
    but call the appropriate methods anyhow """
    ...

class _GroupByMixin(GroupByMixin):
    """ provide the groupby facilities """
    def __init__(self, obj, *args, **kwargs):
        self.groupby = ...
    
    def _apply(self, f, **kwargs):
        """
        dispatch to _upsample; we are stripping all of the _upsample kwargs and
        performing the original function call on the grouped object
        """
        ...
    
    _upsample = ...
    _downsample = ...
    _groupby_and_aggregate = ...


class DatetimeIndexResampler(Resampler):
    @property
    def _resampler_for_grouping(self):
        ...
    
    def _get_binner_for_time(self):
        ...
    
    def _downsample(self, how, **kwargs):
        """
        Downsample the cython defined function

        Parameters
        ----------
        how : string / cython mapped function
        **kwargs : kw args passed to how function
        """
        ...
    
    def _adjust_binner_for_upsample(self, binner):
        """ adjust our binner when upsampling """
        ...
    
    def _upsample(self, method, limit: Optional[Any] = ..., fill_value: Optional[Any] = ...):
        """
        method : string {'backfill', 'bfill', 'pad',
            'ffill', 'asfreq'} method for upsampling
        limit : int, default None
            Maximum size gap to fill when reindexing
        fill_value : scalar, default None
            Value to use for missing values

        See also
        --------
        .fillna

        """
        ...
    
    def _wrap_result(self, result):
        ...
    


class DatetimeIndexResamplerGroupby(_GroupByMixin, DatetimeIndexResampler):
    """
    Provides a resample of a groupby implementation

    .. versionadded:: 0.18.1

    """
    @property
    def _constructor(self):
        ...
    


class PeriodIndexResampler(DatetimeIndexResampler):
    @property
    def _resampler_for_grouping(self):
        ...
    
    def _get_binner_for_time(self):
        ...
    
    def _convert_obj(self, obj):
        ...
    
    def _downsample(self, how, **kwargs):
        """
        Downsample the cython defined function

        Parameters
        ----------
        how : string / cython mapped function
        **kwargs : kw args passed to how function
        """
        ...
    
    def _upsample(self, method, limit: Optional[Any] = ..., fill_value: Optional[Any] = ...):
        """
        method : string {'backfill', 'bfill', 'pad', 'ffill'}
            method for upsampling
        limit : int, default None
            Maximum size gap to fill when reindexing
        fill_value : scalar, default None
            Value to use for missing values

        See also
        --------
        .fillna

        """
        ...
    


class PeriodIndexResamplerGroupby(_GroupByMixin, PeriodIndexResampler):
    """
    Provides a resample of a groupby implementation

    .. versionadded:: 0.18.1

    """
    @property
    def _constructor(self):
        ...
    


class TimedeltaIndexResampler(DatetimeIndexResampler):
    @property
    def _resampler_for_grouping(self):
        ...
    
    def _get_binner_for_time(self):
        ...
    
    def _adjust_binner_for_upsample(self, binner):
        """ adjust our binner when upsampling """
        ...
    


class TimedeltaIndexResamplerGroupby(_GroupByMixin, TimedeltaIndexResampler):
    """
    Provides a resample of a groupby implementation

    .. versionadded:: 0.18.1

    """
    @property
    def _constructor(self):
        ...
    


def resample(obj, kind: Optional[Any] = ..., **kwds):
    """ create a TimeGrouper and return our resampler """
    ...

def get_resampler_for_grouping(groupby, rule, how: Optional[Any] = ..., fill_method: Optional[Any] = ..., limit: Optional[Any] = ..., kind: Optional[Any] = ..., **kwargs):
    """ return our appropriate resampler when grouping as well """
    ...

class TimeGrouper(Grouper):
    """
    Custom groupby class for time-interval grouping

    Parameters
    ----------
    freq : pandas date offset or offset alias for identifying bin edges
    closed : closed end of interval; 'left' or 'right'
    label : interval boundary to use for labeling; 'left' or 'right'
    convention : {'start', 'end', 'e', 's'}
        If axis is PeriodIndex
    """
    _attributes = ...
    def __init__(self, freq=..., closed: Optional[Any] = ..., label: Optional[Any] = ..., how=..., axis=..., fill_method: Optional[Any] = ..., limit: Optional[Any] = ..., loffset: Optional[Any] = ..., kind: Optional[Any] = ..., convention: Optional[Any] = ..., base=..., **kwargs):
        self.closed = ...
        self.label = ...
        self.kind = ...
        self.convention = ...
        self.convention = ...
        self.loffset = ...
        self.how = ...
        self.fill_method = ...
        self.limit = ...
        self.base = ...
    
    def _get_resampler(self, obj, kind: Optional[Any] = ...):
        """
        return my resampler or raise if we have an invalid axis

        Parameters
        ----------
        obj : input object
        kind : string, optional
            'period','timestamp','timedelta' are valid

        Returns
        -------
        a Resampler

        Raises
        ------
        TypeError if incompatible axis

        """
        ...
    
    def _get_grouper(self, obj, validate: bool = ...):
        ...
    
    def _get_time_bins(self, ax):
        ...
    
    def _adjust_bin_edges(self, binner, ax_values):
        ...
    
    def _get_time_delta_bins(self, ax):
        ...
    
    def _get_time_period_bins(self, ax):
        ...
    
    def _get_period_bins(self, ax):
        ...
    


def _take_new_index(obj, indexer, new_index, axis=...):
    ...

def _get_range_edges(first, last, offset, closed=..., base=...):
    ...

def _adjust_dates_anchored(first, last, offset, closed=..., base=...):
    ...

def asfreq(obj, freq, method: Optional[Any] = ..., how: Optional[Any] = ..., normalize: bool = ..., fill_value: Optional[Any] = ...):
    """
    Utility frequency conversion method for Series/DataFrame
    """
    ...

