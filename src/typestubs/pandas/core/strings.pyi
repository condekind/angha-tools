"""
This type stub file was generated by pyright.
"""

from pandas.core.base import NoNewAttributesMixin
from pandas.util._decorators import Appender
from typing import Any, Optional

_cpython_optimized_encoders = ("utf-8", "utf8", "latin-1", "latin1", "iso-8859-1", "mbcs", "ascii")
_cpython_optimized_decoders = _cpython_optimized_encoders + ("utf-16", "utf-32")
_shared_docs = dict()
def _get_array_list(arr, others):
    ...

def str_cat(arr, others: Optional[Any] = ..., sep: Optional[Any] = ..., na_rep: Optional[Any] = ...):
    """
    Concatenate strings in the Series/Index with given separator.

    Parameters
    ----------
    others : list-like, or list of list-likes
      If None, returns str concatenating strings of the Series
    sep : string or None, default None
    na_rep : string or None, default None
        If None, NA in the series are ignored.

    Returns
    -------
    concat : Series/Index of objects or str

    Examples
    --------
    When ``na_rep`` is `None` (default behavior), NaN value(s)
    in the Series are ignored.

    >>> Series(['a','b',np.nan,'c']).str.cat(sep=' ')
    'a b c'

    >>> Series(['a','b',np.nan,'c']).str.cat(sep=' ', na_rep='?')
    'a b ? c'

    If ``others`` is specified, corresponding values are
    concatenated with the separator. Result will be a Series of strings.

    >>> Series(['a', 'b', 'c']).str.cat(['A', 'B', 'C'], sep=',')
    0    a,A
    1    b,B
    2    c,C
    dtype: object

    Otherwise, strings in the Series are concatenated. Result will be a string.

    >>> Series(['a', 'b', 'c']).str.cat(sep=',')
    'a,b,c'

    Also, you can pass a list of list-likes.

    >>> Series(['a', 'b']).str.cat([['x', 'y'], ['1', '2']], sep=',')
    0    a,x,1
    1    b,y,2
    dtype: object
    """
    ...

def _length_check(others):
    ...

def _na_map(f, arr, na_result=..., dtype=...):
    ...

def _map(f, arr, na_mask: bool = ..., na_value=..., dtype=...):
    ...

def str_count(arr, pat, flags=...):
    """
    Count occurrences of pattern in each string of the Series/Index.

    Parameters
    ----------
    pat : string, valid regular expression
    flags : int, default 0 (no flags)
        re module flags, e.g. re.IGNORECASE

    Returns
    -------
    counts : Series/Index of integer values
    """
    ...

def str_contains(arr, pat, case: bool = ..., flags=..., na=..., regex: bool = ...):
    """
    Return boolean Series/``array`` whether given pattern/regex is
    contained in each string in the Series/Index.

    Parameters
    ----------
    pat : string
        Character sequence or regular expression
    case : boolean, default True
        If True, case sensitive
    flags : int, default 0 (no flags)
        re module flags, e.g. re.IGNORECASE
    na : default NaN, fill value for missing values.
    regex : bool, default True
        If True use re.search, otherwise use Python in operator

    Returns
    -------
    contained : Series/array of boolean values

    See Also
    --------
    match : analogous, but stricter, relying on re.match instead of re.search

    """
    ...

def str_startswith(arr, pat, na=...):
    """
    Return boolean Series/``array`` indicating whether each string in the
    Series/Index starts with passed pattern. Equivalent to
    :meth:`str.startswith`.

    Parameters
    ----------
    pat : string
        Character sequence
    na : bool, default NaN

    Returns
    -------
    startswith : Series/array of boolean values
    """
    ...

def str_endswith(arr, pat, na=...):
    """
    Return boolean Series indicating whether each string in the
    Series/Index ends with passed pattern. Equivalent to
    :meth:`str.endswith`.

    Parameters
    ----------
    pat : string
        Character sequence
    na : bool, default NaN

    Returns
    -------
    endswith : Series/array of boolean values
    """
    ...

def str_replace(arr, pat, repl, n=..., case: Optional[Any] = ..., flags=...):
    """
    Replace occurrences of pattern/regex in the Series/Index with
    some other string. Equivalent to :meth:`str.replace` or
    :func:`re.sub`.

    Parameters
    ----------
    pat : string or compiled regex
        String can be a character sequence or regular expression.

        .. versionadded:: 0.20.0
            `pat` also accepts a compiled regex.

    repl : string or callable
        Replacement string or a callable. The callable is passed the regex
        match object and must return a replacement string to be used.
        See :func:`re.sub`.

        .. versionadded:: 0.20.0
            `repl` also accepts a callable.

    n : int, default -1 (all)
        Number of replacements to make from start
    case : boolean, default None
        - If True, case sensitive (the default if `pat` is a string)
        - Set to False for case insensitive
        - Cannot be set if `pat` is a compiled regex
    flags : int, default 0 (no flags)
        - re module flags, e.g. re.IGNORECASE
        - Cannot be set if `pat` is a compiled regex

    Returns
    -------
    replaced : Series/Index of objects

    Notes
    -----
    When `pat` is a compiled regex, all flags should be included in the
    compiled regex. Use of `case` or `flags` with a compiled regex will
    raise an error.

    Examples
    --------
    When `repl` is a string, every `pat` is replaced as with
    :meth:`str.replace`. NaN value(s) in the Series are left as is.

    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', 'b')
    0    boo
    1    buz
    2    NaN
    dtype: object

    When `repl` is a callable, it is called on every `pat` using
    :func:`re.sub`. The callable should expect one positional argument
    (a regex object) and return a string.

    To get the idea:

    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)
    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo
    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz
    2                                                  NaN
    dtype: object

    Reverse every lowercase alphabetic word:

    >>> repl = lambda m: m.group(0)[::-1]
    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)
    0    oof 123
    1    rab zab
    2        NaN
    dtype: object

    Using regex groups (extract second group and swap case):

    >>> pat = r"(?P<one>\w+) (?P<two>\w+) (?P<three>\w+)"
    >>> repl = lambda m: m.group('two').swapcase()
    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)
    0    tWO
    1    bAR
    dtype: object

    Using a compiled regex with flags

    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)
    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')
    0    foo
    1    bar
    2    NaN
    dtype: object
    """
    ...

def str_repeat(arr, repeats):
    """
    Duplicate each string in the Series/Index by indicated number
    of times.

    Parameters
    ----------
    repeats : int or array
        Same value for all (int) or different value per (array)

    Returns
    -------
    repeated : Series/Index of objects
    """
    ...

def str_match(arr, pat, case: bool = ..., flags=..., na=..., as_indexer: Optional[Any] = ...):
    """
    Determine if each string matches a regular expression.

    Parameters
    ----------
    pat : string
        Character sequence or regular expression
    case : boolean, default True
        If True, case sensitive
    flags : int, default 0 (no flags)
        re module flags, e.g. re.IGNORECASE
    na : default NaN, fill value for missing values.
    as_indexer : DEPRECATED - Keyword is ignored.

    Returns
    -------
    Series/array of boolean values

    See Also
    --------
    contains : analogous, but less strict, relying on re.search instead of
        re.match
    extract : extract matched groups

    """
    ...

def _get_single_group_name(rx):
    ...

def _groups_or_na_fun(regex):
    """Used in both extract_noexpand and extract_frame"""
    ...

def _str_extract_noexpand(arr, pat, flags=...):
    """
    Find groups in each string in the Series using passed regular
    expression. This function is called from
    str_extract(expand=False), and can return Series, DataFrame, or
    Index.

    """
    ...

def _str_extract_frame(arr, pat, flags=...):
    """
    For each subject string in the Series, extract groups from the
    first match of regular expression pat. This function is called from
    str_extract(expand=True), and always returns a DataFrame.

    """
    ...

def str_extract(arr, pat, flags=..., expand: Optional[Any] = ...):
    """
    For each subject string in the Series, extract groups from the
    first match of regular expression pat.

    Parameters
    ----------
    pat : string
        Regular expression pattern with capturing groups
    flags : int, default 0 (no flags)
        re module flags, e.g. re.IGNORECASE

    expand : bool, default False
        * If True, return DataFrame.
        * If False, return Series/Index/DataFrame.

        .. versionadded:: 0.18.0

    Returns
    -------
    DataFrame with one row for each subject string, and one column for
    each group. Any capture group names in regular expression pat will
    be used for column names; otherwise capture group numbers will be
    used. The dtype of each result column is always object, even when
    no match is found. If expand=False and pat has only one capture group,
    then return a Series (if subject is a Series) or Index (if subject
    is an Index).

    See Also
    --------
    extractall : returns all matches (not just the first match)

    Examples
    --------
    A pattern with two groups will return a DataFrame with two columns.
    Non-matches will be NaN.

    >>> s = Series(['a1', 'b2', 'c3'])
    >>> s.str.extract('([ab])(\d)')
         0    1
    0    a    1
    1    b    2
    2  NaN  NaN

    A pattern may contain optional groups.

    >>> s.str.extract('([ab])?(\d)')
         0  1
    0    a  1
    1    b  2
    2  NaN  3

    Named groups will become column names in the result.

    >>> s.str.extract('(?P<letter>[ab])(?P<digit>\d)')
      letter digit
    0      a     1
    1      b     2
    2    NaN   NaN

    A pattern with one group will return a DataFrame with one column
    if expand=True.

    >>> s.str.extract('[ab](\d)', expand=True)
         0
    0    1
    1    2
    2  NaN

    A pattern with one group will return a Series if expand=False.

    >>> s.str.extract('[ab](\d)', expand=False)
    0      1
    1      2
    2    NaN
    dtype: object

    """
    ...

def str_extractall(arr, pat, flags=...):
    """
    For each subject string in the Series, extract groups from all
    matches of regular expression pat. When each subject string in the
    Series has exactly one match, extractall(pat).xs(0, level='match')
    is the same as extract(pat).

    .. versionadded:: 0.18.0

    Parameters
    ----------
    pat : string
        Regular expression pattern with capturing groups
    flags : int, default 0 (no flags)
        re module flags, e.g. re.IGNORECASE

    Returns
    -------
    A DataFrame with one row for each match, and one column for each
    group. Its rows have a MultiIndex with first levels that come from
    the subject Series. The last level is named 'match' and indicates
    the order in the subject. Any capture group names in regular
    expression pat will be used for column names; otherwise capture
    group numbers will be used.

    See Also
    --------
    extract : returns first match only (not all matches)

    Examples
    --------
    A pattern with one group will return a DataFrame with one column.
    Indices with no matches will not appear in the result.

    >>> s = Series(["a1a2", "b1", "c1"], index=["A", "B", "C"])
    >>> s.str.extractall("[ab](\d)")
             0
      match
    A 0      1
      1      2
    B 0      1

    Capture group names are used for column names of the result.

    >>> s.str.extractall("[ab](?P<digit>\d)")
            digit
      match
    A 0         1
      1         2
    B 0         1

    A pattern with two groups will return a DataFrame with two columns.

    >>> s.str.extractall("(?P<letter>[ab])(?P<digit>\d)")
            letter digit
      match
    A 0          a     1
      1          a     2
    B 0          b     1

    Optional groups that do not match are NaN in the result.

    >>> s.str.extractall("(?P<letter>[ab])?(?P<digit>\d)")
            letter digit
      match
    A 0          a     1
      1          a     2
    B 0          b     1
    C 0        NaN     1

    """
    ...

def str_get_dummies(arr, sep=...):
    """
    Split each string in the Series by sep and return a frame of
    dummy/indicator variables.

    Parameters
    ----------
    sep : string, default "|"
        String to split on.

    Returns
    -------
    dummies : DataFrame

    Examples
    --------
    >>> Series(['a|b', 'a', 'a|c']).str.get_dummies()
       a  b  c
    0  1  1  0
    1  1  0  0
    2  1  0  1

    >>> Series(['a|b', np.nan, 'a|c']).str.get_dummies()
       a  b  c
    0  1  1  0
    1  0  0  0
    2  1  0  1

    See Also
    --------
    pandas.get_dummies
    """
    ...

def str_join(arr, sep):
    """
    Join lists contained as elements in the Series/Index with
    passed delimiter. Equivalent to :meth:`str.join`.

    Parameters
    ----------
    sep : string
        Delimiter

    Returns
    -------
    joined : Series/Index of objects
    """
    ...

def str_findall(arr, pat, flags=...):
    """
    Find all occurrences of pattern or regular expression in the
    Series/Index. Equivalent to :func:`re.findall`.

    Parameters
    ----------
    pat : string
        Pattern or regular expression
    flags : int, default 0 (no flags)
        re module flags, e.g. re.IGNORECASE

    Returns
    -------
    matches : Series/Index of lists

    See Also
    --------
    extractall : returns DataFrame with one column per capture group
    """
    ...

def str_find(arr, sub, start=..., end: Optional[Any] = ..., side=...):
    """
    Return indexes in each strings in the Series/Index where the
    substring is fully contained between [start:end]. Return -1 on failure.

    Parameters
    ----------
    sub : str
        Substring being searched
    start : int
        Left edge index
    end : int
        Right edge index
    side : {'left', 'right'}, default 'left'
        Specifies a starting side, equivalent to ``find`` or ``rfind``

    Returns
    -------
    found : Series/Index of integer values
    """
    ...

def str_index(arr, sub, start=..., end: Optional[Any] = ..., side=...):
    ...

def str_pad(arr, width, side=..., fillchar=...):
    """
    Pad strings in the Series/Index with an additional character to
    specified side.

    Parameters
    ----------
    width : int
        Minimum width of resulting string; additional characters will be filled
        with spaces
    side : {'left', 'right', 'both'}, default 'left'
    fillchar : str
        Additional character for filling, default is whitespace

    Returns
    -------
    padded : Series/Index of objects
    """
    ...

def str_split(arr, pat: Optional[Any] = ..., n: Optional[Any] = ...):
    """
    Split each string (a la re.split) in the Series/Index by given
    pattern, propagating NA values. Equivalent to :meth:`str.split`.

    Parameters
    ----------
    pat : string, default None
        String or regular expression to split on. If None, splits on whitespace
    n : int, default -1 (all)
        None, 0 and -1 will be interpreted as return all splits
    expand : bool, default False
        * If True, return DataFrame/MultiIndex expanding dimensionality.
        * If False, return Series/Index.

    return_type : deprecated, use `expand`

    Returns
    -------
    split : Series/Index or DataFrame/MultiIndex of objects
    """
    ...

def str_rsplit(arr, pat: Optional[Any] = ..., n: Optional[Any] = ...):
    """
    Split each string in the Series/Index by the given delimiter
    string, starting at the end of the string and working to the front.
    Equivalent to :meth:`str.rsplit`.

    Parameters
    ----------
    pat : string, default None
        Separator to split on. If None, splits on whitespace
    n : int, default -1 (all)
        None, 0 and -1 will be interpreted as return all splits
    expand : bool, default False
        * If True, return DataFrame/MultiIndex expanding dimensionality.
        * If False, return Series/Index.

    Returns
    -------
    split : Series/Index or DataFrame/MultiIndex of objects
    """
    ...

def str_slice(arr, start: Optional[Any] = ..., stop: Optional[Any] = ..., step: Optional[Any] = ...):
    """
    Slice substrings from each element in the Series/Index

    Parameters
    ----------
    start : int or None
    stop : int or None
    step : int or None

    Returns
    -------
    sliced : Series/Index of objects
    """
    ...

def str_slice_replace(arr, start: Optional[Any] = ..., stop: Optional[Any] = ..., repl: Optional[Any] = ...):
    """
    Replace a slice of each string in the Series/Index with another
    string.

    Parameters
    ----------
    start : int or None
    stop : int or None
    repl : str or None
        String for replacement

    Returns
    -------
    replaced : Series/Index of objects
    """
    ...

def str_strip(arr, to_strip: Optional[Any] = ..., side=...):
    """
    Strip whitespace (including newlines) from each string in the
    Series/Index.

    Parameters
    ----------
    to_strip : str or unicode
    side : {'left', 'right', 'both'}, default 'both'

    Returns
    -------
    stripped : Series/Index of objects
    """
    ...

def str_wrap(arr, width, **kwargs):
    r"""
    Wrap long strings in the Series/Index to be formatted in
    paragraphs with length less than a given width.

    This method has the same keyword parameters and defaults as
    :class:`textwrap.TextWrapper`.

    Parameters
    ----------
    width : int
        Maximum line-width
    expand_tabs : bool, optional
        If true, tab characters will be expanded to spaces (default: True)
    replace_whitespace : bool, optional
        If true, each whitespace character (as defined by string.whitespace)
        remaining after tab expansion will be replaced by a single space
        (default: True)
    drop_whitespace : bool, optional
        If true, whitespace that, after wrapping, happens to end up at the
        beginning or end of a line is dropped (default: True)
    break_long_words : bool, optional
        If true, then words longer than width will be broken in order to ensure
        that no lines are longer than width. If it is false, long words will
        not be broken, and some lines may be longer than width. (default: True)
    break_on_hyphens : bool, optional
        If true, wrapping will occur preferably on whitespace and right after
        hyphens in compound words, as it is customary in English. If false,
        only whitespaces will be considered as potentially good places for line
        breaks, but you need to set break_long_words to false if you want truly
        insecable words. (default: True)

    Returns
    -------
    wrapped : Series/Index of objects

    Notes
    -----
    Internally, this method uses a :class:`textwrap.TextWrapper` instance with
    default settings. To achieve behavior matching R's stringr library str_wrap
    function, use the arguments:

    - expand_tabs = False
    - replace_whitespace = True
    - drop_whitespace = True
    - break_long_words = False
    - break_on_hyphens = False

    Examples
    --------

    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])
    >>> s.str.wrap(12)
    0             line to be\nwrapped
    1    another line\nto be\nwrapped
    """
    ...

def str_translate(arr, table, deletechars: Optional[Any] = ...):
    """
    Map all characters in the string through the given mapping table.
    Equivalent to standard :meth:`str.translate`. Note that the optional
    argument deletechars is only valid if you are using python 2. For python 3,
    character deletion should be specified via the table argument.

    Parameters
    ----------
    table : dict (python 3), str or None (python 2)
        In python 3, table is a mapping of Unicode ordinals to Unicode
        ordinals, strings, or None. Unmapped characters are left untouched.
        Characters mapped to None are deleted. :meth:`str.maketrans` is a
        helper function for making translation tables.
        In python 2, table is either a string of length 256 or None. If the
        table argument is None, no translation is applied and the operation
        simply removes the characters in deletechars. :func:`string.maketrans`
        is a helper function for making translation tables.
    deletechars : str, optional (python 2)
        A string of characters to delete. This argument is only valid
        in python 2.

    Returns
    -------
    translated : Series/Index of objects
    """
    ...

def str_get(arr, i):
    """
    Extract element from lists, tuples, or strings in each element in the
    Series/Index.

    Parameters
    ----------
    i : int
        Integer index (location)

    Returns
    -------
    items : Series/Index of objects
    """
    ...

def str_decode(arr, encoding, errors=...):
    """
    Decode character string in the Series/Index using indicated encoding.
    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in
    python3.

    Parameters
    ----------
    encoding : str
    errors : str, optional

    Returns
    -------
    decoded : Series/Index of objects
    """
    ...

def str_encode(arr, encoding, errors=...):
    """
    Encode character string in the Series/Index using indicated encoding.
    Equivalent to :meth:`str.encode`.

    Parameters
    ----------
    encoding : str
    errors : str, optional

    Returns
    -------
    encoded : Series/Index of objects
    """
    ...

def _noarg_wrapper(f, docstring: Optional[Any] = ..., **kargs):
    ...

def _pat_wrapper(f, flags: bool = ..., na: bool = ..., **kwargs):
    ...

def copy(source):
    "Copy a docstring from another source function (if present)"
    ...

class StringMethods(NoNewAttributesMixin):
    """
    Vectorized string functions for Series and Index. NAs stay NA unless
    handled otherwise by a particular method. Patterned after Python's string
    methods, with some inspiration from R's stringr package.

    Examples
    --------
    >>> s.str.split('_')
    >>> s.str.replace('_', '')
    """
    def __init__(self, data):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __iter__(self):
        ...
    
    def _wrap_result(self, result, use_codes: bool = ..., name: Optional[Any] = ..., expand: Optional[Any] = ...):
        ...
    
    @copy(str_cat)
    def cat(self, others: Optional[Any] = ..., sep: Optional[Any] = ..., na_rep: Optional[Any] = ...):
        ...
    
    @copy(str_split)
    def split(self, pat: Optional[Any] = ..., n=..., expand: bool = ...):
        ...
    
    @copy(str_rsplit)
    def rsplit(self, pat: Optional[Any] = ..., n=..., expand: bool = ...):
        ...
    
    @Appender(_shared_docs['str_partition'] % { 'side': 'first','return': '3 elements containing the string itself, followed by two ' 'empty strings','also': 'rpartition : Split the string at the last occurrence of `sep`' })
    def partition(self, pat=..., expand: bool = ...):
        ...
    
    @Appender(_shared_docs['str_partition'] % { 'side': 'last','return': '3 elements containing two empty strings, followed by the ' 'string itself','also': 'partition : Split the string at the first occurrence of `sep`' })
    def rpartition(self, pat=..., expand: bool = ...):
        ...
    
    @copy(str_get)
    def get(self, i):
        ...
    
    @copy(str_join)
    def join(self, sep):
        ...
    
    @copy(str_contains)
    def contains(self, pat, case: bool = ..., flags=..., na=..., regex: bool = ...):
        ...
    
    @copy(str_match)
    def match(self, pat, case: bool = ..., flags=..., na=..., as_indexer: Optional[Any] = ...):
        ...
    
    @copy(str_replace)
    def replace(self, pat, repl, n=..., case: Optional[Any] = ..., flags=...):
        ...
    
    @copy(str_repeat)
    def repeat(self, repeats):
        ...
    
    @copy(str_pad)
    def pad(self, width, side=..., fillchar=...):
        ...
    
    @Appender(_shared_docs['str_pad'] % dict(side='left and right', method='center'))
    def center(self, width, fillchar=...):
        ...
    
    @Appender(_shared_docs['str_pad'] % dict(side='right', method='ljust'))
    def ljust(self, width, fillchar=...):
        ...
    
    @Appender(_shared_docs['str_pad'] % dict(side='left', method='rjust'))
    def rjust(self, width, fillchar=...):
        ...
    
    def zfill(self, width):
        """
        Filling left side of strings in the Series/Index with 0.
        Equivalent to :meth:`str.zfill`.

        Parameters
        ----------
        width : int
            Minimum width of resulting string; additional characters will be
            filled with 0

        Returns
        -------
        filled : Series/Index of objects
        """
        ...
    
    @copy(str_slice)
    def slice(self, start: Optional[Any] = ..., stop: Optional[Any] = ..., step: Optional[Any] = ...):
        ...
    
    @copy(str_slice_replace)
    def slice_replace(self, start: Optional[Any] = ..., stop: Optional[Any] = ..., repl: Optional[Any] = ...):
        ...
    
    @copy(str_decode)
    def decode(self, encoding, errors=...):
        ...
    
    @copy(str_encode)
    def encode(self, encoding, errors=...):
        ...
    
    @Appender(_shared_docs['str_strip'] % dict(side='left and right sides', method='strip'))
    def strip(self, to_strip: Optional[Any] = ...):
        ...
    
    @Appender(_shared_docs['str_strip'] % dict(side='left side', method='lstrip'))
    def lstrip(self, to_strip: Optional[Any] = ...):
        ...
    
    @Appender(_shared_docs['str_strip'] % dict(side='right side', method='rstrip'))
    def rstrip(self, to_strip: Optional[Any] = ...):
        ...
    
    @copy(str_wrap)
    def wrap(self, width, **kwargs):
        ...
    
    @copy(str_get_dummies)
    def get_dummies(self, sep=...):
        ...
    
    @copy(str_translate)
    def translate(self, table, deletechars: Optional[Any] = ...):
        ...
    
    count = ...
    startswith = ...
    endswith = ...
    findall = ...
    @copy(str_extract)
    def extract(self, pat, flags=..., expand: Optional[Any] = ...):
        ...
    
    @copy(str_extractall)
    def extractall(self, pat, flags=...):
        ...
    
    @Appender(_shared_docs['find'] % dict(side='lowest', method='find', also='rfind : Return highest indexes in each strings'))
    def find(self, sub, start=..., end: Optional[Any] = ...):
        ...
    
    @Appender(_shared_docs['find'] % dict(side='highest', method='rfind', also='find : Return lowest indexes in each strings'))
    def rfind(self, sub, start=..., end: Optional[Any] = ...):
        ...
    
    def normalize(self, form):
        """Return the Unicode normal form for the strings in the Series/Index.
        For more information on the forms, see the
        :func:`unicodedata.normalize`.

        Parameters
        ----------
        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}
            Unicode form

        Returns
        -------
        normalized : Series/Index of objects
        """
        ...
    
    @Appender(_shared_docs['index'] % dict(side='lowest', similar='find', method='index', also='rindex : Return highest indexes in each strings'))
    def index(self, sub, start=..., end: Optional[Any] = ...):
        ...
    
    @Appender(_shared_docs['index'] % dict(side='highest', similar='rfind', method='rindex', also='index : Return lowest indexes in each strings'))
    def rindex(self, sub, start=..., end: Optional[Any] = ...):
        ...
    
    len = ...
    lower = ...
    upper = ...
    title = ...
    capitalize = ...
    swapcase = ...
    isalnum = ...
    isalpha = ...
    isdigit = ...
    isspace = ...
    islower = ...
    isupper = ...
    istitle = ...
    isnumeric = ...
    isdecimal = ...
    @classmethod
    def _make_accessor(cls, data):
        ...
    


