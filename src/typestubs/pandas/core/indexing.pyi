"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

def get_indexers_list():
    ...

_NS = slice(None, None)
class _IndexSlice(object):
    """
    Create an object to more easily perform multi-index slicing

    Examples
    --------

    >>> midx = pd.MultiIndex.from_product([['A0','A1'], ['B0','B1','B2','B3']])
    >>> columns = ['foo', 'bar']
    >>> dfmi = pd.DataFrame(np.arange(16).reshape((len(midx), len(columns))),
                            index=midx, columns=columns)

    Using the default slice command:

    >>> dfmi.loc[(slice(None), slice('B0', 'B1')), :]
               foo  bar
        A0 B0    0    1
           B1    2    3
        A1 B0    8    9
           B1   10   11

    Using the IndexSlice class for a more intuitive command:

    >>> idx = pd.IndexSlice
    >>> dfmi.loc[idx[:, 'B0':'B1'], :]
               foo  bar
        A0 B0    0    1
           B1    2    3
        A1 B0    8    9
           B1   10   11
    """
    def __getitem__(self, arg):
        ...
    


IndexSlice = _IndexSlice()
class IndexingError(Exception):
    ...


class _NDFrameIndexer(object):
    _valid_types = ...
    _exception = ...
    axis = ...
    def __init__(self, obj, name):
        self.obj = ...
        self.ndim = ...
        self.name = ...
    
    def __call__(self, axis: Optional[Any] = ...):
        ...
    
    def __iter__(self):
        ...
    
    def __getitem__(self, key):
        ...
    
    def _get_label(self, label, axis: Optional[Any] = ...):
        ...
    
    def _get_loc(self, key, axis: Optional[Any] = ...):
        ...
    
    def _slice(self, obj, axis: Optional[Any] = ..., kind: Optional[Any] = ...):
        ...
    
    def _get_setitem_indexer(self, key):
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def _has_valid_type(self, k, axis):
        ...
    
    def _has_valid_tuple(self, key):
        """ check the key for valid keys across my indexer """
        ...
    
    def _should_validate_iterable(self, axis: Optional[Any] = ...):
        """ return a boolean whether this axes needs validation for a passed
        iterable
        """
        ...
    
    def _is_nested_tuple_indexer(self, tup):
        ...
    
    def _convert_tuple(self, key, is_setter: bool = ...):
        ...
    
    def _convert_range(self, key, is_setter: bool = ...):
        """ convert a range argument """
        ...
    
    def _convert_scalar_indexer(self, key, axis):
        ...
    
    def _convert_slice_indexer(self, key, axis):
        ...
    
    def _has_valid_setitem_indexer(self, indexer):
        ...
    
    def _has_valid_positional_setitem_indexer(self, indexer):
        """ validate that an positional indexer cannot enlarge its target
        will raise if needed, does not modify the indexer externally
        """
        ...
    
    def _setitem_with_indexer(self, indexer, value):
        ...
    
    def _align_series(self, indexer, ser, multiindex_indexer: bool = ...):
        """
        Parameters
        ----------
        indexer : tuple, slice, scalar
            The indexer used to get the locations that will be set to
            `ser`

        ser : pd.Series
            The values to assign to the locations specified by `indexer`

        multiindex_indexer : boolean, optional
            Defaults to False. Should be set to True if `indexer` was from
            a `pd.MultiIndex`, to avoid unnecessary broadcasting.


        Returns:
        --------
        `np.array` of `ser` broadcast to the appropriate shape for assignment
        to the locations selected by `indexer`

        """
        ...
    
    def _align_frame(self, indexer, df):
        ...
    
    def _align_panel(self, indexer, df):
        ...
    
    def _getitem_tuple(self, tup):
        ...
    
    def _multi_take_opportunity(self, tup):
        ...
    
    def _multi_take(self, tup):
        """ create the reindex map for our objects, raise the _exception if we
        can't create the indexer
        """
        ...
    
    def _convert_for_reindex(self, key, axis: Optional[Any] = ...):
        ...
    
    def _handle_lowerdim_multi_index_axis0(self, tup):
        ...
    
    def _getitem_lowerdim(self, tup):
        ...
    
    def _getitem_nested_tuple(self, tup):
        ...
    
    def _getitem_axis(self, key, axis: Optional[Any] = ...):
        ...
    
    def _getitem_iterable(self, key, axis: Optional[Any] = ...):
        ...
    
    def _convert_to_indexer(self, obj, axis: Optional[Any] = ..., is_setter: bool = ...):
        """
        Convert indexing key into something we can use to do actual fancy
        indexing on an ndarray

        Examples
        ix[:5] -> slice(0, 5)
        ix[[1,2,3]] -> [1,2,3]
        ix[['foo', 'bar', 'baz']] -> [i, j, k] (indices of foo, bar, baz)

        Going by Zen of Python?
        'In the face of ambiguity, refuse the temptation to guess.'
        raise AmbiguousIndexError with integer labels?
        - No, prefer label-based indexing
        """
        ...
    
    def _tuplify(self, loc):
        ...
    
    def _get_slice_axis(self, slice_obj, axis: Optional[Any] = ...):
        ...
    


class _IXIndexer(_NDFrameIndexer):
    """A primarily label-location based indexer, with integer position
    fallback.

    ``.ix[]`` supports mixed integer and label based access. It is
    primarily label based, but will fall back to integer positional
    access unless the corresponding axis is of integer type.

    ``.ix`` is the most general indexer and will support any of the
    inputs in ``.loc`` and ``.iloc``. ``.ix`` also supports floating
    point label schemes. ``.ix`` is exceptionally useful when dealing
    with mixed positional and label based hierachical indexes.

    However, when an axis is integer based, ONLY label based access
    and not positional access is supported. Thus, in such cases, it's
    usually better to be explicit and use ``.iloc`` or ``.loc``.

    See more at :ref:`Advanced Indexing <advanced>`.

    """
    def __init__(self, obj, name):
        ...
    
    def _has_valid_type(self, key, axis):
        ...
    


class _LocationIndexer(_NDFrameIndexer):
    _exception = ...
    def __getitem__(self, key):
        ...
    
    def _is_scalar_access(self, key):
        ...
    
    def _getitem_scalar(self, key):
        ...
    
    def _getitem_axis(self, key, axis: Optional[Any] = ...):
        ...
    
    def _getbool_axis(self, key, axis: Optional[Any] = ...):
        ...
    
    def _get_slice_axis(self, slice_obj, axis: Optional[Any] = ...):
        """ this is pretty simple as we just have to deal with labels """
        ...
    


class _LocIndexer(_LocationIndexer):
    """Purely label-location based indexer for selection by label.

    ``.loc[]`` is primarily label based, but may also be used with a
    boolean array.

    Allowed inputs are:

    - A single label, e.g. ``5`` or ``'a'``, (note that ``5`` is
      interpreted as a *label* of the index, and **never** as an
      integer position along the index).
    - A list or array of labels, e.g. ``['a', 'b', 'c']``.
    - A slice object with labels, e.g. ``'a':'f'`` (note that contrary
      to usual python slices, **both** the start and the stop are included!).
    - A boolean array.
    - A ``callable`` function with one argument (the calling Series, DataFrame
      or Panel) and that returns valid output for indexing (one of the above)

    ``.loc`` will raise a ``KeyError`` when the items are not found.

    See more at :ref:`Selection by Label <indexing.label>`

    """
    _valid_types = ...
    _exception = ...
    def _has_valid_type(self, key, axis):
        ...
    
    def _is_scalar_access(self, key):
        ...
    
    def _getitem_scalar(self, key):
        ...
    
    def _get_partial_string_timestamp_match_key(self, key, labels):
        """Translate any partial string timestamp matches in key, returning the
        new key (GH 10331)"""
        ...
    
    def _getitem_axis(self, key, axis: Optional[Any] = ...):
        ...
    


class _iLocIndexer(_LocationIndexer):
    """Purely integer-location based indexing for selection by position.

    ``.iloc[]`` is primarily integer position based (from ``0`` to
    ``length-1`` of the axis), but may also be used with a boolean
    array.

    Allowed inputs are:

    - An integer, e.g. ``5``.
    - A list or array of integers, e.g. ``[4, 3, 0]``.
    - A slice object with ints, e.g. ``1:7``.
    - A boolean array.
    - A ``callable`` function with one argument (the calling Series, DataFrame
      or Panel) and that returns valid output for indexing (one of the above)

    ``.iloc`` will raise ``IndexError`` if a requested indexer is
    out-of-bounds, except *slice* indexers which allow out-of-bounds
    indexing (this conforms with python/numpy *slice* semantics).

    See more at :ref:`Selection by Position <indexing.integer>`

    """
    _valid_types = ...
    _exception = ...
    def _has_valid_type(self, key, axis):
        ...
    
    def _has_valid_setitem_indexer(self, indexer):
        ...
    
    def _is_scalar_access(self, key):
        ...
    
    def _getitem_scalar(self, key):
        ...
    
    def _is_valid_integer(self, key, axis):
        ...
    
    def _is_valid_list_like(self, key, axis):
        ...
    
    def _getitem_tuple(self, tup):
        ...
    
    def _get_slice_axis(self, slice_obj, axis: Optional[Any] = ...):
        ...
    
    def _get_list_axis(self, key, axis: Optional[Any] = ...):
        """
        Return Series values by list or array of integers

        Parameters
        ----------
        key : list-like positional indexer
        axis : int (can only be zero)

        Returns
        -------
        Series object
        """
        ...
    
    def _getitem_axis(self, key, axis: Optional[Any] = ...):
        ...
    
    def _convert_to_indexer(self, obj, axis: Optional[Any] = ..., is_setter: bool = ...):
        """ much simpler as we only have to deal with our valid types """
        ...
    


class _ScalarAccessIndexer(_NDFrameIndexer):
    """ access scalars quickly """
    def _convert_key(self, key, is_setter: bool = ...):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, value):
        ...
    


class _AtIndexer(_ScalarAccessIndexer):
    """Fast label-based scalar accessor

    Similarly to ``loc``, ``at`` provides **label** based scalar lookups.
    You can also set using these indexers.

    """
    _takeable = ...
    def _convert_key(self, key, is_setter: bool = ...):
        """ require they keys to be the same type as the index (so we don't
        fallback)
        """
        ...
    


class _iAtIndexer(_ScalarAccessIndexer):
    """Fast integer location scalar accessor.

    Similarly to ``iloc``, ``iat`` provides **integer** based lookups.
    You can also set using these indexers.

    """
    _takeable = ...
    def _has_valid_setitem_indexer(self, indexer):
        ...
    
    def _convert_key(self, key, is_setter: bool = ...):
        """ require  integer args (and convert to label arguments) """
        ...
    


_eps = 1.1920929e-7
def length_of_indexer(indexer, target: Optional[Any] = ...):
    """return the length of a single non-tuple indexer which could be a slice
    """
    ...

def convert_to_index_sliceable(obj, key):
    """if we are index sliceable, then return my slicer, otherwise return None
    """
    ...

def is_index_slice(obj):
    ...

def check_bool_indexer(ax, key):
    ...

def convert_missing_indexer(indexer):
    """ reverse convert a missing indexer, which is a dict
    return the scalar indexer and a boolean indicating if we converted
    """
    ...

def convert_from_missing_indexer_tuple(indexer, axes):
    """ create a filtered indexer that doesn't have any missing indexers """
    ...

def maybe_convert_indices(indices, n):
    """
    Attempt to convert indices into valid, positive indices.

    If we have negative indices, translate to positive here.
    If we have indices that are out-of-bounds, raise an IndexError.

    Parameters
    ----------
    indices : array-like
        The array of indices that we are to convert.
    n : int
        The number of elements in the array that we are indexing.

    Returns
    -------
    valid_indices : array-like
        An array-like of positive indices that correspond to the ones
        that were passed in initially to this function.

    Raises
    ------
    IndexError : one of the converted indices either exceeded the number
        of elements (specified by `n`) OR was still negative.
    """
    ...

def maybe_convert_ix(*args):
    """
    We likely want to take the cross-product
    """
    ...

def is_nested_tuple(tup, labels):
    ...

def is_list_like_indexer(key):
    ...

def is_label_like(key):
    ...

def need_slice(obj):
    ...

def maybe_droplevels(index, key):
    ...

def _non_reducing_slice(slice_):
    """
    Ensurse that a slice doesn't reduce to a Series or Scalar.

    Any user-paseed `subset` should have this called on it
    to make sure we're always working with DataFrames.
    """
    ...

def _maybe_numeric_slice(df, slice_, include_bool: bool = ...):
    """
    want nice defaults for background_gradient that don't break
    with non-numeric data. But if slice_ is passed go with that.
    """
    ...

