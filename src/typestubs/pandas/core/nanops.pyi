"""
This type stub file was generated by pyright.
"""

import operator
from typing import Any, Optional

_BOTTLENECK_INSTALLED = False
_MIN_BOTTLENECK_VERSION = '1.0.0'
_USE_BOTTLENECK = False
def set_use_bottleneck(v: bool = ...):
    ...

class disallow(object):
    def __init__(self, *dtypes):
        self.dtypes = ...
    
    def check(self, obj):
        ...
    
    def __call__(self, f):
        ...
    


class bottleneck_switch(object):
    def __init__(self, **kwargs):
        self.kwargs = ...
    
    def __call__(self, alt):
        ...
    


def _bn_ok_dtype(dt, name):
    ...

def _has_infs(result):
    ...

def _get_fill_value(dtype, fill_value: Optional[Any] = ..., fill_value_typ: Optional[Any] = ...):
    """ return the correct fill value for the dtype of the values """
    ...

def _get_values(values, skipna, fill_value: Optional[Any] = ..., fill_value_typ: Optional[Any] = ..., isfinite: bool = ..., copy: bool = ...):
    """ utility to get the values view, mask, dtype
    if necessary copy and mask using the specified fill_value
    copy = True will force the copy
    """
    ...

def _isfinite(values):
    ...

def _na_ok_dtype(dtype):
    ...

def _view_if_needed(values):
    ...

def _wrap_results(result, dtype):
    """ wrap our results if needed """
    ...

def _na_for_min_count(values, axis):
    """Return the missing value for `values`

    Parameters
    ----------
    values : ndarray
    axis : int or None
        axis for the reduction

    Returns
    -------
    result : scalar or ndarray
        For 1-D values, returns a scalar of the correct missing type.
        For 2-D values, returns a 1-D array where each element is missing.
    """
    ...

def nanany(values, axis: Optional[Any] = ..., skipna: bool = ...):
    ...

def nanall(values, axis: Optional[Any] = ..., skipna: bool = ...):
    ...

@disallow('M8')
@bottleneck_switch()
def nansum(values, axis: Optional[Any] = ..., skipna: bool = ..., min_count=...):
    ...

@disallow('M8')
@bottleneck_switch()
def nanmean(values, axis: Optional[Any] = ..., skipna: bool = ...):
    ...

@disallow('M8')
@bottleneck_switch()
def nanmedian(values, axis: Optional[Any] = ..., skipna: bool = ...):
    ...

def _get_counts_nanvar(mask, axis, ddof, dtype=...):
    ...

@disallow('M8')
@bottleneck_switch(ddof=1)
def nanstd(values, axis: Optional[Any] = ..., skipna: bool = ..., ddof=...):
    ...

@disallow('M8')
@bottleneck_switch(ddof=1)
def nanvar(values, axis: Optional[Any] = ..., skipna: bool = ..., ddof=...):
    ...

@disallow('M8', 'm8')
def nansem(values, axis: Optional[Any] = ..., skipna: bool = ..., ddof=...):
    ...

def _nanminmax(meth, fill_value_typ):
    ...

nanmin = _nanminmax('min', fill_value_typ='+inf')
nanmax = _nanminmax('max', fill_value_typ='-inf')
@disallow('O')
def nanargmax(values, axis: Optional[Any] = ..., skipna: bool = ...):
    """
    Returns -1 in the NA case
    """
    ...

@disallow('O')
def nanargmin(values, axis: Optional[Any] = ..., skipna: bool = ...):
    """
    Returns -1 in the NA case
    """
    ...

@disallow('M8', 'm8')
def nanskew(values, axis: Optional[Any] = ..., skipna: bool = ...):
    """ Compute the sample skewness.

    The statistic computed here is the adjusted Fisher-Pearson standardized
    moment coefficient G1. The algorithm computes this coefficient directly
    from the second and third central moment.

    """
    ...

@disallow('M8', 'm8')
def nankurt(values, axis: Optional[Any] = ..., skipna: bool = ...):
    """ Compute the sample excess kurtosis.

    The statistic computed here is the adjusted Fisher-Pearson standardized
    moment coefficient G2, computed directly from the second and fourth
    central moment.

    """
    ...

@disallow('M8', 'm8')
def nanprod(values, axis: Optional[Any] = ..., skipna: bool = ..., min_count=...):
    ...

def _maybe_arg_null_out(result, axis, mask, skipna):
    ...

def _get_counts(mask, axis, dtype=...):
    ...

def _maybe_null_out(result, axis, mask, min_count=...):
    ...

def _zero_out_fperr(arg):
    ...

@disallow('M8', 'm8')
def nancorr(a, b, method=..., min_periods: Optional[Any] = ...):
    """
    a, b: ndarrays
    """
    ...

def get_corr_func(method):
    ...

@disallow('M8', 'm8')
def nancov(a, b, min_periods: Optional[Any] = ...):
    ...

def _ensure_numeric(x):
    ...

def make_nancomp(op):
    ...

nangt = make_nancomp(operator.gt)
nange = make_nancomp(operator.ge)
nanlt = make_nancomp(operator.lt)
nanle = make_nancomp(operator.le)
naneq = make_nancomp(operator.eq)
nanne = make_nancomp(operator.ne)
