"""
This type stub file was generated by pyright.
"""

import pandas.core.indexes.base as ibase
from pandas.core.indexes.base import _index_shared_docs
from pandas.util._decorators import Appender, cache_readonly
from pandas.core.indexes.numeric import Int64Index
from typing import Any, Optional

class RangeIndex(Int64Index):
    """
    Immutable Index implementing a monotonic integer range.

    RangeIndex is a memory-saving special case of Int64Index limited to
    representing monotonic ranges. Using RangeIndex may in some instances
    improve computing speed.

    This is the default index type used
    by DataFrame and Series when no explicit index is provided by the user.

    Parameters
    ----------
    start : int (default: 0), or other RangeIndex instance.
        If int and "stop" is not given, interpreted as "stop" instead.
    stop : int (default: 0)
    step : int (default: 1)
    name : object, optional
        Name to be stored in the index
    copy : bool, default False
        Unused, accepted for homogeneity with other index types.

    See Also
    --------
    Index : The base pandas Index type
    Int64Index : Index of int64 data
    """
    _typ = ...
    _engine_type = ...
    def __new__(cls, start: Optional[Any] = ..., stop: Optional[Any] = ..., step: Optional[Any] = ..., name: Optional[Any] = ..., dtype: Optional[Any] = ..., fastpath: bool = ..., copy: bool = ..., **kwargs):
        ...
    
    @classmethod
    def from_range(cls, data, name: Optional[Any] = ..., dtype: Optional[Any] = ..., **kwargs):
        """ create RangeIndex from a range (py3), or xrange (py2) object """
        ...
    
    @classmethod
    def _simple_new(cls, start, stop: Optional[Any] = ..., step: Optional[Any] = ..., name: Optional[Any] = ..., dtype: Optional[Any] = ..., **kwargs):
        ...
    
    @staticmethod
    def _validate_dtype(dtype):
        """ require dtype to be None or int64 """
        ...
    
    @cache_readonly
    def _constructor(self):
        """ return the class to use for construction """
        ...
    
    @cache_readonly
    def _data(self):
        ...
    
    @cache_readonly
    def _int64index(self):
        ...
    
    def _get_data_as_items(self):
        """ return a list of tuples of start, stop, step """
        ...
    
    def __reduce__(self):
        ...
    
    def _format_attrs(self):
        """
        Return a list of tuples of the (attr, formatted_value)
        """
        ...
    
    def _format_data(self, name: Optional[Any] = ...):
        ...
    
    @cache_readonly
    def nbytes(self):
        """
        Return the number of bytes in the underlying data
        On implementations where this is undetermined (PyPy)
        assume 24 bytes for each value
        """
        ...
    
    def memory_usage(self, deep: bool = ...):
        """
        Memory usage of my values

        Parameters
        ----------
        deep : bool
            Introspect the data deeply, interrogate
            `object` dtypes for system-level memory consumption

        Returns
        -------
        bytes used

        Notes
        -----
        Memory usage does not include memory consumed by elements that
        are not components of the array if deep=False

        See Also
        --------
        numpy.ndarray.nbytes
        """
        ...
    
    @property
    def dtype(self):
        ...
    
    @property
    def is_unique(self):
        """ return if the index has unique values """
        ...
    
    @cache_readonly
    def is_monotonic_increasing(self):
        ...
    
    @cache_readonly
    def is_monotonic_decreasing(self):
        ...
    
    @property
    def has_duplicates(self):
        ...
    
    def tolist(self):
        ...
    
    @Appender(_index_shared_docs['_shallow_copy'])
    def _shallow_copy(self, values: Optional[Any] = ..., **kwargs):
        ...
    
    @Appender(ibase._index_shared_docs['copy'])
    def copy(self, name: Optional[Any] = ..., deep: bool = ..., dtype: Optional[Any] = ..., **kwargs):
        ...
    
    def _minmax(self, meth):
        ...
    
    def min(self):
        """The minimum value of the RangeIndex"""
        ...
    
    def max(self):
        """The maximum value of the RangeIndex"""
        ...
    
    def argsort(self, *args, **kwargs):
        """
        Returns the indices that would sort the index and its
        underlying data.

        Returns
        -------
        argsorted : numpy array

        See also
        --------
        numpy.ndarray.argsort
        """
        ...
    
    def equals(self, other):
        """
        Determines if two Index objects contain the same elements.
        """
        ...
    
    def intersection(self, other):
        """
        Form the intersection of two Index objects. Sortedness of the result is
        not guaranteed

        Parameters
        ----------
        other : Index or array-like

        Returns
        -------
        intersection : Index
        """
        ...
    
    def _min_fitting_element(self, lower_limit):
        """Returns the smallest element greater than or equal to the limit"""
        ...
    
    def _max_fitting_element(self, upper_limit):
        """Returns the largest element smaller than or equal to the limit"""
        ...
    
    def _extended_gcd(self, a, b):
        """
        Extended Euclidean algorithms to solve Bezout's identity:
           a*x + b*y = gcd(x, y)
        Finds one particular solution for x, y: s, t
        Returns: gcd, s, t
        """
        ...
    
    def union(self, other):
        """
        Form the union of two Index objects and sorts if possible

        Parameters
        ----------
        other : Index or array-like

        Returns
        -------
        union : Index
        """
        ...
    
    @Appender(_index_shared_docs['join'])
    def join(self, other, how=..., level: Optional[Any] = ..., return_indexers: bool = ..., sort: bool = ...):
        ...
    
    def _concat_same_dtype(self, indexes, name):
        ...
    
    def __len__(self):
        """
        return the length of the RangeIndex
        """
        ...
    
    @property
    def size(self):
        ...
    
    def __getitem__(self, key):
        """
        Conserve RangeIndex type for scalar and slice keys.
        """
        ...
    
    def __floordiv__(self, other):
        ...
    
    @classmethod
    def _add_numeric_methods_binary(cls):
        """ add in numeric methods, specialized to RangeIndex """
        ...
    


