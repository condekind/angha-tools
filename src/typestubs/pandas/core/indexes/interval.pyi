"""
This type stub file was generated by pyright.
"""

import pandas.core.indexes.base as ibase
from pandas.core.indexes.base import Index, _index_shared_docs
from pandas._libs.interval import IntervalMixin
from pandas.util._decorators import Appender, cache_readonly
from typing import Any, Optional

""" define the IntervalIndex """
_index_doc_kwargs = dict(ibase._index_doc_kwargs)
_VALID_CLOSED = set(['left', 'right', 'both', 'neither'])
def _get_next_label(label):
    ...

def _get_prev_label(label):
    ...

def _get_interval_closed_bounds(interval):
    """
    Given an Interval or IntervalIndex, return the corresponding interval with
    closed bounds.
    """
    ...

def _new_IntervalIndex(cls, d):
    """ This is called upon unpickling,
    rather than the default which doesn't
    have arguments and breaks __new__ """
    ...

class IntervalIndex(IntervalMixin, Index):
    """
    Immutable Index implementing an ordered, sliceable set. IntervalIndex
    represents an Index of intervals that are all closed on the same side.

    .. versionadded:: 0.20.0

    .. warning::

       The indexing behaviors are provisional and may change in
       a future version of pandas.

    Attributes
    ----------
    left, right : array-like (1-dimensional)
        Left and right bounds for each interval.
    closed : {'left', 'right', 'both', 'neither'}, optional
        Whether the intervals are closed on the left-side, right-side, both or
        neither. Defaults to 'right'.
    name : object, optional
        Name to be stored in the index.
    copy : boolean, default False
        Copy the meta-data

    Examples
    ---------
    A new ``IntervalIndex`` is typically constructed using
    :func:`interval_range`:

    >>> pd.interval_range(start=0, end=5)
    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]]
                  closed='right', dtype='interval[int64]')

    It may also be constructed using one of the constructor
    methods :meth:`IntervalIndex.from_arrays`,
    :meth:`IntervalIndex.from_breaks`, :meth:`IntervalIndex.from_intervals`
    and :meth:`IntervalIndex.from_tuples`.

    See further examples in the doc strings of ``interval_range`` and the
    mentioned constructor methods.

    Notes
    ------
    See the `user guide
    <http://pandas.pydata.org/pandas-docs/stable/advanced.html#intervalindex>`_
    for more.

    See Also
    --------
    Index : The base pandas Index type
    Interval : A bounded slice-like interval
    interval_range : Function to create a fixed frequency
    IntervalIndex, IntervalIndex.from_arrays, IntervalIndex.from_breaks,
    IntervalIndex.from_intervals, IntervalIndex.from_tuples
    cut, qcut : convert arrays of continuous data into categoricals/series of
                ``Interval``.
    """
    _typ = ...
    _comparables = ...
    _attributes = ...
    _allow_index_ops = ...
    _defer_to_indexing = ...
    _mask = ...
    def __new__(cls, data, closed=..., name: Optional[Any] = ..., copy: bool = ..., dtype: Optional[Any] = ..., fastpath: bool = ..., verify_integrity: bool = ...):
        ...
    
    @classmethod
    def _simple_new(cls, left, right, closed: Optional[Any] = ..., name: Optional[Any] = ..., copy: bool = ..., verify_integrity: bool = ...):
        ...
    
    @Appender(_index_shared_docs['_shallow_copy'])
    def _shallow_copy(self, left: Optional[Any] = ..., right: Optional[Any] = ..., **kwargs):
        ...
    
    def _validate(self):
        """
        Verify that the IntervalIndex is valid.
        """
        ...
    
    @cache_readonly
    def hasnans(self):
        """ return if I have any nans; enables various perf speedups """
        ...
    
    @cache_readonly
    def _isnan(self):
        """ return if each value is nan"""
        ...
    
    @cache_readonly
    def _engine(self):
        ...
    
    @property
    def _constructor(self):
        ...
    
    def __contains__(self, key):
        """
        return a boolean if this key is IN the index
        We *only* accept an Interval

        Parameters
        ----------
        key : Interval

        Returns
        -------
        boolean
        """
        ...
    
    def contains(self, key):
        """
        return a boolean if this key is IN the index

        We accept / allow keys to be not *just* actual
        objects.

        Parameters
        ----------
        key : int, float, Interval

        Returns
        -------
        boolean
        """
        ...
    
    @classmethod
    def from_breaks(cls, breaks, closed=..., name: Optional[Any] = ..., copy: bool = ...):
        """
        Construct an IntervalIndex from an array of splits

        Parameters
        ----------
        breaks : array-like (1-dimensional)
            Left and right bounds for each interval.
        closed : {'left', 'right', 'both', 'neither'}, optional
            Whether the intervals are closed on the left-side, right-side, both
            or neither. Defaults to 'right'.
        name : object, optional
            Name to be stored in the index.
        copy : boolean, default False
            copy the data

        Examples
        --------
        >>> pd.IntervalIndex.from_breaks([0, 1, 2, 3])
        IntervalIndex([(0, 1], (1, 2], (2, 3]]
                      closed='right',
                      dtype='interval[int64]')

        See Also
        --------
        interval_range : Function to create a fixed frequency IntervalIndex
        IntervalIndex.from_arrays : Construct an IntervalIndex from a left and
                                    right array
        IntervalIndex.from_intervals : Construct an IntervalIndex from an array
                                       of Interval objects
        IntervalIndex.from_tuples : Construct an IntervalIndex from a
                                    list/array of tuples
        """
        ...
    
    @classmethod
    def from_arrays(cls, left, right, closed=..., name: Optional[Any] = ..., copy: bool = ...):
        """
        Construct an IntervalIndex from a a left and right array

        Parameters
        ----------
        left : array-like (1-dimensional)
            Left bounds for each interval.
        right : array-like (1-dimensional)
            Right bounds for each interval.
        closed : {'left', 'right', 'both', 'neither'}, optional
            Whether the intervals are closed on the left-side, right-side, both
            or neither. Defaults to 'right'.
        name : object, optional
            Name to be stored in the index.
        copy : boolean, default False
            copy the data

        Examples
        --------
        >>> pd.IntervalIndex.from_arrays([0, 1, 2], [1, 2, 3])
        IntervalIndex([(0, 1], (1, 2], (2, 3]]
                      closed='right',
                      dtype='interval[int64]')

        See Also
        --------
        interval_range : Function to create a fixed frequency IntervalIndex
        IntervalIndex.from_breaks : Construct an IntervalIndex from an array of
                                    splits
        IntervalIndex.from_intervals : Construct an IntervalIndex from an array
                                       of Interval objects
        IntervalIndex.from_tuples : Construct an IntervalIndex from a
                                    list/array of tuples
        """
        ...
    
    @classmethod
    def from_intervals(cls, data, name: Optional[Any] = ..., copy: bool = ...):
        """
        Construct an IntervalIndex from a 1d array of Interval objects

        Parameters
        ----------
        data : array-like (1-dimensional)
            Array of Interval objects. All intervals must be closed on the same
            sides.
        name : object, optional
            Name to be stored in the index.
        copy : boolean, default False
            by-default copy the data, this is compat only and ignored

        Examples
        --------
        >>> pd.IntervalIndex.from_intervals([pd.Interval(0, 1),
        ...                                  pd.Interval(1, 2)])
        IntervalIndex([(0, 1], (1, 2]]
                      closed='right', dtype='interval[int64]')

        The generic Index constructor work identically when it infers an array
        of all intervals:

        >>> pd.Index([pd.Interval(0, 1), pd.Interval(1, 2)])
        IntervalIndex([(0, 1], (1, 2]]
                      closed='right', dtype='interval[int64]')

        See Also
        --------
        interval_range : Function to create a fixed frequency IntervalIndex
        IntervalIndex.from_arrays : Construct an IntervalIndex from a left and
                                    right array
        IntervalIndex.from_breaks : Construct an IntervalIndex from an array of
                                    splits
        IntervalIndex.from_tuples : Construct an IntervalIndex from a
                                    list/array of tuples
        """
        ...
    
    @classmethod
    def from_tuples(cls, data, closed=..., name: Optional[Any] = ..., copy: bool = ...):
        """
        Construct an IntervalIndex from a list/array of tuples

        Parameters
        ----------
        data : array-like (1-dimensional)
            Array of tuples
        closed : {'left', 'right', 'both', 'neither'}, optional
            Whether the intervals are closed on the left-side, right-side, both
            or neither. Defaults to 'right'.
        name : object, optional
            Name to be stored in the index.
        copy : boolean, default False
            by-default copy the data, this is compat only and ignored

        Examples
        --------
        >>>  pd.IntervalIndex.from_tuples([(0, 1), (1,2)])
        IntervalIndex([(0, 1], (1, 2]],
                      closed='right', dtype='interval[int64]')

        See Also
        --------
        interval_range : Function to create a fixed frequency IntervalIndex
        IntervalIndex.from_arrays : Construct an IntervalIndex from a left and
                                    right array
        IntervalIndex.from_breaks : Construct an IntervalIndex from an array of
                                    splits
        IntervalIndex.from_intervals : Construct an IntervalIndex from an array
                                       of Interval objects
        """
        ...
    
    def to_tuples(self):
        ...
    
    @cache_readonly
    def _multiindex(self):
        ...
    
    @property
    def left(self):
        ...
    
    @property
    def right(self):
        ...
    
    @property
    def closed(self):
        ...
    
    def __len__(self):
        ...
    
    @cache_readonly
    def values(self):
        """
        Returns the IntervalIndex's data as a numpy array of Interval
        objects (with dtype='object')
        """
        ...
    
    def __array__(self, result: Optional[Any] = ...):
        """ the array interface, return my values """
        ...
    
    def __array_wrap__(self, result, context: Optional[Any] = ...):
        ...
    
    def _array_values(self):
        ...
    
    def __reduce__(self):
        ...
    
    @Appender(_index_shared_docs['copy'])
    def copy(self, deep: bool = ..., name: Optional[Any] = ...):
        ...
    
    @Appender(_index_shared_docs['astype'])
    def astype(self, dtype, copy: bool = ...):
        ...
    
    @cache_readonly
    def dtype(self):
        ...
    
    @property
    def inferred_type(self):
        ...
    
    @Appender(Index.memory_usage.__doc__)
    def memory_usage(self, deep: bool = ...):
        ...
    
    @cache_readonly
    def mid(self):
        """Returns the mid-point of each interval in the index as an array
        """
        ...
    
    @cache_readonly
    def is_monotonic(self):
        ...
    
    @cache_readonly
    def is_monotonic_increasing(self):
        ...
    
    @cache_readonly
    def is_monotonic_decreasing(self):
        ...
    
    @cache_readonly
    def is_unique(self):
        ...
    
    @cache_readonly
    def is_non_overlapping_monotonic(self):
        ...
    
    @Appender(_index_shared_docs['_convert_scalar_indexer'])
    def _convert_scalar_indexer(self, key, kind: Optional[Any] = ...):
        ...
    
    def _maybe_cast_slice_bound(self, label, side, kind):
        ...
    
    @Appender(_index_shared_docs['_convert_list_indexer'])
    def _convert_list_indexer(self, keyarr, kind: Optional[Any] = ...):
        """
        we are passed a list-like indexer. Return the
        indexer for matching intervals.
        """
        ...
    
    def _maybe_cast_indexed(self, key):
        """
        we need to cast the key, which could be a scalar
        or an array-like to the type of our subtype
        """
        ...
    
    def _check_method(self, method):
        ...
    
    def _searchsorted_monotonic(self, label, side, exclude_label: bool = ...):
        ...
    
    def _get_loc_only_exact_matches(self, key):
        ...
    
    def _find_non_overlapping_monotonic_bounds(self, key):
        ...
    
    def get_loc(self, key, method: Optional[Any] = ...):
        """Get integer location, slice or boolean mask for requested label.

        Parameters
        ----------
        key : label
        method : {None}, optional
            * default: matches where the label is within an interval only.

        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask

        Examples
        ---------
        >>> i1, i2 = pd.Interval(0, 1), pd.Interval(1, 2)
        >>> index = pd.IntervalIndex.from_intervals([i1, i2])
        >>> index.get_loc(1)
        0

        You can also supply an interval or an location for a point inside an
        interval.

        >>> index.get_loc(pd.Interval(0, 2))
        array([0, 1], dtype=int64)
        >>> index.get_loc(1.5)
        1

        If a label is in several intervals, you get the locations of all the
        relevant intervals.

        >>> i3 = pd.Interval(0, 2)
        >>> overlapping_index = pd.IntervalIndex.from_intervals([i2, i3])
        >>> overlapping_index.get_loc(1.5)
        array([0, 1], dtype=int64)
        """
        ...
    
    def get_value(self, series, key):
        ...
    
    @Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)
    def get_indexer(self, target, method: Optional[Any] = ..., limit: Optional[Any] = ..., tolerance: Optional[Any] = ...):
        ...
    
    def _get_reindexer(self, target):
        """
        Return an indexer for a target IntervalIndex with self
        """
        ...
    
    @Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)
    def get_indexer_non_unique(self, target):
        ...
    
    @Appender(_index_shared_docs['where'])
    def where(self, cond, other: Optional[Any] = ...):
        ...
    
    def delete(self, loc):
        ...
    
    def insert(self, loc, item):
        ...
    
    def _as_like_interval_index(self, other, error_msg):
        ...
    
    def _concat_same_dtype(self, to_concat, name):
        """
        assert that we all have the same .closed
        we allow a 0-len index here as well
        """
        ...
    
    @Appender(_index_shared_docs['take'] % _index_doc_kwargs)
    def take(self, indices, axis=..., allow_fill: bool = ..., fill_value: Optional[Any] = ..., **kwargs):
        ...
    
    def __getitem__(self, value):
        ...
    
    def _format_with_header(self, header, **kwargs):
        ...
    
    def _format_native_types(self, na_rep=..., quoting: Optional[Any] = ..., **kwargs):
        """ actually format my specific types """
        ...
    
    def _format_data(self, name: Optional[Any] = ...):
        ...
    
    def _format_attrs(self):
        ...
    
    def _format_space(self):
        ...
    
    def argsort(self, *args, **kwargs):
        ...
    
    def equals(self, other):
        ...
    
    def _setop(op_name):
        ...
    
    union = ...
    intersection = ...
    difference = ...
    symmetric_differnce = ...


def _is_valid_endpoint(endpoint):
    """helper for interval_range to check if start/end are valid types"""
    ...

def _is_type_compatible(a, b):
    """helper for interval_range to check type compat of start/end/freq"""
    ...

def interval_range(start: Optional[Any] = ..., end: Optional[Any] = ..., periods: Optional[Any] = ..., freq: Optional[Any] = ..., name: Optional[Any] = ..., closed=...):
    """
    Return a fixed frequency IntervalIndex

    Parameters
    ----------
    start : numeric or datetime-like, default None
        Left bound for generating intervals
    end : numeric or datetime-like, default None
        Right bound for generating intervals
    periods : integer, default None
        Number of periods to generate
    freq : numeric, string, or DateOffset, default None
        The length of each interval. Must be consistent with the type of start
        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1
        for numeric and 'D' (calendar daily) for datetime-like.
    name : string, default None
        Name of the resulting IntervalIndex
    closed : string, default 'right'
        options are: 'left', 'right', 'both', 'neither'

    Notes
    -----
    Of the three parameters: ``start``, ``end``, and ``periods``, exactly two
    must be specified.

    Returns
    -------
    rng : IntervalIndex

    Examples
    --------
    Numeric ``start`` and  ``end`` is supported.

    >>> pd.interval_range(start=0, end=5)
    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]]
                  closed='right', dtype='interval[int64]')

    Additionally, datetime-like input is also supported.

    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),
                          end=pd.Timestamp('2017-01-04'))
    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],
                   (2017-01-03, 2017-01-04]]
                  closed='right', dtype='interval[datetime64[ns]]')

    The ``freq`` parameter specifies the frequency between the left and right.
    endpoints of the individual intervals within the ``IntervalIndex``.  For
    numeric ``start`` and ``end``, the frequency must also be numeric.

    >>> pd.interval_range(start=0, periods=4, freq=1.5)
    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]]
                  closed='right', dtype='interval[float64]')

    Similarly, for datetime-like ``start`` and ``end``, the frequency must be
    convertible to a DateOffset.

    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),
                          periods=3, freq='MS')
    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],
                   (2017-03-01, 2017-04-01]]
                  closed='right', dtype='interval[datetime64[ns]]')

    The ``closed`` parameter specifies which endpoints of the individual
    intervals within the ``IntervalIndex`` are closed.

    >>> pd.interval_range(end=5, periods=4, closed='both')
    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]]
                  closed='both', dtype='interval[int64]')

    See Also
    --------
    IntervalIndex : an Index of intervals that are all closed on the same side.
    """
    ...

