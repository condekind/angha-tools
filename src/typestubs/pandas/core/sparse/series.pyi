"""
This type stub file was generated by pyright.
"""

from pandas.core.series import Series
from pandas.core import generic
from pandas.util._decorators import Appender
from typing import Any, Optional

"""
Data structures for sparse float data. Life is made simpler by dealing only
with float64 data
"""
_shared_doc_kwargs = dict(axes='index', klass='SparseSeries', axes_single_arg="{0, 'index'}", optional_labels='', optional_axis='')
def _arith_method(op, name, str_rep: Optional[Any] = ..., default_axis: Optional[Any] = ..., fill_zeros: Optional[Any] = ..., **eval_kwargs):
    """
    Wrapper function for Series arithmetic operations, to avoid
    code duplication.

    str_rep, default_axis, fill_zeros and eval_kwargs are not used, but are
    present for compatibility.
    """
    ...

def _sparse_series_op(left, right, op, name):
    ...

class SparseSeries(Series):
    """Data structure for labeled, sparse floating point data

    Parameters
    ----------
    data : {array-like, Series, SparseSeries, dict}
    kind : {'block', 'integer'}
    fill_value : float
        Code for missing value. Defaults depends on dtype.
        0 for int dtype, False for bool dtype, and NaN for other dtypes
    sparse_index : {BlockIndex, IntIndex}, optional
        Only if you have one. Mainly used internally

    Notes
    -----
    SparseSeries objects are immutable via the typical Python means. If you
    must change values, convert to dense, make your changes, then convert back
    to sparse
    """
    _subtyp = ...
    def __init__(self, data: Optional[Any] = ..., index: Optional[Any] = ..., sparse_index: Optional[Any] = ..., kind=..., fill_value: Optional[Any] = ..., name: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ..., fastpath: bool = ...):
        self.index = ...
        self.name = ...
    
    @property
    def values(self):
        """ return the array """
        ...
    
    def __array__(self, result: Optional[Any] = ...):
        """ the array interface, return my values """
        ...
    
    def get_values(self):
        """ same as values """
        ...
    
    @property
    def block(self):
        ...
    
    @property
    def fill_value(self):
        ...
    
    @fill_value.setter
    def fill_value(self, v):
        ...
    
    @property
    def sp_index(self):
        ...
    
    @property
    def sp_values(self):
        ...
    
    @property
    def npoints(self):
        ...
    
    @classmethod
    def from_array(cls, arr, index: Optional[Any] = ..., name: Optional[Any] = ..., copy: bool = ..., fill_value: Optional[Any] = ..., fastpath: bool = ...):
        """
        Simplified alternate constructor
        """
        ...
    
    @property
    def _constructor(self):
        ...
    
    @property
    def _constructor_expanddim(self):
        ...
    
    @property
    def kind(self):
        ...
    
    def as_sparse_array(self, kind: Optional[Any] = ..., fill_value: Optional[Any] = ..., copy: bool = ...):
        """ return my self as a sparse array, do not copy by default """
        ...
    
    def __len__(self):
        ...
    
    @property
    def shape(self):
        ...
    
    def __unicode__(self):
        ...
    
    def __array_wrap__(self, result, context: Optional[Any] = ...):
        """
        Gets called prior to a ufunc (and after)

        See SparseArray.__array_wrap__ for detail.
        """
        ...
    
    def __array_finalize__(self, obj):
        """
        Gets called after any ufunc or other array operations, necessary
        to pass on the index.
        """
        self.name = ...
        self.fill_value = ...
    
    def _reduce(self, op, name, axis=..., skipna: bool = ..., numeric_only: Optional[Any] = ..., filter_type: Optional[Any] = ..., **kwds):
        """ perform a reduction operation """
        ...
    
    def __getstate__(self):
        ...
    
    def _unpickle_series_compat(self, state):
        self.name = ...
    
    def __iter__(self):
        """ forward to the array """
        ...
    
    def _set_subtyp(self, is_all_dates):
        ...
    
    def _ixs(self, i, axis=...):
        """
        Return the i-th value or values in the SparseSeries by location

        Parameters
        ----------
        i : int, slice, or sequence of integers

        Returns
        -------
        value : scalar (int) or Series (slice, sequence)
        """
        ...
    
    def _get_val_at(self, loc):
        """ forward to the array """
        ...
    
    def __getitem__(self, key):
        ...
    
    def _get_values(self, indexer):
        ...
    
    def _set_with_engine(self, key, value):
        ...
    
    def abs(self):
        """
        Return an object with absolute value taken. Only applicable to objects
        that are all numeric

        Returns
        -------
        abs: type of caller
        """
        ...
    
    def get(self, label, default: Optional[Any] = ...):
        """
        Returns value occupying requested label, default to specified
        missing value if not present. Analogous to dict.get

        Parameters
        ----------
        label : object
            Label value looking for
        default : object, optional
            Value to return if label not in index

        Returns
        -------
        y : scalar
        """
        ...
    
    def get_value(self, label, takeable: bool = ...):
        """
        Retrieve single value at passed index label

        .. deprecated:: 0.21.0

        Please use .at[] or .iat[] accessors.

        Parameters
        ----------
        index : label
        takeable : interpret the index as indexers, default False

        Returns
        -------
        value : scalar value
        """
        ...
    
    def _get_value(self, label, takeable: bool = ...):
        ...
    
    def set_value(self, label, value, takeable: bool = ...):
        """
        Quickly set single value at passed label. If label is not contained, a
        new object is created with the label placed at the end of the result
        index

        .. deprecated:: 0.21.0

        Please use .at[] or .iat[] accessors.

        Parameters
        ----------
        label : object
            Partial indexing with MultiIndex not allowed
        value : object
            Scalar value
        takeable : interpret the index as indexers, default False

        Notes
        -----
        This method *always* returns a new object. It is not particularly
        efficient but is provided for API compatibility with Series

        Returns
        -------
        series : SparseSeries
        """
        ...
    
    def _set_value(self, label, value, takeable: bool = ...):
        ...
    
    def _set_values(self, key, value):
        ...
    
    def to_dense(self, sparse_only: bool = ...):
        """
        Convert SparseSeries to a Series.

        Parameters
        ----------
        sparse_only: bool, default False
            DEPRECATED: this argument will be removed in a future version.

            If True, return just the non-sparse values, or the dense version
            of `self.values` if False.

        Returns
        -------
        s : Series
        """
        ...
    
    @property
    def density(self):
        ...
    
    def copy(self, deep: bool = ...):
        """
        Make a copy of the SparseSeries. Only the actual sparse values need to
        be copied
        """
        ...
    
    @Appender(generic._shared_docs['reindex'] % _shared_doc_kwargs)
    def reindex(self, index: Optional[Any] = ..., method: Optional[Any] = ..., copy: bool = ..., limit: Optional[Any] = ..., **kwargs):
        ...
    
    def sparse_reindex(self, new_index):
        """
        Conform sparse values to new SparseIndex

        Parameters
        ----------
        new_index : {BlockIndex, IntIndex}

        Returns
        -------
        reindexed : SparseSeries
        """
        ...
    
    @Appender(generic._shared_docs['take'])
    def take(self, indices, axis=..., convert: Optional[Any] = ..., *args, **kwargs):
        ...
    
    def cumsum(self, axis=..., *args, **kwargs):
        """
        Cumulative sum of non-NA/null values.

        When performing the cumulative summation, any non-NA/null values will
        be skipped. The resulting SparseSeries will preserve the locations of
        NaN values, but the fill value will be `np.nan` regardless.

        Parameters
        ----------
        axis : {0}

        Returns
        -------
        cumsum : SparseSeries
        """
        ...
    
    @Appender(generic._shared_docs['isna'])
    def isna(self):
        ...
    
    isnull = ...
    @Appender(generic._shared_docs['notna'])
    def notna(self):
        ...
    
    notnull = ...
    def dropna(self, axis=..., inplace: bool = ..., **kwargs):
        """
        Analogous to Series.dropna. If fill_value=NaN, returns a dense Series
        """
        ...
    
    @Appender(generic._shared_docs['shift'] % _shared_doc_kwargs)
    def shift(self, periods, freq: Optional[Any] = ..., axis=...):
        ...
    
    def combine_first(self, other):
        """
        Combine Series values, choosing the calling Series's values
        first. Result index will be the union of the two indexes

        Parameters
        ----------
        other : Series

        Returns
        -------
        y : Series
        """
        ...
    
    def to_coo(self, row_levels=..., column_levels=..., sort_labels: bool = ...):
        """
        Create a scipy.sparse.coo_matrix from a SparseSeries with MultiIndex.

        Use row_levels and column_levels to determine the row and column
        coordinates respectively. row_levels and column_levels are the names
        (labels) or numbers of the levels. {row_levels, column_levels} must be
        a partition of the MultiIndex level names (or numbers).

        Parameters
        ----------
        row_levels : tuple/list
        column_levels : tuple/list
        sort_labels : bool, default False
            Sort the row and column labels before forming the sparse matrix.

        Returns
        -------
        y : scipy.sparse.coo_matrix
        rows : list (row labels)
        columns : list (column labels)

        Examples
        --------
        >>> from numpy import nan
        >>> s = Series([3.0, nan, 1.0, 3.0, nan, nan])
        >>> s.index = MultiIndex.from_tuples([(1, 2, 'a', 0),
                                              (1, 2, 'a', 1),
                                              (1, 1, 'b', 0),
                                              (1, 1, 'b', 1),
                                              (2, 1, 'b', 0),
                                              (2, 1, 'b', 1)],
                                              names=['A', 'B', 'C', 'D'])
        >>> ss = s.to_sparse()
        >>> A, rows, columns = ss.to_coo(row_levels=['A', 'B'],
                                         column_levels=['C', 'D'],
                                         sort_labels=True)
        >>> A
        <3x4 sparse matrix of type '<class 'numpy.float64'>'
                with 3 stored elements in COOrdinate format>
        >>> A.todense()
        matrix([[ 0.,  0.,  1.,  3.],
        [ 3.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.]])
        >>> rows
        [(1, 1), (1, 2), (2, 1)]
        >>> columns
        [('a', 0), ('a', 1), ('b', 0), ('b', 1)]
        """
        ...
    
    @classmethod
    def from_coo(cls, A, dense_index: bool = ...):
        """
        Create a SparseSeries from a scipy.sparse.coo_matrix.

        Parameters
        ----------
        A : scipy.sparse.coo_matrix
        dense_index : bool, default False
            If False (default), the SparseSeries index consists of only the
            coords of the non-null entries of the original coo_matrix.
            If True, the SparseSeries index consists of the full sorted
            (row, col) coordinates of the coo_matrix.

        Returns
        -------
        s : SparseSeries

        Examples
        ---------
        >>> from scipy import sparse
        >>> A = sparse.coo_matrix(([3.0, 1.0, 2.0], ([1, 0, 0], [0, 2, 3])),
                               shape=(3, 4))
        >>> A
        <3x4 sparse matrix of type '<class 'numpy.float64'>'
                with 3 stored elements in COOrdinate format>
        >>> A.todense()
        matrix([[ 0.,  0.,  1.,  2.],
                [ 3.,  0.,  0.,  0.],
                [ 0.,  0.,  0.,  0.]])
        >>> ss = SparseSeries.from_coo(A)
        >>> ss
        0  2    1
           3    2
        1  0    3
        dtype: float64
        BlockIndex
        Block locations: array([0], dtype=int32)
        Block lengths: array([3], dtype=int32)
        """
        ...
    


