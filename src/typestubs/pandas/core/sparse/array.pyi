"""
This type stub file was generated by pyright.
"""

import numpy as np
from pandas.core.base import PandasObject
from pandas import compat
from pandas.util._decorators import Appender
from pandas.core.indexes.base import _index_shared_docs
from typing import Any, Optional

"""
SparseArray data structure
"""
_sparray_doc_kwargs = dict(klass='SparseArray')
def _arith_method(op, name, str_rep: Optional[Any] = ..., default_axis: Optional[Any] = ..., fill_zeros: Optional[Any] = ..., **eval_kwargs):
    """
    Wrapper function for Series arithmetic operations, to avoid
    code duplication.
    """
    ...

def _get_fill(arr):
    ...

def _sparse_array_op(left, right, op, name, series: bool = ...):
    ...

def _wrap_result(name, data, sparse_index, fill_value, dtype: Optional[Any] = ...):
    """ wrap op result to have correct dtype """
    ...

class SparseArray(PandasObject, np.ndarray):
    """Data structure for labeled, sparse floating point 1-D data

    Parameters
    ----------
    data : {array-like (1-D), Series, SparseSeries, dict}
    kind : {'block', 'integer'}
    fill_value : float
        Code for missing value. Defaults depends on dtype.
        0 for int dtype, False for bool dtype, and NaN for other dtypes
    sparse_index : {BlockIndex, IntIndex}, optional
        Only if you have one. Mainly used internally

    Notes
    -----
    SparseArray objects are immutable via the typical Python means. If you
    must change values, convert to dense, make your changes, then convert back
    to sparse
    """
    __array_priority__ = ...
    _typ = ...
    _subtyp = ...
    sp_index = ...
    fill_value = ...
    def __new__(cls, data, sparse_index: Optional[Any] = ..., index: Optional[Any] = ..., kind=..., fill_value: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ...):
        ...
    
    @classmethod
    def _simple_new(cls, data, sp_index, fill_value):
        ...
    
    @property
    def _constructor(self):
        ...
    
    @property
    def kind(self):
        ...
    
    def __array_wrap__(self, out_arr, context: Optional[Any] = ...):
        """
        NumPy calls this method when ufunc is applied

        Parameters
        ----------

        out_arr : ndarray
            ufunc result (note that ufunc is only applied to sp_values)
        context : tuple of 3 elements (ufunc, signature, domain)
            for example, following is a context when np.sin is applied to
            SparseArray,

            (<ufunc 'sin'>, (SparseArray,), 0))

        See http://docs.scipy.org/doc/numpy/user/basics.subclassing.html
        """
        ...
    
    def __array_finalize__(self, obj):
        """
        Gets called after any ufunc or other array operations, necessary
        to pass on the index.
        """
        self.sp_index = ...
    
    def __reduce__(self):
        """Necessary for making this object picklable"""
        ...
    
    def __setstate__(self, state):
        """Necessary for making this object picklable"""
        self.sp_index = ...
    
    def __len__(self):
        ...
    
    def __unicode__(self):
        ...
    
    def disable(self, other):
        ...
    
    __iadd__ = ...
    __isub__ = ...
    __imul__ = ...
    __itruediv__ = ...
    __ifloordiv__ = ...
    __ipow__ = ...
    if not compat.PY3:
        __idiv__ = ...
    @property
    def values(self):
        """
        Dense values
        """
        ...
    
    @property
    def sp_values(self):
        ...
    
    @property
    def fill_value(self):
        ...
    
    @fill_value.setter
    def fill_value(self, value):
        ...
    
    def get_values(self, fill: Optional[Any] = ...):
        """ return a dense representation """
        ...
    
    def to_dense(self, fill: Optional[Any] = ...):
        """
        Convert SparseArray to a NumPy array.

        Parameters
        ----------
        fill: float, default None
            .. deprecated:: 0.20.0
               This argument is not respected by this function.

        Returns
        -------
        arr : NumPy array
        """
        ...
    
    def __iter__(self):
        ...
    
    def __getitem__(self, key):
        """

        """
        ...
    
    def __getslice__(self, i, j):
        ...
    
    def _get_val_at(self, loc):
        ...
    
    @Appender(_index_shared_docs['take'] % _sparray_doc_kwargs)
    def take(self, indices, axis=..., allow_fill: bool = ..., fill_value: Optional[Any] = ..., **kwargs):
        """
        Sparse-compatible version of ndarray.take

        Returns
        -------
        taken : ndarray
        """
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def __setslice__(self, i, j, value):
        ...
    
    def astype(self, dtype: Optional[Any] = ..., copy: bool = ...):
        ...
    
    def copy(self, deep: bool = ...):
        """
        Make a copy of the SparseArray. Only the actual sparse values need to
        be copied.
        """
        ...
    
    def count(self):
        """
        Compute sum of non-NA/null observations in SparseArray. If the
        fill_value is not NaN, the "sparse" locations will be included in the
        observation count.

        Returns
        -------
        nobs : int
        """
        ...
    
    @property
    def _null_fill_value(self):
        ...
    
    @property
    def _valid_sp_values(self):
        ...
    
    @Appender(_index_shared_docs['fillna'] % _sparray_doc_kwargs)
    def fillna(self, value, downcast: Optional[Any] = ...):
        ...
    
    def all(self, axis=..., *args, **kwargs):
        """
        Tests whether all elements evaluate True

        Returns
        -------
        all : bool

        See Also
        --------
        numpy.all
        """
        ...
    
    def any(self, axis=..., *args, **kwargs):
        """
        Tests whether at least one of elements evaluate True

        Returns
        -------
        any : bool

        See Also
        --------
        numpy.any
        """
        ...
    
    def sum(self, axis=..., *args, **kwargs):
        """
        Sum of non-NA/null values

        Returns
        -------
        sum : float
        """
        ...
    
    def cumsum(self, axis=..., *args, **kwargs):
        """
        Cumulative sum of non-NA/null values.

        When performing the cumulative summation, any non-NA/null values will
        be skipped. The resulting SparseArray will preserve the locations of
        NaN values, but the fill value will be `np.nan` regardless.

        Parameters
        ----------
        axis : int or None
            Axis over which to perform the cumulative summation. If None,
            perform cumulative summation over flattened array.

        Returns
        -------
        cumsum : SparseArray
        """
        ...
    
    def mean(self, axis=..., *args, **kwargs):
        """
        Mean of non-NA/null values

        Returns
        -------
        mean : float
        """
        ...
    
    def value_counts(self, dropna: bool = ...):
        """
        Returns a Series containing counts of unique values.

        Parameters
        ----------
        dropna : boolean, default True
            Don't include counts of NaN, even if NaN is in sp_values.

        Returns
        -------
        counts : Series
        """
        ...
    


def _maybe_to_dense(obj):
    """ try to convert to dense """
    ...

def _maybe_to_sparse(array):
    """ array must be SparseSeries or SparseArray """
    ...

def _sanitize_values(arr):
    """
    return an ndarray for our input,
    in a platform independent manner
    """
    ...

def make_sparse(arr, kind=..., fill_value: Optional[Any] = ...):
    """
    Convert ndarray to sparse format

    Parameters
    ----------
    arr : ndarray
    kind : {'block', 'integer'}
    fill_value : NaN or another value

    Returns
    -------
    (sparse_values, index) : (ndarray, SparseIndex)
    """
    ...

def _make_index(length, indices, kind):
    ...

