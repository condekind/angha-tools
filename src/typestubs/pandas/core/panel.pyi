"""
This type stub file was generated by pyright.
"""

from pandas.core.frame import DataFrame
from pandas.core.generic import NDFrame, _shared_docs
from pandas.util._decorators import Appender
from typing import Any, Optional

"""
Contains data structures designed for manipulating panel (3-dimensional) data
"""
_shared_doc_kwargs = dict(axes='items, major_axis, minor_axis', klass="Panel", axes_single_arg="{0, 1, 2, 'items', 'major_axis', 'minor_axis'}", optional_mapper='', optional_axis='', optional_labels='')
def _ensure_like_indices(time, panels):
    """
    Makes sure that time and panels are conformable
    """
    ...

def panel_index(time, panels, names: Optional[Any] = ...):
    """
    Returns a multi-index suitable for a panel-like DataFrame

    Parameters
    ----------
    time : array-like
        Time index, does not have to repeat
    panels : array-like
        Panel index, does not have to repeat
    names : list, optional
        List containing the names of the indices

    Returns
    -------
    multi_index : MultiIndex
        Time index is the first level, the panels are the second level.

    Examples
    --------
    >>> years = range(1960,1963)
    >>> panels = ['A', 'B', 'C']
    >>> panel_idx = panel_index(years, panels)
    >>> panel_idx
    MultiIndex([(1960, 'A'), (1961, 'A'), (1962, 'A'), (1960, 'B'),
                (1961, 'B'), (1962, 'B'), (1960, 'C'), (1961, 'C'),
                (1962, 'C')], dtype=object)

    or

    >>> import numpy as np
    >>> years = np.repeat(range(1960,1963), 3)
    >>> panels = np.tile(['A', 'B', 'C'], 3)
    >>> panel_idx = panel_index(years, panels)
    >>> panel_idx
    MultiIndex([(1960, 'A'), (1960, 'B'), (1960, 'C'), (1961, 'A'),
                (1961, 'B'), (1961, 'C'), (1962, 'A'), (1962, 'B'),
                (1962, 'C')], dtype=object)
    """
    ...

class Panel(NDFrame):
    """
    Represents wide format panel data, stored as 3-dimensional array

    Parameters
    ----------
    data : ndarray (items x major x minor), or dict of DataFrames
    items : Index or array-like
        axis=0
    major_axis : Index or array-like
        axis=1
    minor_axis : Index or array-like
        axis=2
    dtype : dtype, default None
        Data type to force, otherwise infer
    copy : boolean, default False
        Copy data from inputs. Only affects DataFrame / 2d ndarray input
    """
    @property
    def _constructor(self):
        ...
    
    _constructor_sliced = ...
    def __init__(self, data: Optional[Any] = ..., items: Optional[Any] = ..., major_axis: Optional[Any] = ..., minor_axis: Optional[Any] = ..., copy: bool = ..., dtype: Optional[Any] = ...):
        ...
    
    def _init_data(self, data, copy, dtype, **kwargs):
        """
        Generate ND initialization; axes are passed
        as required objects to __init__
        """
        ...
    
    def _init_dict(self, data, axes, dtype: Optional[Any] = ...):
        ...
    
    def _init_arrays(self, arrays, arr_names, axes):
        ...
    
    @classmethod
    def from_dict(cls, data, intersect: bool = ..., orient=..., dtype: Optional[Any] = ...):
        """
        Construct Panel from dict of DataFrame objects

        Parameters
        ----------
        data : dict
            {field : DataFrame}
        intersect : boolean
            Intersect indexes of input DataFrames
        orient : {'items', 'minor'}, default 'items'
            The "orientation" of the data. If the keys of the passed dict
            should be the items of the result panel, pass 'items'
            (default). Otherwise if the columns of the values of the passed
            DataFrame objects should be the items (which in the case of
            mixed-dtype data you should do), instead pass 'minor'
        dtype : dtype, default None
            Data type to force, otherwise infer

        Returns
        -------
        Panel
        """
        ...
    
    def __getitem__(self, key):
        ...
    
    def _getitem_multilevel(self, key):
        ...
    
    def _init_matrix(self, data, axes, dtype: Optional[Any] = ..., copy: bool = ...):
        ...
    
    def _compare_constructor(self, other, func, try_cast: bool = ...):
        ...
    
    def __unicode__(self):
        """
        Return a string representation for a particular Panel

        Invoked by unicode(df) in py2 only.
        Yields a Unicode String in both py2/py3.
        """
        ...
    
    def _get_plane_axes_index(self, axis):
        """
        Get my plane axes indexes: these are already
        (as compared with higher level planes),
        as we are returning a DataFrame axes indexes
        """
        ...
    
    def _get_plane_axes(self, axis):
        """
        Get my plane axes indexes: these are already
        (as compared with higher level planes),
        as we are returning a DataFrame axes
        """
        ...
    
    fromDict = ...
    def to_sparse(self, *args, **kwargs):
        """
        NOT IMPLEMENTED: do not call this method, as sparsifying is not
        supported for Panel objects and will raise an error.

        Convert to SparsePanel
        """
        ...
    
    def to_excel(self, path, na_rep=..., engine: Optional[Any] = ..., **kwargs):
        """
        Write each DataFrame in Panel to a separate excel sheet

        Parameters
        ----------
        path : string or ExcelWriter object
            File path or existing ExcelWriter
        na_rep : string, default ''
            Missing data representation
        engine : string, default None
            write engine to use - you can also set this via the options
            ``io.excel.xlsx.writer``, ``io.excel.xls.writer``, and
            ``io.excel.xlsm.writer``.

        Other Parameters
        ----------------
        float_format : string, default None
            Format string for floating point numbers
        cols : sequence, optional
            Columns to write
        header : boolean or list of string, default True
            Write out column names. If a list of string is given it is
            assumed to be aliases for the column names
        index : boolean, default True
            Write row names (index)
        index_label : string or sequence, default None
            Column label for index column(s) if desired. If None is given, and
            `header` and `index` are True, then the index names are used. A
            sequence should be given if the DataFrame uses MultiIndex.
        startrow : upper left cell row to dump data frame
        startcol : upper left cell column to dump data frame

        Notes
        -----
        Keyword arguments (and na_rep) are passed to the ``to_excel`` method
        for each DataFrame written.
        """
        ...
    
    def as_matrix(self):
        ...
    
    def get_value(self, *args, **kwargs):
        """
        Quickly retrieve single value at (item, major, minor) location

        .. deprecated:: 0.21.0

        Please use .at[] or .iat[] accessors.

        Parameters
        ----------
        item : item label (panel item)
        major : major axis label (panel item row)
        minor : minor axis label (panel item column)
        takeable : interpret the passed labels as indexers, default False

        Returns
        -------
        value : scalar value
        """
        ...
    
    def _get_value(self, *args, **kwargs):
        ...
    
    def set_value(self, *args, **kwargs):
        """
        Quickly set single value at (item, major, minor) location

        .. deprecated:: 0.21.0

        Please use .at[] or .iat[] accessors.

        Parameters
        ----------
        item : item label (panel item)
        major : major axis label (panel item row)
        minor : minor axis label (panel item column)
        value : scalar
        takeable : interpret the passed labels as indexers, default False

        Returns
        -------
        panel : Panel
            If label combo is contained, will be reference to calling Panel,
            otherwise a new object
        """
        ...
    
    def _set_value(self, *args, **kwargs):
        ...
    
    def _box_item_values(self, key, values):
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def _unpickle_panel_compat(self, state):
        "Unpickle the panel"
        ...
    
    def conform(self, frame, axis=...):
        """
        Conform input DataFrame to align with chosen axis pair.

        Parameters
        ----------
        frame : DataFrame
        axis : {'items', 'major', 'minor'}

            Axis the input corresponds to. E.g., if axis='major', then
            the frame's columns would be items, and the index would be
            values of the minor axis

        Returns
        -------
        DataFrame
        """
        ...
    
    def head(self, n=...):
        ...
    
    def tail(self, n=...):
        ...
    
    def round(self, decimals=..., *args, **kwargs):
        """
        Round each value in Panel to a specified number of decimal places.

        .. versionadded:: 0.18.0

        Parameters
        ----------
        decimals : int
            Number of decimal places to round to (default: 0).
            If decimals is negative, it specifies the number of
            positions to the left of the decimal point.

        Returns
        -------
        Panel object

        See Also
        --------
        numpy.around
        """
        ...
    
    def _needs_reindex_multi(self, axes, method, level):
        """ don't allow a multi reindex on Panel or above ndim """
        ...
    
    def align(self, other, **kwargs):
        ...
    
    def dropna(self, axis=..., how=..., inplace: bool = ...):
        """
        Drop 2D from panel, holding passed axis constant

        Parameters
        ----------
        axis : int, default 0
            Axis to hold constant. E.g. axis=1 will drop major_axis entries
            having a certain amount of NA data
        how : {'all', 'any'}, default 'any'
            'any': one or more values are NA in the DataFrame along the
            axis. For 'all' they all must be.
        inplace : bool, default False
            If True, do operation inplace and return None.

        Returns
        -------
        dropped : Panel
        """
        ...
    
    def _combine(self, other, func, axis=...):
        ...
    
    def _combine_const(self, other, func, try_cast: bool = ...):
        ...
    
    def _combine_frame(self, other, func, axis=..., try_cast: bool = ...):
        ...
    
    def _combine_panel(self, other, func, try_cast: bool = ...):
        ...
    
    def major_xs(self, key):
        """
        Return slice of panel along major axis

        Parameters
        ----------
        key : object
            Major axis label

        Returns
        -------
        y : DataFrame
            index -> minor axis, columns -> items

        Notes
        -----
        major_xs is only for getting, not setting values.

        MultiIndex Slicers is a generic way to get/set values on any level or
        levels and is a superset of major_xs functionality, see
        :ref:`MultiIndex Slicers <advanced.mi_slicers>`

        """
        ...
    
    def minor_xs(self, key):
        """
        Return slice of panel along minor axis

        Parameters
        ----------
        key : object
            Minor axis label

        Returns
        -------
        y : DataFrame
            index -> major axis, columns -> items

        Notes
        -----
        minor_xs is only for getting, not setting values.

        MultiIndex Slicers is a generic way to get/set values on any level or
        levels and is a superset of minor_xs functionality, see
        :ref:`MultiIndex Slicers <advanced.mi_slicers>`

        """
        ...
    
    def xs(self, key, axis=...):
        """
        Return slice of panel along selected axis

        Parameters
        ----------
        key : object
            Label
        axis : {'items', 'major', 'minor}, default 1/'major'

        Returns
        -------
        y : ndim(self)-1

        Notes
        -----
        xs is only for getting, not setting values.

        MultiIndex Slicers is a generic way to get/set values on any level or
        levels and  is a superset of xs functionality, see
        :ref:`MultiIndex Slicers <advanced.mi_slicers>`

        """
        ...
    
    _xs = ...
    def _ixs(self, i, axis=...):
        """
        i : int, slice, or sequence of integers
        axis : int
        """
        ...
    
    def groupby(self, function, axis=...):
        """
        Group data on given axis, returning GroupBy object

        Parameters
        ----------
        function : callable
            Mapping function for chosen access
        axis : {'major', 'minor', 'items'}, default 'major'

        Returns
        -------
        grouped : PanelGroupBy
        """
        ...
    
    def to_frame(self, filter_observations: bool = ...):
        """
        Transform wide format into long (stacked) format as DataFrame whose
        columns are the Panel's items and whose index is a MultiIndex formed
        of the Panel's major and minor axes.

        Parameters
        ----------
        filter_observations : boolean, default True
            Drop (major, minor) pairs without a complete set of observations
            across all the items

        Returns
        -------
        y : DataFrame
        """
        ...
    
    to_long = ...
    toLong = ...
    def apply(self, func, axis=..., **kwargs):
        """
        Applies function along axis (or axes) of the Panel

        Parameters
        ----------
        func : function
            Function to apply to each combination of 'other' axes
            e.g. if axis = 'items', the combination of major_axis/minor_axis
            will each be passed as a Series; if axis = ('items', 'major'),
            DataFrames of items & major axis will be passed
        axis : {'items', 'minor', 'major'}, or {0, 1, 2}, or a tuple with two
            axes
        Additional keyword arguments will be passed as keywords to the function

        Examples
        --------

        Returns a Panel with the square root of each element

        >>> p = pd.Panel(np.random.rand(4,3,2))
        >>> p.apply(np.sqrt)

        Equivalent to p.sum(1), returning a DataFrame

        >>> p.apply(lambda x: x.sum(), axis=1)

        Equivalent to previous:

        >>> p.apply(lambda x: x.sum(), axis='minor')

        Return the shapes of each DataFrame over axis 2 (i.e the shapes of
        items x major), as a Series

        >>> p.apply(lambda x: x.shape, axis=(0,1))

        Returns
        -------
        result : Panel, DataFrame, or Series
        """
        ...
    
    def _apply_1d(self, func, axis):
        ...
    
    def _apply_2d(self, func, axis):
        """ handle 2-d slices, equiv to iterating over the other axis """
        ...
    
    def _reduce(self, op, name, axis=..., skipna: bool = ..., numeric_only: Optional[Any] = ..., filter_type: Optional[Any] = ..., **kwds):
        ...
    
    def _construct_return_type(self, result, axes: Optional[Any] = ...):
        """ return the type for the ndim of the result """
        ...
    
    def _wrap_result(self, result, axis):
        ...
    
    @Appender(_shared_docs['reindex'] % _shared_doc_kwargs)
    def reindex(self, *args, **kwargs):
        ...
    
    @Appender(_shared_docs['rename'] % _shared_doc_kwargs)
    def rename(self, items: Optional[Any] = ..., major_axis: Optional[Any] = ..., minor_axis: Optional[Any] = ..., **kwargs):
        ...
    
    @Appender(_shared_docs['reindex_axis'] % _shared_doc_kwargs)
    def reindex_axis(self, labels, axis=..., method: Optional[Any] = ..., level: Optional[Any] = ..., copy: bool = ..., limit: Optional[Any] = ..., fill_value=...):
        ...
    
    @Appender(_shared_docs['transpose'] % _shared_doc_kwargs)
    def transpose(self, *args, **kwargs):
        ...
    
    @Appender(_shared_docs['fillna'] % _shared_doc_kwargs)
    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ..., axis: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., downcast: Optional[Any] = ..., **kwargs):
        ...
    
    def count(self, axis=...):
        """
        Return number of observations over requested axis.

        Parameters
        ----------
        axis : {'items', 'major', 'minor'} or {0, 1, 2}

        Returns
        -------
        count : DataFrame
        """
        ...
    
    def shift(self, periods=..., freq: Optional[Any] = ..., axis=...):
        """
        Shift index by desired number of periods with an optional time freq.
        The shifted data will not include the dropped periods and the
        shifted axis will be smaller than the original. This is different
        from the behavior of DataFrame.shift()

        Parameters
        ----------
        periods : int
            Number of periods to move, can be positive or negative
        freq : DateOffset, timedelta, or time rule string, optional
        axis : {'items', 'major', 'minor'} or {0, 1, 2}

        Returns
        -------
        shifted : Panel
        """
        ...
    
    def tshift(self, periods=..., freq: Optional[Any] = ..., axis=...):
        ...
    
    def join(self, other, how=..., lsuffix=..., rsuffix=...):
        """
        Join items with other Panel either on major and minor axes column

        Parameters
        ----------
        other : Panel or list of Panels
            Index should be similar to one of the columns in this one
        how : {'left', 'right', 'outer', 'inner'}
            How to handle indexes of the two objects. Default: 'left'
            for joining on index, None otherwise
            * left: use calling frame's index
            * right: use input frame's index
            * outer: form union of indexes
            * inner: use intersection of indexes
        lsuffix : string
            Suffix to use from left frame's overlapping columns
        rsuffix : string
            Suffix to use from right frame's overlapping columns

        Returns
        -------
        joined : Panel
        """
        ...
    
    def update(self, other, join=..., overwrite: bool = ..., filter_func: Optional[Any] = ..., raise_conflict: bool = ...):
        """
        Modify Panel in place using non-NA values from passed
        Panel, or object coercible to Panel. Aligns on items

        Parameters
        ----------
        other : Panel, or object coercible to Panel
        join : How to join individual DataFrames
            {'left', 'right', 'outer', 'inner'}, default 'left'
        overwrite : boolean, default True
            If True then overwrite values for common keys in the calling panel
        filter_func : callable(1d-array) -> 1d-array<boolean>, default None
            Can choose to replace values other than NA. Return True for values
            that should be updated
        raise_conflict : bool
            If True, will raise an error if a DataFrame and other both
            contain data in the same place.
        """
        ...
    
    def _get_join_index(self, other, how):
        ...
    
    @staticmethod
    def _extract_axes(self, data, axes, **kwargs):
        """ return a list of the axis indicies """
        ...
    
    @staticmethod
    def _extract_axes_for_slice(self, axes):
        """ return the slice dictionary for these axes """
        ...
    
    @staticmethod
    def _prep_ndarray(self, values, copy: bool = ...):
        ...
    
    @staticmethod
    def _homogenize_dict(self, frames, intersect: bool = ..., dtype: Optional[Any] = ...):
        """
        Conform set of _constructor_sliced-like objects to either
        an intersection of indices / columns or a union.

        Parameters
        ----------
        frames : dict
        intersect : boolean, default True

        Returns
        -------
        dict of aligned results & indicies
        """
        ...
    
    @staticmethod
    def _extract_axis(self, data, axis=..., intersect: bool = ...):
        ...
    
    @classmethod
    def _add_aggregate_operations(cls, use_numexpr: bool = ...):
        """ add the operations to the cls; evaluate the doc strings again """
        ...
    


class WidePanel(Panel):
    def __init__(self, *args, **kwargs):
        ...
    


class LongPanel(DataFrame):
    def __init__(self, *args, **kwargs):
        ...
    


