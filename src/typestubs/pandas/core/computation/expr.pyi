"""
This type stub file was generated by pyright.
"""

import ast
from pandas import compat
from pandas.compat import string_types
from pandas.core.base import StringMixin
from pandas.core.computation.ops import BinOp, UnaryOp, _mathops, _reductions
from typing import Any, Optional

""":func:`~pandas.eval` parsers
"""
def tokenize_string(source):
    """Tokenize a Python source code string.

    Parameters
    ----------
    source : str
        A Python source code string
    """
    ...

def _rewrite_assign(tok):
    """Rewrite the assignment operator for PyTables expressions that use ``=``
    as a substitute for ``==``.

    Parameters
    ----------
    tok : tuple of int, str
        ints correspond to the all caps constants in the tokenize module

    Returns
    -------
    t : tuple of int, str
        Either the input or token or the replacement values
    """
    ...

def _replace_booleans(tok):
    """Replace ``&`` with ``and`` and ``|`` with ``or`` so that bitwise
    precedence is changed to boolean precedence.

    Parameters
    ----------
    tok : tuple of int, str
        ints correspond to the all caps constants in the tokenize module

    Returns
    -------
    t : tuple of int, str
        Either the input or token or the replacement values
    """
    ...

def _replace_locals(tok):
    """Replace local variables with a syntactically valid name.

    Parameters
    ----------
    tok : tuple of int, str
        ints correspond to the all caps constants in the tokenize module

    Returns
    -------
    t : tuple of int, str
        Either the input or token or the replacement values

    Notes
    -----
    This is somewhat of a hack in that we rewrite a string such as ``'@a'`` as
    ``'__pd_eval_local_a'`` by telling the tokenizer that ``__pd_eval_local_``
    is a ``tokenize.OP`` and to replace the ``'@'`` symbol with it.
    """
    ...

def _preparse(source, f=...):
    """Compose a collection of tokenization functions

    Parameters
    ----------
    source : str
        A Python source code string
    f : callable
        This takes a tuple of (toknum, tokval) as its argument and returns a
        tuple with the same structure but possibly different elements. Defaults
        to the composition of ``_rewrite_assign``, ``_replace_booleans``, and
        ``_replace_locals``.

    Returns
    -------
    s : str
        Valid Python source code

    Notes
    -----
    The `f` parameter can be any callable that takes *and* returns input of the
    form ``(toknum, tokval)``, where ``toknum`` is one of the constants from
    the ``tokenize`` module and ``tokval`` is a string.
    """
    ...

def _is_type(t):
    """Factory for a type checking function of type ``t`` or tuple of types."""
    ...

_is_list = _is_type(list)
_is_str = _is_type(string_types)
_all_nodes = frozenset(filter(lambda x: isinstance(x, type) and issubclass(x, ast.AST), getattr(ast, node) for node in dir(ast)))
def _filter_nodes(superclass, all_nodes=...):
    """Filter out AST nodes that are subclasses of ``superclass``."""
    ...

_all_node_names = frozenset(map(lambda x: x.__name__, _all_nodes))
_mod_nodes = _filter_nodes(ast.mod)
_stmt_nodes = _filter_nodes(ast.stmt)
_expr_nodes = _filter_nodes(ast.expr)
_expr_context_nodes = _filter_nodes(ast.expr_context)
_slice_nodes = _filter_nodes(ast.slice)
_boolop_nodes = _filter_nodes(ast.boolop)
_operator_nodes = _filter_nodes(ast.operator)
_unary_op_nodes = _filter_nodes(ast.unaryop)
_cmp_op_nodes = _filter_nodes(ast.cmpop)
_comprehension_nodes = _filter_nodes(ast.comprehension)
_handler_nodes = _filter_nodes(ast.excepthandler)
_arguments_nodes = _filter_nodes(ast.arguments)
_keyword_nodes = _filter_nodes(ast.keyword)
_alias_nodes = _filter_nodes(ast.alias)
_hacked_nodes = frozenset(['Assign', 'Module', 'Expr'])
_unsupported_expr_nodes = frozenset(['Yield', 'GeneratorExp', 'IfExp', 'DictComp', 'SetComp', 'Repr', 'Lambda', 'Set', 'AST', 'Is', 'IsNot'])
_unsupported_nodes = _stmt_nodes | _mod_nodes | _handler_nodes | _arguments_nodes | _keyword_nodes | _alias_nodes | _expr_context_nodes | _unsupported_expr_nodes - _hacked_nodes
_base_supported_nodes = _all_node_names - _unsupported_nodes | _hacked_nodes
_msg = 'cannot both support and not support {intersection}'.format(intersection=_unsupported_nodes & _base_supported_nodes)
def _node_not_implemented(node_name, cls):
    """Return a function that raises a NotImplementedError with a passed node
    name.
    """
    ...

def disallow(nodes):
    """Decorator to disallow certain nodes from parsing. Raises a
    NotImplementedError instead.

    Returns
    -------
    disallowed : callable
    """
    ...

def _op_maker(op_class, op_symbol):
    """Return a function to create an op class with its symbol already passed.

    Returns
    -------
    f : callable
    """
    ...

_op_classes = { 'binary': BinOp,'unary': UnaryOp }
def add_ops(op_classes):
    """Decorator to add default implementation of ops."""
    ...

@disallow(_unsupported_nodes)
@add_ops(_op_classes)
class BaseExprVisitor(ast.NodeVisitor):
    """Custom ast walker. Parsers of other engines should subclass this class
    if necessary.

    Parameters
    ----------
    env : Scope
    engine : str
    parser : str
    preparser : callable
    """
    const_type = ...
    term_type = ...
    binary_ops = ...
    binary_op_nodes = ...
    binary_op_nodes_map = ...
    unary_ops = ...
    unary_op_nodes = ...
    unary_op_nodes_map = ...
    rewrite_map = ...
    def __init__(self, env, engine, parser, preparser=...):
        self.env = ...
        self.engine = ...
        self.parser = ...
        self.preparser = ...
        self.assigner = ...
    
    def visit(self, node, **kwargs):
        ...
    
    def visit_Module(self, node, **kwargs):
        ...
    
    def visit_Expr(self, node, **kwargs):
        ...
    
    def _rewrite_membership_op(self, node, left, right):
        ...
    
    def _maybe_transform_eq_ne(self, node, left: Optional[Any] = ..., right: Optional[Any] = ...):
        ...
    
    def _maybe_downcast_constants(self, left, right):
        ...
    
    def _maybe_eval(self, binop, eval_in_python):
        ...
    
    def _maybe_evaluate_binop(self, op, op_class, lhs, rhs, eval_in_python=..., maybe_eval_in_python=...):
        ...
    
    def visit_BinOp(self, node, **kwargs):
        ...
    
    def visit_Div(self, node, **kwargs):
        ...
    
    def visit_UnaryOp(self, node, **kwargs):
        ...
    
    def visit_Name(self, node, **kwargs):
        ...
    
    def visit_NameConstant(self, node, **kwargs):
        ...
    
    def visit_Num(self, node, **kwargs):
        ...
    
    def visit_Str(self, node, **kwargs):
        ...
    
    def visit_List(self, node, **kwargs):
        ...
    
    visit_Tuple = ...
    def visit_Index(self, node, **kwargs):
        """ df.index[4] """
        ...
    
    def visit_Subscript(self, node, **kwargs):
        ...
    
    def visit_Slice(self, node, **kwargs):
        """ df.index[slice(4,6)] """
        ...
    
    def visit_Assign(self, node, **kwargs):
        """
        support a single assignment node, like

        c = a + b

        set the assigner at the top level, must be a Name node which
        might or might not exist in the resolvers

        """
        self.assigner = ...
    
    def visit_Attribute(self, node, **kwargs):
        ...
    
    def visit_Call_35(self, node, side: Optional[Any] = ..., **kwargs):
        """ in 3.5 the starargs attribute was changed to be more flexible,
        #11097 """
        ...
    
    def visit_Call_legacy(self, node, side: Optional[Any] = ..., **kwargs):
        ...
    
    def translate_In(self, op):
        ...
    
    def visit_Compare(self, node, **kwargs):
        ...
    
    def _try_visit_binop(self, bop):
        ...
    
    def visit_BoolOp(self, node, **kwargs):
        ...
    


if compat.PY35:
    ...
else:
    ...
_python_not_supported = frozenset(['Dict', 'BoolOp', 'In', 'NotIn'])
_numexpr_supported_calls = frozenset(_reductions + _mathops)
@disallow(_unsupported_nodes | _python_not_supported - _boolop_nodes | frozenset(['BoolOp', 'Attribute', 'In', 'NotIn', 'Tuple']))
class PandasExprVisitor(BaseExprVisitor):
    def __init__(self, env, engine, parser, preparser=...):
        ...
    


@disallow(_unsupported_nodes | _python_not_supported | frozenset(['Not']))
class PythonExprVisitor(BaseExprVisitor):
    def __init__(self, env, engine, parser, preparser=...):
        ...
    


class Expr(StringMixin):
    """Object encapsulating an expression.

    Parameters
    ----------
    expr : str
    engine : str, optional, default 'numexpr'
    parser : str, optional, default 'pandas'
    env : Scope, optional, default None
    truediv : bool, optional, default True
    level : int, optional, default 2
    """
    def __init__(self, expr, engine=..., parser=..., env: Optional[Any] = ..., truediv: bool = ..., level=...):
        self.expr = ...
        self.env = ...
        self.engine = ...
        self.parser = ...
        self.terms = ...
    
    @property
    def assigner(self):
        ...
    
    def __call__(self):
        ...
    
    def __unicode__(self):
        ...
    
    def __len__(self):
        ...
    
    def parse(self):
        """Parse an expression"""
        ...
    
    @property
    def names(self):
        """Get the names in an expression"""
        ...
    


_parsers = { 'python': PythonExprVisitor,'pandas': PandasExprVisitor }
