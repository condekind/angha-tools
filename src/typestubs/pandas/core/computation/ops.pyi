"""
This type stub file was generated by pyright.
"""

import operator as op
from pandas.compat import PY3
from pandas.core.base import StringMixin
from typing import Any, Optional

"""Operator classes for eval.
"""
_reductions = ('sum', 'prod')
_unary_math_ops = ('sin', 'cos', 'exp', 'log', 'expm1', 'log1p', 'sqrt', 'sinh', 'cosh', 'tanh', 'arcsin', 'arccos', 'arctan', 'arccosh', 'arcsinh', 'arctanh', 'abs')
_binary_math_ops = ('arctan2', )
_mathops = _unary_math_ops + _binary_math_ops
_LOCAL_TAG = '__pd_eval_local_'
class UndefinedVariableError(NameError):
    """NameError subclass for local variables."""
    def __init__(self, name, is_local):
        ...
    


class Term(StringMixin):
    def __new__(cls, name, env, side: Optional[Any] = ..., encoding: Optional[Any] = ...):
        ...
    
    def __init__(self, name, env, side: Optional[Any] = ..., encoding: Optional[Any] = ...):
        self.env = ...
        self.side = ...
        self.is_local = ...
        self.encoding = ...
    
    @property
    def local_name(self):
        ...
    
    def __unicode__(self):
        ...
    
    def __call__(self, *args, **kwargs):
        ...
    
    def evaluate(self, *args, **kwargs):
        ...
    
    def _resolve_name(self):
        ...
    
    def update(self, value):
        """
        search order for local (i.e., @variable) variables:

        scope, key_variable
        [('locals', 'local_name'),
         ('globals', 'local_name'),
         ('locals', 'key'),
         ('globals', 'key')]
        """
        self.value = ...
    
    @property
    def isscalar(self):
        ...
    
    @property
    def type(self):
        ...
    
    return_type = ...
    @property
    def raw(self):
        ...
    
    @property
    def is_datetime(self):
        ...
    
    @property
    def value(self):
        ...
    
    @value.setter
    def value(self, new_value):
        ...
    
    @property
    def name(self):
        ...
    
    @name.setter
    def name(self, new_name):
        ...
    
    @property
    def ndim(self):
        ...
    


class Constant(Term):
    def __init__(self, value, env, side: Optional[Any] = ..., encoding: Optional[Any] = ...):
        ...
    
    def _resolve_name(self):
        ...
    
    @property
    def name(self):
        ...
    
    def __unicode__(self):
        ...
    


_bool_op_map = { 'not': '~','and': '&','or': '|' }
class Op(StringMixin):
    """Hold an operator of arbitrary arity
    """
    def __init__(self, op, operands, *args, **kwargs):
        self.op = ...
        self.operands = ...
        self.encoding = ...
    
    def __iter__(self):
        ...
    
    def __unicode__(self):
        """Print a generic n-ary operator and its operands using infix
        notation"""
        ...
    
    @property
    def return_type(self):
        ...
    
    @property
    def has_invalid_return_type(self):
        ...
    
    @property
    def operand_types(self):
        ...
    
    @property
    def isscalar(self):
        ...
    
    @property
    def is_datetime(self):
        ...
    


def _in(x, y):
    """Compute the vectorized membership of ``x in y`` if possible, otherwise
    use Python.
    """
    ...

def _not_in(x, y):
    """Compute the vectorized membership of ``x not in y`` if possible,
    otherwise use Python.
    """
    ...

_cmp_ops_syms = ('>', '<', '>=', '<=', '==', '!=', 'in', 'not in')
_cmp_ops_funcs = (op.gt, op.lt, op.ge, op.le, op.eq, op.ne, _in, _not_in)
_cmp_ops_dict = dict(zip(_cmp_ops_syms, _cmp_ops_funcs))
_bool_ops_syms = ('&', '|', 'and', 'or')
_bool_ops_funcs = (op.and_, op.or_, op.and_, op.or_)
_bool_ops_dict = dict(zip(_bool_ops_syms, _bool_ops_funcs))
_arith_ops_syms = ('+', '-', '*', '/', '**', '//', '%')
_arith_ops_funcs = (op.add, op.sub, op.mul, op.truediv if PY3 else op.div, op.pow, op.floordiv, op.mod)
_arith_ops_dict = dict(zip(_arith_ops_syms, _arith_ops_funcs))
_special_case_arith_ops_syms = ('**', '//', '%')
_special_case_arith_ops_funcs = (op.pow, op.floordiv, op.mod)
_special_case_arith_ops_dict = dict(zip(_special_case_arith_ops_syms, _special_case_arith_ops_funcs))
_binary_ops_dict = {  }
def _cast_inplace(terms, acceptable_dtypes, dtype):
    """Cast an expression inplace.

    Parameters
    ----------
    terms : Op
        The expression that should cast.
    acceptable_dtypes : list of acceptable numpy.dtype
        Will not cast if term's dtype in this list.

        .. versionadded:: 0.19.0

    dtype : str or numpy.dtype
        The dtype to cast to.
    """
    ...

def is_term(obj):
    ...

class BinOp(Op):
    """Hold a binary operator and its operands

    Parameters
    ----------
    op : str
    left : Term or Op
    right : Term or Op
    """
    def __init__(self, op, lhs, rhs, **kwargs):
        self.lhs = ...
        self.rhs = ...
    
    def __call__(self, env):
        """Recursively evaluate an expression in Python space.

        Parameters
        ----------
        env : Scope

        Returns
        -------
        object
            The result of an evaluated expression.
        """
        ...
    
    def evaluate(self, env, engine, parser, term_type, eval_in_python):
        """Evaluate a binary operation *before* being passed to the engine.

        Parameters
        ----------
        env : Scope
        engine : str
        parser : str
        term_type : type
        eval_in_python : list

        Returns
        -------
        term_type
            The "pre-evaluated" expression as an instance of ``term_type``
        """
        ...
    
    def convert_values(self):
        """Convert datetimes to a comparable value in an expression.
        """
        ...
    
    def _disallow_scalar_only_bool_ops(self):
        ...
    


def isnumeric(dtype):
    ...

class Div(BinOp):
    """Div operator to special case casting.

    Parameters
    ----------
    lhs, rhs : Term or Op
        The Terms or Ops in the ``/`` expression.
    truediv : bool
        Whether or not to use true division. With Python 3 this happens
        regardless of the value of ``truediv``.
    """
    def __init__(self, lhs, rhs, truediv, *args, **kwargs):
        ...
    


_unary_ops_syms = ('+', '-', '~', 'not')
_unary_ops_funcs = (op.pos, op.neg, op.invert, op.invert)
_unary_ops_dict = dict(zip(_unary_ops_syms, _unary_ops_funcs))
class UnaryOp(Op):
    """Hold a unary operator and its operands

    Parameters
    ----------
    op : str
        The token used to represent the operator.
    operand : Term or Op
        The Term or Op operand to the operator.

    Raises
    ------
    ValueError
        * If no function associated with the passed operator token is found.
    """
    def __init__(self, op, operand):
        self.operand = ...
    
    def __call__(self, env):
        ...
    
    def __unicode__(self):
        ...
    
    @property
    def return_type(self):
        ...
    


class MathCall(Op):
    def __init__(self, func, args):
        self.func = ...
    
    def __call__(self, env):
        ...
    
    def __unicode__(self):
        ...
    


class FuncNode(object):
    def __init__(self, name):
        self.name = ...
        self.func = ...
    
    def __call__(self, *args):
        ...
    


