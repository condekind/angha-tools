"""
This type stub file was generated by pyright.
"""

from pandas.core.computation import expr, ops
from pandas.core.computation.expr import BaseExprVisitor
from typing import Any, Optional

""" manage PyTables query interface via Expressions """
class Scope(expr.Scope):
    __slots__ = ...
    def __init__(self, level, global_dict: Optional[Any] = ..., local_dict: Optional[Any] = ..., queryables: Optional[Any] = ...):
        self.queryables = ...
    


class Term(ops.Term):
    def __new__(cls, name, env, side: Optional[Any] = ..., encoding: Optional[Any] = ...):
        ...
    
    def __init__(self, name, env, side: Optional[Any] = ..., encoding: Optional[Any] = ...):
        ...
    
    def _resolve_name(self):
        ...
    
    @property
    def value(self):
        ...
    


class Constant(Term):
    def __init__(self, value, env, side: Optional[Any] = ..., encoding: Optional[Any] = ...):
        ...
    
    def _resolve_name(self):
        ...
    


class BinOp(ops.BinOp):
    _max_selectors = ...
    def __init__(self, op, lhs, rhs, queryables, encoding):
        self.queryables = ...
        self.encoding = ...
        self.filter = ...
        self.condition = ...
    
    def _disallow_scalar_only_bool_ops(self):
        ...
    
    def prune(self, klass):
        ...
    
    def conform(self, rhs):
        """ inplace conform rhs """
        ...
    
    @property
    def is_valid(self):
        """ return True if this is a valid field """
        ...
    
    @property
    def is_in_table(self):
        """ return True if this is a valid column name for generation (e.g. an
        actual column in the table) """
        ...
    
    @property
    def kind(self):
        """ the kind of my field """
        ...
    
    @property
    def meta(self):
        """ the meta of my field """
        ...
    
    @property
    def metadata(self):
        """ the metadata of my field """
        ...
    
    def generate(self, v):
        """ create and return the op string for this TermValue """
        ...
    
    def convert_value(self, v):
        """ convert the expression that is in the term to something that is
        accepted by pytables """
        ...
    
    def convert_values(self):
        ...
    


class FilterBinOp(BinOp):
    def __unicode__(self):
        ...
    
    def invert(self):
        """ invert the filter """
        ...
    
    def format(self):
        """ return the actual filter format """
        ...
    
    def evaluate(self):
        ...
    
    def generate_filter_op(self, invert: bool = ...):
        ...
    


class JointFilterBinOp(FilterBinOp):
    def format(self):
        ...
    
    def evaluate(self):
        ...
    


class ConditionBinOp(BinOp):
    def __unicode__(self):
        ...
    
    def invert(self):
        """ invert the condition """
        ...
    
    def format(self):
        """ return the actual ne format """
        ...
    
    def evaluate(self):
        ...
    


class JointConditionBinOp(ConditionBinOp):
    def evaluate(self):
        self.condition = ...
    


class UnaryOp(ops.UnaryOp):
    def prune(self, klass):
        ...
    


_op_classes = { 'unary': UnaryOp }
class ExprVisitor(BaseExprVisitor):
    const_type = ...
    term_type = ...
    def __init__(self, env, engine, parser, **kwargs):
        ...
    
    def visit_UnaryOp(self, node, **kwargs):
        ...
    
    def visit_Index(self, node, **kwargs):
        ...
    
    def visit_Assign(self, node, **kwargs):
        ...
    
    def visit_Subscript(self, node, **kwargs):
        ...
    
    def visit_Attribute(self, node, **kwargs):
        ...
    
    def translate_In(self, op):
        ...
    
    def _rewrite_membership_op(self, node, left, right):
        ...
    


def _validate_where(w):
    """
    Validate that the where statement is of the right type.

    The type may either be String, Expr, or list-like of Exprs.

    Parameters
    ----------
    w : String term expression, Expr, or list-like of Exprs.

    Returns
    -------
    where : The original where clause if the check was successful.

    Raises
    ------
    TypeError : An invalid data type was passed in for w (e.g. dict).
    """
    ...

class Expr(expr.Expr):
    """ hold a pytables like expression, comprised of possibly multiple 'terms'

    Parameters
    ----------
    where : string term expression, Expr, or list-like of Exprs
    queryables : a "kinds" map (dict of column name -> kind), or None if column
        is non-indexable
    encoding : an encoding that will encode the query terms

    Returns
    -------
    an Expr object

    Examples
    --------

    'index>=date'
    "columns=['A', 'D']"
    'columns=A'
    'columns==A'
    "~(columns=['A','B'])"
    'index>df.index[3] & string="bar"'
    '(index>df.index[3] & index<=df.index[6]) | string="bar"'
    "ts>=Timestamp('2012-02-01')"
    "major_axis>=20130101"
    """
    def __init__(self, where, queryables: Optional[Any] = ..., encoding: Optional[Any] = ..., scope_level=...):
        self.encoding = ...
        self.condition = ...
        self.filter = ...
        self.terms = ...
        self.expr = ...
        self.env = ...
    
    def __unicode__(self):
        ...
    
    def evaluate(self):
        """ create and return the numexpr condition and filter """
        ...
    


class TermValue(object):
    """ hold a term value the we use to construct a condition/filter """
    def __init__(self, value, converted, kind):
        self.value = ...
        self.converted = ...
        self.kind = ...
    
    def tostring(self, encoding):
        """ quote the string if not encoded
            else encode and return """
        ...
    


def maybe_expression(s):
    """ loose checking if s is a pytables-acceptable expression """
    ...

