"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

""" define extension dtypes """
class ExtensionDtype(object):
    """
    A np.dtype duck-typed class, suitable for holding a custom dtype.

    THIS IS NOT A REAL NUMPY DTYPE
    """
    name = ...
    names = ...
    type = ...
    subdtype = ...
    kind = ...
    str = ...
    num = ...
    shape = ...
    itemsize = ...
    base = ...
    isbuiltin = ...
    isnative = ...
    _metadata = ...
    _cache = ...
    def __unicode__(self):
        ...
    
    def __str__(self):
        """
        Return a string representation for a particular Object

        Invoked by str(df) in both py2/py3.
        Yields Bytestring in Py2, Unicode String in py3.
        """
        ...
    
    def __bytes__(self):
        """
        Return a string representation for a particular object.

        Invoked by bytes(obj) in py3 only.
        Yields a bytestring in both py2/py3.
        """
        ...
    
    def __repr__(self):
        """
        Return a string representation for a particular object.

        Yields Bytestring in Py2, Unicode String in py3.
        """
        ...
    
    def __hash__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __getstate__(self):
        ...
    
    @classmethod
    def reset_cache(cls):
        """ clear the cache """
        ...
    
    @classmethod
    def is_dtype(cls, dtype):
        """ Return a boolean if the passed type is an actual dtype that
        we can match (via string or type)
        """
        ...
    


class CategoricalDtypeType(type):
    """
    the type of CategoricalDtype, this metaclass determines subclass ability
    """
    ...


class CategoricalDtype(ExtensionDtype):
    """
    Type for categorical data with the categories and orderedness

    .. versionchanged:: 0.21.0

    Parameters
    ----------
    categories : sequence, optional
        Must be unique, and must not contain any nulls.
    ordered : bool, default False

    Notes
    -----
    This class is useful for specifying the type of a ``Categorical``
    independent of the values. See :ref:`categorical.categoricaldtype`
    for more.

    Examples
    --------
    >>> t = CategoricalDtype(categories=['b', 'a'], ordered=True)
    >>> pd.Series(['a', 'b', 'a', 'c'], dtype=t)
    0      a
    1      b
    2      a
    3    NaN
    dtype: category
    Categories (2, object): [b < a]

    See Also
    --------
    pandas.Categorical
    """
    name = ...
    type = ...
    kind = ...
    str = ...
    base = ...
    _metadata = ...
    _cache = ...
    def __init__(self, categories: Optional[Any] = ..., ordered: bool = ...):
        ...
    
    @classmethod
    def _from_fastpath(cls, categories: Optional[Any] = ..., ordered: bool = ...):
        ...
    
    @classmethod
    def _from_categorical_dtype(cls, dtype, categories: Optional[Any] = ..., ordered: Optional[Any] = ...):
        ...
    
    def _finalize(self, categories, ordered, fastpath: bool = ...):
        ...
    
    def __setstate__(self, state):
        ...
    
    def __hash__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __repr__(self):
        ...
    
    @staticmethod
    def _hash_categories(categories, ordered: bool = ...):
        ...
    
    @classmethod
    def construct_from_string(cls, string):
        """ attempt to construct this type from a string, raise a TypeError if
        it's not possible """
        ...
    
    @staticmethod
    def _validate_ordered(ordered):
        """
        Validates that we have a valid ordered parameter. If
        it is not a boolean, a TypeError will be raised.

        Parameters
        ----------
        ordered : object
            The parameter to be verified.

        Raises
        ------
        TypeError
            If 'ordered' is not a boolean.
        """
        ...
    
    @staticmethod
    def _validate_categories(categories, fastpath: bool = ...):
        """
        Validates that we have good categories

        Parameters
        ----------
        categories : array-like
        fastpath : bool
            Whether to skip nan and uniqueness checks

        Returns
        -------
        categories : Index
        """
        ...
    
    @property
    def categories(self):
        """
        An ``Index`` containing the unique categories allowed.
        """
        ...
    
    @property
    def ordered(self):
        """Whether the categories have an ordered relationship"""
        ...
    


class DatetimeTZDtypeType(type):
    """
    the type of DatetimeTZDtype, this metaclass determines subclass ability
    """
    ...


class DatetimeTZDtype(ExtensionDtype):
    """
    A np.dtype duck-typed class, suitable for holding a custom datetime with tz
    dtype.

    THIS IS NOT A REAL NUMPY DTYPE, but essentially a sub-class of
    np.datetime64[ns]
    """
    type = ...
    kind = ...
    str = ...
    num = ...
    base = ...
    _metadata = ...
    _match = ...
    _cache = ...
    def __new__(cls, unit: Optional[Any] = ..., tz: Optional[Any] = ...):
        """ Create a new unit if needed, otherwise return from the cache

        Parameters
        ----------
        unit : string unit that this represents, currently must be 'ns'
        tz : string tz that this represents
        """
        ...
    
    @classmethod
    def construct_from_string(cls, string):
        """ attempt to construct this type from a string, raise a TypeError if
        it's not possible
        """
        ...
    
    def __unicode__(self):
        ...
    
    @property
    def name(self):
        ...
    
    def __hash__(self):
        ...
    
    def __eq__(self, other):
        ...
    


class PeriodDtypeType(type):
    """
    the type of PeriodDtype, this metaclass determines subclass ability
    """
    ...


class PeriodDtype(ExtensionDtype):
    __metaclass__ = ...
    type = ...
    kind = ...
    str = ...
    base = ...
    num = ...
    _metadata = ...
    _match = ...
    _cache = ...
    def __new__(cls, freq: Optional[Any] = ...):
        """
        Parameters
        ----------
        freq : frequency
        """
        ...
    
    @classmethod
    def _parse_dtype_strict(cls, freq):
        ...
    
    @classmethod
    def construct_from_string(cls, string):
        """
        attempt to construct this type from a string, raise a TypeError
        if its not possible
        """
        ...
    
    def __unicode__(self):
        ...
    
    @property
    def name(self):
        ...
    
    def __hash__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    @classmethod
    def is_dtype(cls, dtype):
        """
        Return a boolean if we if the passed type is an actual dtype that we
        can match (via string or type)
        """
        ...
    


class IntervalDtypeType(type):
    """
    the type of IntervalDtype, this metaclass determines subclass ability
    """
    ...


class IntervalDtype(ExtensionDtype):
    __metaclass__ = ...
    type = ...
    kind = ...
    str = ...
    base = ...
    num = ...
    _metadata = ...
    _match = ...
    _cache = ...
    def __new__(cls, subtype: Optional[Any] = ...):
        """
        Parameters
        ----------
        subtype : the dtype of the Interval
        """
        ...
    
    @classmethod
    def construct_from_string(cls, string):
        """
        attempt to construct this type from a string, raise a TypeError
        if its not possible
        """
        ...
    
    def __unicode__(self):
        ...
    
    @property
    def name(self):
        ...
    
    def __hash__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    @classmethod
    def is_dtype(cls, dtype):
        """
        Return a boolean if we if the passed type is an actual dtype that we
        can match (via string or type)
        """
        ...
    


