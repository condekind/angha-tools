"""
This type stub file was generated by pyright.
"""

import numpy as np
from pandas._libs import algos
from typing import Any, Optional

"""
Routines for filling missing data
"""
def mask_missing(arr, values_to_mask):
    """
    Return a masking array of same size/shape as arr
    with entries equaling any member of values_to_mask set to True
    """
    ...

def clean_fill_method(method, allow_nearest: bool = ...):
    ...

def clean_interp_method(method, **kwargs):
    ...

def interpolate_1d(xvalues, yvalues, method=..., limit: Optional[Any] = ..., limit_direction=..., fill_value: Optional[Any] = ..., bounds_error: bool = ..., order: Optional[Any] = ..., **kwargs):
    """
    Logic for the 1-d interpolation.  The result should be 1-d, inputs
    xvalues and yvalues will each be 1-d arrays of the same length.

    Bounds_error is currently hardcoded to False since non-scipy ones don't
    take it as an argumnet.
    """
    ...

def _interpolate_scipy_wrapper(x, y, new_x, method, fill_value: Optional[Any] = ..., bounds_error: bool = ..., order: Optional[Any] = ..., **kwargs):
    """
    passed off to scipy.interpolate.interp1d. method is scipy's kind.
    Returns an array interpolated at new_x.  Add any new methods to
    the list in _clean_interp_method
    """
    ...

def _from_derivatives(xi, yi, x, order: Optional[Any] = ..., der=..., extrapolate: bool = ...):
    """
    Convenience function for interpolate.BPoly.from_derivatives

    Construct a piecewise polynomial in the Bernstein basis, compatible
    with the specified values and derivatives at breakpoints.

    Parameters
    ----------
    xi : array_like
        sorted 1D array of x-coordinates
    yi : array_like or list of array-likes
        yi[i][j] is the j-th derivative known at xi[i]
    orders : None or int or array_like of ints. Default: None.
        Specifies the degree of local polynomials. If not None, some
        derivatives are ignored.
    der : int or list
        How many derivatives to extract; None for all potentially nonzero
        derivatives (that is a number equal to the number of points), or a
        list of derivatives to extract. This numberincludes the function
        value as 0th derivative.
     extrapolate : bool, optional
        Whether to extrapolate to ouf-of-bounds points based on first and last
        intervals, or to return NaNs. Default: True.

    See Also
    --------
    scipy.interpolate.BPoly.from_derivatives

    Returns
    -------
    y : scalar or array_like
        The result, of length R or length M or M by R,

    """
    ...

def _akima_interpolate(xi, yi, x, der=..., axis=...):
    """
    Convenience function for akima interpolation.
    xi and yi are arrays of values used to approximate some function f,
    with ``yi = f(xi)``.

    See `Akima1DInterpolator` for details.

    Parameters
    ----------
    xi : array_like
        A sorted list of x-coordinates, of length N.
    yi :  array_like
        A 1-D array of real values.  `yi`'s length along the interpolation
        axis must be equal to the length of `xi`. If N-D array, use axis
        parameter to select correct axis.
    x : scalar or array_like
        Of length M.
    der : int or list, optional
        How many derivatives to extract; None for all potentially
        nonzero derivatives (that is a number equal to the number
        of points), or a list of derivatives to extract. This number
        includes the function value as 0th derivative.
    axis : int, optional
        Axis in the yi array corresponding to the x-coordinate values.

    See Also
    --------
    scipy.interpolate.Akima1DInterpolator

    Returns
    -------
    y : scalar or array_like
        The result, of length R or length M or M by R,

    """
    ...

def interpolate_2d(values, method=..., axis=..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ..., dtype: Optional[Any] = ...):
    """ perform an actual interpolation of values, values will be make 2-d if
    needed fills inplace, returns the result
    """
    ...

def _interp_wrapper(f, wrap_dtype, na_override: Optional[Any] = ...):
    ...

_pad_1d_datetime = _interp_wrapper(algos.pad_inplace_int64, np.int64)
_pad_2d_datetime = _interp_wrapper(algos.pad_2d_inplace_int64, np.int64)
_backfill_1d_datetime = _interp_wrapper(algos.backfill_inplace_int64, np.int64)
_backfill_2d_datetime = _interp_wrapper(algos.backfill_2d_inplace_int64, np.int64)
def pad_1d(values, limit: Optional[Any] = ..., mask: Optional[Any] = ..., dtype: Optional[Any] = ...):
    ...

def backfill_1d(values, limit: Optional[Any] = ..., mask: Optional[Any] = ..., dtype: Optional[Any] = ...):
    ...

def pad_2d(values, limit: Optional[Any] = ..., mask: Optional[Any] = ..., dtype: Optional[Any] = ...):
    ...

def backfill_2d(values, limit: Optional[Any] = ..., mask: Optional[Any] = ..., dtype: Optional[Any] = ...):
    ...

_fill_methods = { 'pad': pad_1d,'backfill': backfill_1d }
def get_fill_func(method):
    ...

def clean_reindex_fill_method(method):
    ...

def fill_zeros(result, x, y, name, fill):
    """
    if this is a reversed op, then flip x,y

    if we have an integer value (or array in y)
    and we have 0's, fill them with the fill,
    return the result

    mask the nan's from x
    """
    ...

def _interp_limit(invalid, fw_limit, bw_limit):
    """Get idx of values that won't be filled b/c they exceed the limits.

    This is equivalent to the more readable, but slower

    .. code-block:: python

       for x in np.where(invalid)[0]:
           if invalid[max(0, x - fw_limit):x + bw_limit + 1].all():
               yield x
    """
    ...

def _rolling_window(a, window):
    """
    [True, True, False, True, False], 2 ->

    [
        [True,  True],
        [True, False],
        [False, True],
        [True, False],
    ]
    """
    ...

