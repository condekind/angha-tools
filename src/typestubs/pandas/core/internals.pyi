"""
This type stub file was generated by pyright.
"""

from pandas.core.base import PandasObject
from pandas.core.dtypes.common import is_categorical, is_datetimetz, is_integer, is_sparse
from pandas.util._decorators import cache_readonly
from typing import Any, Optional

class Block(PandasObject):
    """
    Canonical n-dimensional unit of homogeneous dtype contained in a pandas
    data structure

    Index-ignorant; let the container take care of that
    """
    __slots__ = ...
    is_numeric = ...
    is_float = ...
    is_integer = ...
    is_complex = ...
    is_datetime = ...
    is_datetimetz = ...
    is_timedelta = ...
    is_bool = ...
    is_object = ...
    is_categorical = ...
    is_sparse = ...
    _box_to_block_values = ...
    _can_hold_na = ...
    _downcast_dtype = ...
    _can_consolidate = ...
    _verify_integrity = ...
    _validate_ndim = ...
    _ftype = ...
    _holder = ...
    _concatenator = ...
    def __init__(self, values, placement, ndim: Optional[Any] = ..., fastpath: bool = ...):
        self.ndim = ...
        self.mgr_locs = ...
        self.values = ...
    
    @property
    def _consolidate_key(self):
        ...
    
    @property
    def _is_single_block(self):
        ...
    
    @property
    def is_view(self):
        """ return a boolean if I am possibly a view """
        ...
    
    @property
    def is_datelike(self):
        """ return True if I am a non-datelike """
        ...
    
    def is_categorical_astype(self, dtype):
        """
        validate that we have a astypeable to categorical,
        returns a boolean if we are a categorical
        """
        ...
    
    def external_values(self, dtype: Optional[Any] = ...):
        """ return an outside world format, currently just the ndarray """
        ...
    
    def internal_values(self, dtype: Optional[Any] = ...):
        """ return an internal format, currently just the ndarray
        this should be the pure internal API format
        """
        ...
    
    def formatting_values(self):
        """Return the internal values used by the DataFrame/SeriesFormatter"""
        ...
    
    def get_values(self, dtype: Optional[Any] = ...):
        """
        return an internal format, currently just the ndarray
        this is often overriden to handle to_dense like operations
        """
        ...
    
    def to_dense(self):
        ...
    
    @property
    def _na_value(self):
        ...
    
    @property
    def fill_value(self):
        ...
    
    @property
    def mgr_locs(self):
        ...
    
    @property
    def array_dtype(self):
        """ the dtype to return if I want to construct this block as an
        array
        """
        ...
    
    def make_block(self, values, placement: Optional[Any] = ..., ndim: Optional[Any] = ..., **kwargs):
        """
        Create a new block, with type inference propagate any values that are
        not specified
        """
        ...
    
    def make_block_scalar(self, values, **kwargs):
        """
        Create a ScalarBlock
        """
        ...
    
    def make_block_same_class(self, values, placement: Optional[Any] = ..., fastpath: bool = ..., **kwargs):
        """ Wrap given values in a block of same type as self. """
        ...
    
    @mgr_locs.setter
    def mgr_locs(self, new_mgr_locs):
        ...
    
    def __unicode__(self):
        ...
    
    def __len__(self):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        self.mgr_locs = ...
        self.values = ...
        self.ndim = ...
    
    def _slice(self, slicer):
        """ return a slice of my values """
        ...
    
    def reshape_nd(self, labels, shape, ref_items, mgr: Optional[Any] = ...):
        """
        Parameters
        ----------
        labels : list of new axis labels
        shape : new shape
        ref_items : new ref_items

        return a new block that is transformed to a nd block
        """
        ...
    
    def getitem_block(self, slicer, new_mgr_locs: Optional[Any] = ...):
        """
        Perform __getitem__-like, return result as block.

        As of now, only supports slices that preserve dimensionality.
        """
        ...
    
    @property
    def shape(self):
        ...
    
    @property
    def itemsize(self):
        ...
    
    @property
    def dtype(self):
        ...
    
    @property
    def ftype(self):
        ...
    
    def merge(self, other):
        ...
    
    def concat_same_type(self, to_concat, placement: Optional[Any] = ...):
        """
        Concatenate list of single blocks of the same type.
        """
        ...
    
    def reindex_axis(self, indexer, method: Optional[Any] = ..., axis=..., fill_value: Optional[Any] = ..., limit: Optional[Any] = ..., mask_info: Optional[Any] = ...):
        """
        Reindex using pre-computed indexer information
        """
        ...
    
    def iget(self, i):
        ...
    
    def set(self, locs, values, check: bool = ...):
        """
        Modify Block in-place with new item value

        Returns
        -------
        None
        """
        ...
    
    def delete(self, loc):
        """
        Delete given loc(-s) from block in-place.
        """
        self.values = ...
        self.mgr_locs = ...
    
    def apply(self, func, mgr: Optional[Any] = ..., **kwargs):
        """ apply the function to my values; return a block if we are not
        one
        """
        ...
    
    def fillna(self, value, limit: Optional[Any] = ..., inplace: bool = ..., downcast: Optional[Any] = ..., mgr: Optional[Any] = ...):
        """ fillna on the block with the value. If we fail, then convert to
        ObjectBlock and try again
        """
        ...
    
    def split_and_operate(self, mask, f, inplace):
        """
        split the block per-column, and apply the callable f
        per-column, return a new block for each. Handle
        masking which will not change a block unless needed.

        Parameters
        ----------
        mask : 2-d boolean mask
        f : callable accepting (1d-mask, 1d values, indexer)
        inplace : boolean

        Returns
        -------
        list of blocks
        """
        ...
    
    def _maybe_downcast(self, blocks, downcast: Optional[Any] = ...):
        ...
    
    def downcast(self, dtypes: Optional[Any] = ..., mgr: Optional[Any] = ...):
        """ try to downcast each item to the dict of dtypes if present """
        ...
    
    def astype(self, dtype, copy: bool = ..., errors=..., values: Optional[Any] = ..., **kwargs):
        ...
    
    def _astype(self, dtype, copy: bool = ..., errors=..., values: Optional[Any] = ..., klass: Optional[Any] = ..., mgr: Optional[Any] = ..., **kwargs):
        """
        Coerce to the new type

        dtype : str, dtype convertible
        copy : boolean, default False
            copy if indicated
        errors : str, {'raise', 'ignore'}, default 'ignore'
            - ``raise`` : allow exceptions to be raised
            - ``ignore`` : suppress exceptions. On error return original object
        """
        ...
    
    def convert(self, copy: bool = ..., **kwargs):
        """ attempt to coerce any object types to better types return a copy
        of the block (if copy = True) by definition we are not an ObjectBlock
        here!
        """
        ...
    
    def _can_hold_element(self, element):
        """ require the same dtype as ourselves """
        ...
    
    def _try_cast_result(self, result, dtype: Optional[Any] = ...):
        """ try to cast the result to our original type, we may have
        roundtripped thru object in the mean-time
        """
        ...
    
    def _try_coerce_args(self, values, other):
        """ provide coercion to our input arguments """
        ...
    
    def _try_coerce_result(self, result):
        """ reverse of try_coerce_args """
        ...
    
    def _try_coerce_and_cast_result(self, result, dtype: Optional[Any] = ...):
        ...
    
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep=..., quoting: Optional[Any] = ..., **kwargs):
        """ convert to our native types format, slicing if desired """
        ...
    
    def copy(self, deep: bool = ..., mgr: Optional[Any] = ...):
        """ copy constructor """
        ...
    
    def replace(self, to_replace, value, inplace: bool = ..., filter: Optional[Any] = ..., regex: bool = ..., convert: bool = ..., mgr: Optional[Any] = ...):
        """ replace the to_replace value with value, possible to create new
        blocks here this is just a call to putmask. regex is not used here.
        It is used in ObjectBlocks.  It is here for API
        compatibility.
        """
        ...
    
    def _replace_single(self, *args, **kwargs):
        """ no-op on a non-ObjectBlock """
        ...
    
    def setitem(self, indexer, value, mgr: Optional[Any] = ...):
        """ set the value inplace; return a new block (of a possibly different
        dtype)

        indexer is a direct slice/positional indexer; value must be a
        compatible shape
        """
        ...
    
    def putmask(self, mask, new, align: bool = ..., inplace: bool = ..., axis=..., transpose: bool = ..., mgr: Optional[Any] = ...):
        """ putmask the data to the block; it is possible that we may create a
        new dtype of block

        return the resulting block(s)

        Parameters
        ----------
        mask  : the condition to respect
        new : a ndarray/object
        align : boolean, perform alignment on other/cond, default is True
        inplace : perform inplace modification, default is False
        axis : int
        transpose : boolean
            Set to True if self is stored with axes reversed

        Returns
        -------
        a list of new blocks, the result of the putmask
        """
        ...
    
    def coerce_to_target_dtype(self, other):
        """
        coerce the current block to a dtype compat for other
        we will return a block, possibly object, and not raise

        we can also safely try to coerce to the same dtype
        and will receive the same block
        """
        ...
    
    def interpolate(self, method=..., axis=..., index: Optional[Any] = ..., values: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., limit_direction=..., fill_value: Optional[Any] = ..., coerce: bool = ..., downcast: Optional[Any] = ..., mgr: Optional[Any] = ..., **kwargs):
        ...
    
    def _interpolate_with_fill(self, method=..., axis=..., inplace: bool = ..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ..., coerce: bool = ..., downcast: Optional[Any] = ..., mgr: Optional[Any] = ...):
        """ fillna but using the interpolate machinery """
        ...
    
    def _interpolate(self, method: Optional[Any] = ..., index: Optional[Any] = ..., values: Optional[Any] = ..., fill_value: Optional[Any] = ..., axis=..., limit: Optional[Any] = ..., limit_direction=..., inplace: bool = ..., downcast: Optional[Any] = ..., mgr: Optional[Any] = ..., **kwargs):
        """ interpolate using scipy wrappers """
        ...
    
    def take_nd(self, indexer, axis, new_mgr_locs: Optional[Any] = ..., fill_tuple: Optional[Any] = ...):
        """
        Take values according to indexer and return them as a block.bb

        """
        ...
    
    def diff(self, n, axis=..., mgr: Optional[Any] = ...):
        """ return block for the diff of the values """
        ...
    
    def shift(self, periods, axis=..., mgr: Optional[Any] = ...):
        """ shift the block by periods, possibly upcast """
        ...
    
    def eval(self, func, other, errors=..., try_cast: bool = ..., mgr: Optional[Any] = ...):
        """
        evaluate the block; return result block from the result

        Parameters
        ----------
        func  : how to combine self, other
        other : a ndarray/object
        errors : str, {'raise', 'ignore'}, default 'raise'
            - ``raise`` : allow exceptions to be raised
            - ``ignore`` : suppress exceptions. On error return original object

        try_cast : try casting the results to the input type

        Returns
        -------
        a new block, the result of the func
        """
        ...
    
    def where(self, other, cond, align: bool = ..., errors=..., try_cast: bool = ..., axis=..., transpose: bool = ..., mgr: Optional[Any] = ...):
        """
        evaluate the block; return result block(s) from the result

        Parameters
        ----------
        other : a ndarray/object
        cond  : the condition to respect
        align : boolean, perform alignment on other/cond
        errors : str, {'raise', 'ignore'}, default 'raise'
            - ``raise`` : allow exceptions to be raised
            - ``ignore`` : suppress exceptions. On error return original object

        axis : int
        transpose : boolean
            Set to True if self is stored with axes reversed

        Returns
        -------
        a new block(s), the result of the func
        """
        ...
    
    def equals(self, other):
        ...
    
    def _unstack(self, unstacker_func, new_columns):
        """Return a list of unstacked blocks of self

        Parameters
        ----------
        unstacker_func : callable
            Partially applied unstacker.
        new_columns : Index
            All columns of the unstacked BlockManager.

        Returns
        -------
        blocks : list of Block
            New blocks of unstacked values.
        mask : array_like of bool
            The mask of columns of `blocks` we should keep.
        """
        ...
    
    def quantile(self, qs, interpolation=..., axis=..., mgr: Optional[Any] = ...):
        """
        compute the quantiles of the

        Parameters
        ----------
        qs: a scalar or list of the quantiles to be computed
        interpolation: type of interpolation, default 'linear'
        axis: axis to compute, default 0

        Returns
        -------
        tuple of (axis, block)

        """
        ...
    


class ScalarBlock(Block):
    """
    a scalar compat Block
    """
    __slots__ = ...
    def __init__(self, values):
        self.ndim = ...
        self.mgr_locs = ...
        self.values = ...
    
    @property
    def dtype(self):
        ...
    
    @property
    def shape(self):
        ...
    
    def __len__(self):
        ...
    


class NonConsolidatableMixIn(object):
    """ hold methods for the nonconsolidatable blocks """
    _can_consolidate = ...
    _verify_integrity = ...
    _validate_ndim = ...
    _holder = ...
    def __init__(self, values, placement, ndim: Optional[Any] = ..., fastpath: bool = ..., **kwargs):
        self.mgr_locs = ...
        self.ndim = ...
        self.values = ...
    
    @property
    def shape(self):
        ...
    
    def get_values(self, dtype: Optional[Any] = ...):
        """ need to to_dense myself (and always return a ndim sized object) """
        ...
    
    def iget(self, col):
        ...
    
    def should_store(self, value):
        ...
    
    def set(self, locs, values, check: bool = ...):
        self.values = ...
    
    def putmask(self, mask, new, align: bool = ..., inplace: bool = ..., axis=..., transpose: bool = ..., mgr: Optional[Any] = ...):
        """
        putmask the data to the block; we must be a single block and not
        generate other blocks

        return the resulting block

        Parameters
        ----------
        mask  : the condition to respect
        new : a ndarray/object
        align : boolean, perform alignment on other/cond, default is True
        inplace : perform inplace modification, default is False

        Returns
        -------
        a new block(s), the result of the putmask
        """
        ...
    
    def _slice(self, slicer):
        """ return a slice of my values (but densify first) """
        ...
    
    def _try_cast_result(self, result, dtype: Optional[Any] = ...):
        ...
    
    def _unstack(self, unstacker_func, new_columns):
        """Return a list of unstacked blocks of self

        Parameters
        ----------
        unstacker_func : callable
            Partially applied unstacker.
        new_columns : Index
            All columns of the unstacked BlockManager.

        Returns
        -------
        blocks : list of Block
            New blocks of unstacked values.
        mask : array_like of bool
            The mask of columns of `blocks` we should keep.
        """
        ...
    


class NumericBlock(Block):
    __slots__ = ...
    is_numeric = ...
    _can_hold_na = ...


class FloatOrComplexBlock(NumericBlock):
    __slots__ = ...
    def equals(self, other):
        ...
    


class FloatBlock(FloatOrComplexBlock):
    __slots__ = ...
    is_float = ...
    _downcast_dtype = ...
    def _can_hold_element(self, element):
        ...
    
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep=..., float_format: Optional[Any] = ..., decimal=..., quoting: Optional[Any] = ..., **kwargs):
        """ convert to our native types format, slicing if desired """
        ...
    
    def should_store(self, value):
        ...
    


class ComplexBlock(FloatOrComplexBlock):
    __slots__ = ...
    is_complex = ...
    def _can_hold_element(self, element):
        ...
    
    def should_store(self, value):
        ...
    


class IntBlock(NumericBlock):
    __slots__ = ...
    is_integer = ...
    _can_hold_na = ...
    def _can_hold_element(self, element):
        ...
    
    def should_store(self, value):
        ...
    


class DatetimeLikeBlockMixin(object):
    @property
    def _na_value(self):
        ...
    
    @property
    def fill_value(self):
        ...
    
    def get_values(self, dtype: Optional[Any] = ...):
        """
        return object dtype as boxed values, such as Timestamps/Timedelta
        """
        ...
    


class TimeDeltaBlock(DatetimeLikeBlockMixin, IntBlock):
    __slots__ = ...
    is_timedelta = ...
    _can_hold_na = ...
    is_numeric = ...
    @property
    def _box_func(self):
        ...
    
    def _can_hold_element(self, element):
        ...
    
    def fillna(self, value, **kwargs):
        ...
    
    def _try_coerce_args(self, values, other):
        """
        Coerce values and other to int64, with null values converted to
        iNaT. values is always ndarray-like, other may not be

        Parameters
        ----------
        values : ndarray-like
        other : ndarray-like or scalar

        Returns
        -------
        base-type values, values mask, base-type other, other mask
        """
        ...
    
    def _try_coerce_result(self, result):
        """ reverse of try_coerce_args / try_operate """
        ...
    
    def should_store(self, value):
        ...
    
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep: Optional[Any] = ..., quoting: Optional[Any] = ..., **kwargs):
        """ convert to our native types format, slicing if desired """
        ...
    


class BoolBlock(NumericBlock):
    __slots__ = ...
    is_bool = ...
    _can_hold_na = ...
    def _can_hold_element(self, element):
        ...
    
    def should_store(self, value):
        ...
    
    def replace(self, to_replace, value, inplace: bool = ..., filter: Optional[Any] = ..., regex: bool = ..., convert: bool = ..., mgr: Optional[Any] = ...):
        ...
    


class ObjectBlock(Block):
    __slots__ = ...
    is_object = ...
    _can_hold_na = ...
    def __init__(self, values, ndim=..., fastpath: bool = ..., placement: Optional[Any] = ..., **kwargs):
        ...
    
    @property
    def is_bool(self):
        """ we can be a bool if we have only bool values but are of type
        object
        """
        ...
    
    def convert(self, *args, **kwargs):
        """ attempt to coerce any object types to better types return a copy of
        the block (if copy = True) by definition we ARE an ObjectBlock!!!!!

        can return multiple blocks!
        """
        ...
    
    def set(self, locs, values, check: bool = ...):
        """
        Modify Block in-place with new item value

        Returns
        -------
        None
        """
        ...
    
    def _maybe_downcast(self, blocks, downcast: Optional[Any] = ...):
        ...
    
    def _can_hold_element(self, element):
        ...
    
    def _try_coerce_args(self, values, other):
        """ provide coercion to our input arguments """
        ...
    
    def should_store(self, value):
        ...
    
    def replace(self, to_replace, value, inplace: bool = ..., filter: Optional[Any] = ..., regex: bool = ..., convert: bool = ..., mgr: Optional[Any] = ...):
        ...
    
    def _replace_single(self, to_replace, value, inplace: bool = ..., filter: Optional[Any] = ..., regex: bool = ..., convert: bool = ..., mgr: Optional[Any] = ...):
        ...
    


class CategoricalBlock(NonConsolidatableMixIn, ObjectBlock):
    __slots__ = ...
    is_categorical = ...
    _verify_integrity = ...
    _can_hold_na = ...
    _holder = ...
    _concatenator = ...
    def __init__(self, values, placement, fastpath: bool = ..., **kwargs):
        ...
    
    @property
    def is_view(self):
        """ I am never a view """
        ...
    
    def to_dense(self):
        ...
    
    def convert(self, copy: bool = ..., **kwargs):
        ...
    
    @property
    def array_dtype(self):
        """ the dtype to return if I want to construct this block as an
        array
        """
        ...
    
    def _slice(self, slicer):
        """ return a slice of my values """
        ...
    
    def _try_coerce_result(self, result):
        """ reverse of try_coerce_args """
        ...
    
    def fillna(self, value, limit: Optional[Any] = ..., inplace: bool = ..., downcast: Optional[Any] = ..., mgr: Optional[Any] = ...):
        ...
    
    def interpolate(self, method=..., axis=..., inplace: bool = ..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ..., **kwargs):
        ...
    
    def shift(self, periods, axis=..., mgr: Optional[Any] = ...):
        ...
    
    def take_nd(self, indexer, axis=..., new_mgr_locs: Optional[Any] = ..., fill_tuple: Optional[Any] = ...):
        """
        Take values according to indexer and return them as a block.bb
        """
        ...
    
    def _astype(self, dtype, copy: bool = ..., errors=..., values: Optional[Any] = ..., klass: Optional[Any] = ..., mgr: Optional[Any] = ...):
        """
        Coerce to the new type (if copy=True, return a new copy)
        raise on an except if raise == True
        """
        ...
    
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep=..., quoting: Optional[Any] = ..., **kwargs):
        """ convert to our native types format, slicing if desired """
        ...
    
    def concat_same_type(self, to_concat, placement: Optional[Any] = ...):
        """
        Concatenate list of single blocks of the same type.
        """
        ...
    


class DatetimeBlock(DatetimeLikeBlockMixin, Block):
    __slots__ = ...
    is_datetime = ...
    _can_hold_na = ...
    def __init__(self, values, placement, fastpath: bool = ..., **kwargs):
        ...
    
    def _astype(self, dtype, mgr: Optional[Any] = ..., **kwargs):
        """
        these automatically copy, so copy=True has no effect
        raise on an except if raise == True
        """
        ...
    
    def _can_hold_element(self, element):
        ...
    
    def _try_coerce_args(self, values, other):
        """
        Coerce values and other to dtype 'i8'. NaN and NaT convert to
        the smallest i8, and will correctly round-trip to NaT if converted
        back in _try_coerce_result. values is always ndarray-like, other
        may not be

        Parameters
        ----------
        values : ndarray-like
        other : ndarray-like or scalar

        Returns
        -------
        base-type values, values mask, base-type other, other mask
        """
        ...
    
    def _try_coerce_result(self, result):
        """ reverse of try_coerce_args """
        ...
    
    @property
    def _box_func(self):
        ...
    
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep: Optional[Any] = ..., date_format: Optional[Any] = ..., quoting: Optional[Any] = ..., **kwargs):
        """ convert to our native types format, slicing if desired """
        ...
    
    def should_store(self, value):
        ...
    
    def set(self, locs, values, check: bool = ...):
        """
        Modify Block in-place with new item value

        Returns
        -------
        None
        """
        ...
    


class DatetimeTZBlock(NonConsolidatableMixIn, DatetimeBlock):
    """ implement a datetime64 block with a tz attribute """
    __slots__ = ...
    _holder = ...
    _concatenator = ...
    is_datetimetz = ...
    def __init__(self, values, placement, ndim=..., **kwargs):
        ...
    
    def copy(self, deep: bool = ..., mgr: Optional[Any] = ...):
        """ copy constructor """
        ...
    
    def external_values(self):
        """ we internally represent the data as a DatetimeIndex, but for
        external compat with ndarray, export as a ndarray of Timestamps
        """
        ...
    
    def get_values(self, dtype: Optional[Any] = ...):
        ...
    
    def _slice(self, slicer):
        """ return a slice of my values """
        ...
    
    def _try_coerce_args(self, values, other):
        """
        localize and return i8 for the values

        Parameters
        ----------
        values : ndarray-like
        other : ndarray-like or scalar

        Returns
        -------
        base-type values, values mask, base-type other, other mask
        """
        ...
    
    def _try_coerce_result(self, result):
        """ reverse of try_coerce_args """
        ...
    
    @property
    def _box_func(self):
        ...
    
    def shift(self, periods, axis=..., mgr: Optional[Any] = ...):
        """ shift the block by periods """
        ...
    
    def concat_same_type(self, to_concat, placement: Optional[Any] = ...):
        """
        Concatenate list of single blocks of the same type.
        """
        ...
    


class SparseBlock(NonConsolidatableMixIn, Block):
    """ implement as a list of sparse arrays of the same dtype """
    __slots__ = ...
    is_sparse = ...
    is_numeric = ...
    _box_to_block_values = ...
    _can_hold_na = ...
    _ftype = ...
    _holder = ...
    _concatenator = ...
    @property
    def shape(self):
        ...
    
    @property
    def itemsize(self):
        ...
    
    @property
    def fill_value(self):
        ...
    
    @fill_value.setter
    def fill_value(self, v):
        ...
    
    def to_dense(self):
        ...
    
    @property
    def sp_values(self):
        ...
    
    @sp_values.setter
    def sp_values(self, v):
        self.values = ...
    
    @property
    def sp_index(self):
        ...
    
    @property
    def kind(self):
        ...
    
    def _astype(self, dtype, copy: bool = ..., errors=..., values: Optional[Any] = ..., klass: Optional[Any] = ..., mgr: Optional[Any] = ..., **kwargs):
        ...
    
    def __len__(self):
        ...
    
    def copy(self, deep: bool = ..., mgr: Optional[Any] = ...):
        ...
    
    def make_block_same_class(self, values, placement, sparse_index: Optional[Any] = ..., kind: Optional[Any] = ..., dtype: Optional[Any] = ..., fill_value: Optional[Any] = ..., copy: bool = ..., fastpath: bool = ..., **kwargs):
        """ return a new block """
        ...
    
    def interpolate(self, method=..., axis=..., inplace: bool = ..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ..., **kwargs):
        ...
    
    def fillna(self, value, limit: Optional[Any] = ..., inplace: bool = ..., downcast: Optional[Any] = ..., mgr: Optional[Any] = ...):
        ...
    
    def shift(self, periods, axis=..., mgr: Optional[Any] = ...):
        """ shift the block by periods """
        ...
    
    def reindex_axis(self, indexer, method: Optional[Any] = ..., axis=..., fill_value: Optional[Any] = ..., limit: Optional[Any] = ..., mask_info: Optional[Any] = ...):
        """
        Reindex using pre-computed indexer information
        """
        ...
    
    def sparse_reindex(self, new_index):
        """ sparse reindex and return a new block
            current reindex only works for float64 dtype! """
        ...
    


def make_block(values, placement, klass: Optional[Any] = ..., ndim: Optional[Any] = ..., dtype: Optional[Any] = ..., fastpath: bool = ...):
    ...

class BlockManager(PandasObject):
    """
    Core internal data structure to implement DataFrame, Series, Panel, etc.

    Manage a bunch of labeled 2D mixed-type ndarrays. Essentially it's a
    lightweight blocked set of labeled data to be manipulated by the DataFrame
    public API class

    Attributes
    ----------
    shape
    ndim
    axes
    values
    items

    Methods
    -------
    set_axis(axis, new_labels)
    copy(deep=True)

    get_dtype_counts
    get_ftype_counts
    get_dtypes
    get_ftypes

    apply(func, axes, block_filter_fn)

    get_bool_data
    get_numeric_data

    get_slice(slice_like, axis)
    get(label)
    iget(loc)
    get_scalar(label_tup)

    take(indexer, axis)
    reindex_axis(new_labels, axis)
    reindex_indexer(new_labels, indexer, axis)

    delete(label)
    insert(loc, label, value)
    set(label, value)

    Parameters
    ----------


    Notes
    -----
    This is *not* a public API class
    """
    __slots__ = ...
    def __init__(self, blocks, axes, do_integrity_check: bool = ..., fastpath: bool = ...):
        self.axes = ...
        self.blocks = ...
    
    def make_empty(self, axes: Optional[Any] = ...):
        """ return an empty BlockManager with the items axis of len 0 """
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    @property
    def shape(self):
        ...
    
    @property
    def ndim(self):
        ...
    
    def set_axis(self, axis, new_labels):
        ...
    
    def rename_axis(self, mapper, axis, copy: bool = ..., level: Optional[Any] = ...):
        """
        Rename one of axes.

        Parameters
        ----------
        mapper : unary callable
        axis : int
        copy : boolean, default True
        level : int, default None

        """
        ...
    
    def add_prefix(self, prefix):
        ...
    
    def add_suffix(self, suffix):
        ...
    
    @property
    def _is_single_block(self):
        ...
    
    def _rebuild_blknos_and_blklocs(self):
        """
        Update mgr._blknos / mgr._blklocs.
        """
        ...
    
    def _get_items(self):
        ...
    
    items = ...
    def _get_counts(self, f):
        """ return a dict of the counts of the function in BlockManager """
        ...
    
    def get_dtype_counts(self):
        ...
    
    def get_ftype_counts(self):
        ...
    
    def get_dtypes(self):
        ...
    
    def get_ftypes(self):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        ...
    
    def _post_setstate(self):
        ...
    
    def __len__(self):
        ...
    
    def __unicode__(self):
        ...
    
    def _verify_integrity(self):
        ...
    
    def apply(self, f, axes: Optional[Any] = ..., filter: Optional[Any] = ..., do_integrity_check: bool = ..., consolidate: bool = ..., **kwargs):
        """
        iterate over the blocks, collect and create a new block manager

        Parameters
        ----------
        f : the callable or function name to operate on at the block level
        axes : optional (if not supplied, use self.axes)
        filter : list, if supplied, only call the block if the filter is in
                 the block
        do_integrity_check : boolean, default False. Do the block manager
            integrity check
        consolidate: boolean, default True. Join together blocks having same
            dtype

        Returns
        -------
        Block Manager (new object)

        """
        ...
    
    def reduction(self, f, axis=..., consolidate: bool = ..., transposed: bool = ..., **kwargs):
        """
        iterate over the blocks, collect and create a new block manager.
        This routine is intended for reduction type operations and
        will do inference on the generated blocks.

        Parameters
        ----------
        f: the callable or function name to operate on at the block level
        axis: reduction axis, default 0
        consolidate: boolean, default True. Join together blocks having same
            dtype
        transposed: boolean, default False
            we are holding transposed data

        Returns
        -------
        Block Manager (new object)

        """
        ...
    
    def isna(self, **kwargs):
        ...
    
    def where(self, **kwargs):
        ...
    
    def eval(self, **kwargs):
        ...
    
    def quantile(self, **kwargs):
        ...
    
    def setitem(self, **kwargs):
        ...
    
    def putmask(self, **kwargs):
        ...
    
    def diff(self, **kwargs):
        ...
    
    def interpolate(self, **kwargs):
        ...
    
    def shift(self, **kwargs):
        ...
    
    def fillna(self, **kwargs):
        ...
    
    def downcast(self, **kwargs):
        ...
    
    def astype(self, dtype, **kwargs):
        ...
    
    def convert(self, **kwargs):
        ...
    
    def replace(self, **kwargs):
        ...
    
    def replace_list(self, src_list, dest_list, inplace: bool = ..., regex: bool = ..., mgr: Optional[Any] = ...):
        """ do a list replace """
        ...
    
    def reshape_nd(self, axes, **kwargs):
        """ a 2d-nd reshape operation on a BlockManager """
        ...
    
    def is_consolidated(self):
        """
        Return True if more than one block with the same dtype
        """
        ...
    
    def _consolidate_check(self):
        ...
    
    @property
    def is_mixed_type(self):
        ...
    
    @property
    def is_numeric_mixed_type(self):
        ...
    
    @property
    def is_datelike_mixed_type(self):
        ...
    
    @property
    def is_view(self):
        """ return a boolean if we are a single block and are a view """
        ...
    
    def get_bool_data(self, copy: bool = ...):
        """
        Parameters
        ----------
        copy : boolean, default False
            Whether to copy the blocks
        """
        ...
    
    def get_numeric_data(self, copy: bool = ...):
        """
        Parameters
        ----------
        copy : boolean, default False
            Whether to copy the blocks
        """
        ...
    
    def combine(self, blocks, copy: bool = ...):
        """ return a new manager with the blocks """
        ...
    
    def get_slice(self, slobj, axis=...):
        ...
    
    def __contains__(self, item):
        ...
    
    @property
    def nblocks(self):
        ...
    
    def copy(self, deep: bool = ..., mgr: Optional[Any] = ...):
        """
        Make deep or shallow copy of BlockManager

        Parameters
        ----------
        deep : boolean o rstring, default True
            If False, return shallow copy (do not copy data)
            If 'all', copy data and a deep copy of the index

        Returns
        -------
        copy : BlockManager
        """
        ...
    
    def as_matrix(self, items: Optional[Any] = ...):
        ...
    
    def _interleave(self):
        """
        Return ndarray from blocks with specified item order
        Items must be contained in the blocks
        """
        ...
    
    def to_dict(self, copy: bool = ...):
        """
        Return a dict of str(dtype) -> BlockManager

        Parameters
        ----------
        copy : boolean, default True

        Returns
        -------
        values : a dict of dtype -> BlockManager

        Notes
        -----
        This consolidates based on str(dtype)
        """
        ...
    
    def xs(self, key, axis=..., copy: bool = ..., takeable: bool = ...):
        ...
    
    def fast_xs(self, loc):
        """
        get a cross sectional for a given location in the
        items ; handle dups

        return the result, is *could* be a view in the case of a
        single block
        """
        ...
    
    def consolidate(self):
        """
        Join together blocks having same dtype

        Returns
        -------
        y : BlockManager
        """
        ...
    
    def _consolidate_inplace(self):
        ...
    
    def get(self, item, fastpath: bool = ...):
        """
        Return values for selected item (ndarray or BlockManager).
        """
        ...
    
    def iget(self, i, fastpath: bool = ...):
        """
        Return the data as a SingleBlockManager if fastpath=True and possible

        Otherwise return as a ndarray
        """
        ...
    
    def get_scalar(self, tup):
        """
        Retrieve single item
        """
        ...
    
    def delete(self, item):
        """
        Delete selected item (items if non-unique) in-place.
        """
        self.blocks = ...
    
    def set(self, item, value, check: bool = ...):
        """
        Set new item in-place. Does not consolidate. Adds new Block if not
        contained in the current set of items
        if check, then validate that we are not setting the same data in-place
        """
        ...
    
    def insert(self, loc, item, value, allow_duplicates: bool = ...):
        """
        Insert item at selected position.

        Parameters
        ----------
        loc : int
        item : hashable
        value : array_like
        allow_duplicates: bool
            If False, trying to insert non-unique item will raise

        """
        ...
    
    def reindex_axis(self, new_index, axis, method: Optional[Any] = ..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ..., copy: bool = ...):
        """
        Conform block manager to new index.
        """
        ...
    
    def reindex_indexer(self, new_axis, indexer, axis, fill_value: Optional[Any] = ..., allow_dups: bool = ..., copy: bool = ...):
        """
        Parameters
        ----------
        new_axis : Index
        indexer : ndarray of int64 or None
        axis : int
        fill_value : object
        allow_dups : bool

        pandas-indexer with -1's only.
        """
        ...
    
    def _slice_take_blocks_ax0(self, slice_or_indexer, fill_tuple: Optional[Any] = ...):
        """
        Slice/take blocks along axis=0.

        Overloaded for SingleBlock

        Returns
        -------
        new_blocks : list of Block

        """
        ...
    
    def _make_na_block(self, placement, fill_value: Optional[Any] = ...):
        ...
    
    def take(self, indexer, axis=..., verify: bool = ..., convert: bool = ...):
        """
        Take items along any axis.
        """
        ...
    
    def merge(self, other, lsuffix=..., rsuffix=...):
        ...
    
    def _is_indexed_like(self, other):
        """
        Check all axes except items
        """
        ...
    
    def equals(self, other):
        ...
    
    def unstack(self, unstacker_func):
        """Return a blockmanager with all blocks unstacked.

        Parameters
        ----------
        unstacker_func : callable
            A (partially-applied) ``pd.core.reshape._Unstacker`` class.

        Returns
        -------
        unstacked : BlockManager
        """
        ...
    


class SingleBlockManager(BlockManager):
    """ manage a single block with """
    ndim = ...
    _is_consolidated = ...
    _known_consolidated = ...
    __slots__ = ...
    def __init__(self, block, axis, do_integrity_check: bool = ..., fastpath: bool = ...):
        self.blocks = ...
    
    def _post_setstate(self):
        ...
    
    @property
    def _block(self):
        ...
    
    @property
    def _values(self):
        ...
    
    @property
    def _blknos(self):
        """ compat with BlockManager """
        ...
    
    @property
    def _blklocs(self):
        """ compat with BlockManager """
        ...
    
    def reindex(self, new_axis, indexer: Optional[Any] = ..., method: Optional[Any] = ..., fill_value: Optional[Any] = ..., limit: Optional[Any] = ..., copy: bool = ...):
        ...
    
    def get_slice(self, slobj, axis=...):
        ...
    
    @property
    def index(self):
        ...
    
    def convert(self, **kwargs):
        """ convert the whole block as one """
        ...
    
    @property
    def dtype(self):
        ...
    
    @property
    def array_dtype(self):
        ...
    
    @property
    def ftype(self):
        ...
    
    def get_dtype_counts(self):
        ...
    
    def get_ftype_counts(self):
        ...
    
    def get_dtypes(self):
        ...
    
    def get_ftypes(self):
        ...
    
    def external_values(self):
        ...
    
    def internal_values(self):
        ...
    
    def formatting_values(self):
        """Return the internal values used by the DataFrame/SeriesFormatter"""
        ...
    
    def get_values(self):
        """ return a dense type view """
        ...
    
    @property
    def asobject(self):
        """
        return a object dtype array. datetime/timedelta like values are boxed
        to Timestamp/Timedelta instances.
        """
        ...
    
    @property
    def itemsize(self):
        ...
    
    @property
    def _can_hold_na(self):
        ...
    
    def is_consolidated(self):
        ...
    
    def _consolidate_check(self):
        ...
    
    def _consolidate_inplace(self):
        ...
    
    def delete(self, item):
        """
        Delete single item from SingleBlockManager.

        Ensures that self.blocks doesn't become empty.
        """
        ...
    
    def fast_xs(self, loc):
        """
        fast path for getting a cross-section
        return a view of the data
        """
        ...
    
    def concat(self, to_concat, new_axis):
        """
        Concatenate a list of SingleBlockManagers into a single
        SingleBlockManager.

        Used for pd.concat of Series objects with axis=0.

        Parameters
        ----------
        to_concat : list of SingleBlockManagers
        new_axis : Index of the result

        Returns
        -------
        SingleBlockManager

        """
        ...
    


def construction_error(tot_items, block_shape, axes, e: Optional[Any] = ...):
    """ raise a helpful message about our construction """
    ...

def create_block_manager_from_blocks(blocks, axes):
    ...

def create_block_manager_from_arrays(arrays, names, axes):
    ...

def form_blocks(arrays, names, axes):
    ...

def _simple_blockify(tuples, dtype):
    """ return a single array of a block that has a single dtype; if dtype is
    not None, coerce to this dtype
    """
    ...

def _multi_blockify(tuples, dtype: Optional[Any] = ...):
    """ return an array of blocks that potentially have different dtypes """
    ...

def _sparse_blockify(tuples, dtype: Optional[Any] = ...):
    """ return an array of blocks that potentially have different dtypes (and
    are sparse)
    """
    ...

def _stack_arrays(tuples, dtype):
    ...

def _interleaved_dtype(blocks):
    ...

def _consolidate(blocks):
    """
    Merge blocks having same dtype, exclude non-consolidating blocks
    """
    ...

def _merge_blocks(blocks, dtype: Optional[Any] = ..., _can_consolidate: bool = ...):
    ...

def _extend_blocks(result, blocks: Optional[Any] = ...):
    """ return a new extended blocks, givin the result """
    ...

def _block_shape(values, ndim=..., shape: Optional[Any] = ...):
    """ guarantee the shape of the values to be at least 1 d """
    ...

def _vstack(to_stack, dtype):
    ...

def _maybe_compare(a, b, op):
    ...

def _concat_indexes(indexes):
    ...

def _block2d_to_blocknd(values, placement, shape, labels, ref_items):
    """ pivot to the labels shape """
    ...

def _factor_indexer(shape, labels):
    """
    given a tuple of shape and a list of Categorical labels, return the
    expanded label indexer
    """
    ...

def _get_blkno_placements(blknos, blk_count, group: bool = ...):
    """

    Parameters
    ----------
    blknos : array of int64
    blk_count : int
    group : bool

    Returns
    -------
    iterator
        yield (BlockPlacement, blkno)

    """
    ...

def items_overlap_with_suffix(left, lsuffix, right, rsuffix):
    """
    If two indices overlap, add suffixes to overlapping entries.

    If corresponding suffix is empty, the entry is simply converted to string.

    """
    ...

def _safe_reshape(arr, new_shape):
    """
    If possible, reshape `arr` to have shape `new_shape`,
    with a couple of exceptions (see gh-13012):

    1) If `arr` is a Categorical or Index, `arr` will be
       returned as is.
    2) If `arr` is a Series, the `_values` attribute will
       be reshaped and returned.

    Parameters
    ----------
    arr : array-like, object to be reshaped
    new_shape : int or tuple of ints, the new shape
    """
    ...

def _transform_index(index, func, level: Optional[Any] = ...):
    """
    Apply function to all values found in index.

    This includes transforming multiindex entries separately.
    Only apply function to one level of the MultiIndex if level is specified.

    """
    ...

def _putmask_smart(v, m, n):
    """
    Return a new ndarray, try to preserve dtype if possible.

    Parameters
    ----------
    v : `values`, updated in-place (array like)
    m : `mask`, applies to both sides (array like)
    n : `new values` either scalar or an array like aligned with `values`

    Returns
    -------
    values : ndarray with updated values
        this *may* be a copy of the original

    See Also
    --------
    ndarray.putmask
    """
    ...

def concatenate_block_managers(mgrs_indexers, axes, concat_axis, copy):
    """
    Concatenate block managers into one.

    Parameters
    ----------
    mgrs_indexers : list of (BlockManager, {axis: indexer,...}) tuples
    axes : list of Index
    concat_axis : int
    copy : bool

    """
    ...

def is_uniform_join_units(join_units):
    """
    Check if the join units consist of blocks of uniform type that can
    be concatenated using Block.concat_same_type instead of the generic
    concatenate_join_units (which uses `_concat._concat_compat`).

    """
    ...

def get_empty_dtype_and_na(join_units):
    """
    Return dtype and N/A values to use when concatenating specified units.

    Returned N/A value may be None which means there was no casting involved.

    Returns
    -------
    dtype
    na
    """
    ...

def concatenate_join_units(join_units, concat_axis, copy):
    """
    Concatenate values from several join units along selected axis.
    """
    ...

def get_mgr_concatenation_plan(mgr, indexers):
    """
    Construct concatenation plan for given block manager and indexers.

    Parameters
    ----------
    mgr : BlockManager
    indexers : dict of {axis: indexer}

    Returns
    -------
    plan : list of (BlockPlacement, JoinUnit) tuples

    """
    ...

def combine_concat_plans(plans, concat_axis):
    """
    Combine multiple concatenation plans into one.

    existing_plan is updated in-place.
    """
    ...

def trim_join_unit(join_unit, length):
    """
    Reduce join_unit's shape along item axis to length.

    Extra items that didn't fit are returned as a separate block.
    """
    ...

class JoinUnit(object):
    def __init__(self, block, shape, indexers: Optional[Any] = ...):
        self.block = ...
        self.indexers = ...
        self.shape = ...
    
    def __repr__(self):
        ...
    
    @cache_readonly
    def needs_filling(self):
        ...
    
    @cache_readonly
    def dtype(self):
        ...
    
    @cache_readonly
    def is_na(self):
        ...
    
    def get_reindexed_values(self, empty_dtype, upcasted_na):
        ...
    


def _fast_count_smallints(arr):
    """Faster version of set(arr) for sequences of small numbers."""
    ...

def _preprocess_slice_or_indexer(slice_or_indexer, length, allow_fill):
    ...

