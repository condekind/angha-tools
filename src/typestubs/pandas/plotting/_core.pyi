"""
This type stub file was generated by pyright.
"""

from pandas.util._decorators import Appender, cache_readonly
from pandas.core.base import PandasObject
from pandas.core.generic import _shared_doc_kwargs, _shared_docs
from pandas.plotting._tools import table
from typing import Any, Optional

def _get_standard_kind(kind):
    ...

def _gca(rc: Optional[Any] = ...):
    ...

def _gcf():
    ...

class MPLPlot(object):
    """
    Base class for assembling a pandas plot using matplotlib

    Parameters
    ----------
    data :

    """
    @property
    def _kind(self):
        """Specify kind str. Must be overridden in child class"""
        ...
    
    _layout_type = ...
    _default_rot = ...
    orientation = ...
    _pop_attributes = ...
    _attr_defaults = ...
    def __init__(self, data, kind: Optional[Any] = ..., by: Optional[Any] = ..., subplots: bool = ..., sharex: Optional[Any] = ..., sharey: bool = ..., use_index: bool = ..., figsize: Optional[Any] = ..., grid: Optional[Any] = ..., legend: bool = ..., rot: Optional[Any] = ..., ax: Optional[Any] = ..., fig: Optional[Any] = ..., title: Optional[Any] = ..., xlim: Optional[Any] = ..., ylim: Optional[Any] = ..., xticks: Optional[Any] = ..., yticks: Optional[Any] = ..., sort_columns: bool = ..., fontsize: Optional[Any] = ..., secondary_y: bool = ..., colormap: Optional[Any] = ..., table: bool = ..., layout: Optional[Any] = ..., **kwds):
        self.data = ...
        self.by = ...
        self.kind = ...
        self.sort_columns = ...
        self.subplots = ...
        self.sharey = ...
        self.figsize = ...
        self.layout = ...
        self.xticks = ...
        self.yticks = ...
        self.xlim = ...
        self.ylim = ...
        self.title = ...
        self.use_index = ...
        self.fontsize = ...
        self.grid = ...
        self.legend = ...
        self.legend_handles = ...
        self.legend_labels = ...
        self.ax = ...
        self.fig = ...
        self.axes = ...
        self.errors = ...
        self.secondary_y = ...
        self.table = ...
        self.kwds = ...
    
    def _validate_color_args(self):
        ...
    
    def _iter_data(self, data: Optional[Any] = ..., keep_index: bool = ..., fillna: Optional[Any] = ...):
        ...
    
    @property
    def nseries(self):
        ...
    
    def draw(self):
        ...
    
    def generate(self):
        ...
    
    def _args_adjust(self):
        ...
    
    def _has_plotted_object(self, ax):
        """check whether ax has data"""
        ...
    
    def _maybe_right_yaxis(self, ax, axes_num):
        ...
    
    def _setup_subplots(self):
        self.fig = ...
        self.axes = ...
    
    @property
    def result(self):
        """
        Return result axes
        """
        ...
    
    def _compute_plot_data(self):
        self.data = ...
    
    def _make_plot(self):
        ...
    
    def _add_table(self):
        ...
    
    def _post_plot_logic_common(self, ax, data):
        """Common post process for each axes"""
        ...
    
    def _post_plot_logic(self, ax, data):
        """Post process for each axes. Overridden in child classes"""
        ...
    
    def _adorn_subplots(self):
        """Common post process unrelated to data"""
        ...
    
    def _apply_axis_properties(self, axis, rot: Optional[Any] = ..., fontsize: Optional[Any] = ...):
        ...
    
    @property
    def legend_title(self):
        ...
    
    def _add_legend_handle(self, handle, label, index: Optional[Any] = ...):
        ...
    
    def _make_legend(self):
        ...
    
    def _get_ax_legend(self, ax):
        ...
    
    @cache_readonly
    def plt(self):
        ...
    
    @staticmethod
    def mpl_ge_1_3_1():
        ...
    
    @staticmethod
    def mpl_ge_1_5_0():
        ...
    
    _need_to_set_index = ...
    def _get_xticks(self, convert_period: bool = ...):
        ...
    
    @classmethod
    def _plot(cls, ax, x, y, style: Optional[Any] = ..., is_errorbar: bool = ..., **kwds):
        ...
    
    def _get_index_name(self):
        ...
    
    @classmethod
    def _get_ax_layer(cls, ax, primary: bool = ...):
        """get left (primary) or right (secondary) axes"""
        ...
    
    def _get_ax(self, i):
        ...
    
    def on_right(self, i):
        ...
    
    def _apply_style_colors(self, colors, kwds, col_num, label):
        """
        Manage style and color based on column number and its label.
        Returns tuple of appropriate style and kwds which "color" may be added.
        """
        ...
    
    def _get_colors(self, num_colors: Optional[Any] = ..., color_kwds=...):
        ...
    
    def _parse_errorbars(self, label, err):
        """
        Look for error keyword arguments and return the actual errorbar data
        or return the error DataFrame/dict

        Error bars can be specified in several ways:
            Series: the user provides a pandas.Series object of the same
                    length as the data
            ndarray: provides a np.ndarray of the same length as the data
            DataFrame/dict: error values are paired with keys matching the
                    key in the plotted DataFrame
            str: the name of the column within the plotted DataFrame
        """
        ...
    
    def _get_errorbars(self, label: Optional[Any] = ..., index: Optional[Any] = ..., xerr: bool = ..., yerr: bool = ...):
        ...
    
    def _get_subplots(self):
        ...
    
    def _get_axes_layout(self):
        ...
    


class PlanePlot(MPLPlot):
    """
    Abstract class for plotting on plane, currently scatter and hexbin.
    """
    _layout_type = ...
    def __init__(self, data, x, y, **kwargs):
        self.x = ...
        self.y = ...
    
    @property
    def nseries(self):
        ...
    
    def _post_plot_logic(self, ax, data):
        ...
    


class ScatterPlot(PlanePlot):
    _kind = ...
    def __init__(self, data, x, y, s: Optional[Any] = ..., c: Optional[Any] = ..., **kwargs):
        self.c = ...
    
    def _make_plot(self):
        ...
    


class HexBinPlot(PlanePlot):
    _kind = ...
    def __init__(self, data, x, y, C: Optional[Any] = ..., **kwargs):
        self.C = ...
    
    def _make_plot(self):
        ...
    
    def _make_legend(self):
        ...
    


class LinePlot(MPLPlot):
    _kind = ...
    _default_rot = ...
    orientation = ...
    def __init__(self, data, **kwargs):
        self.x_compat = ...
    
    def _is_ts_plot(self):
        ...
    
    def _use_dynamic_x(self):
        ...
    
    def _make_plot(self):
        ...
    
    @classmethod
    def _plot(cls, ax, x, y, style: Optional[Any] = ..., column_num: Optional[Any] = ..., stacking_id: Optional[Any] = ..., **kwds):
        ...
    
    @classmethod
    def _ts_plot(cls, ax, x, data, style: Optional[Any] = ..., **kwds):
        ...
    
    def _get_stacking_id(self):
        ...
    
    @classmethod
    def _initialize_stacker(cls, ax, stacking_id, n):
        ...
    
    @classmethod
    def _get_stacked_values(cls, ax, stacking_id, values, label):
        ...
    
    @classmethod
    def _update_stacker(cls, ax, stacking_id, values):
        ...
    
    def _post_plot_logic(self, ax, data):
        ...
    


class AreaPlot(LinePlot):
    _kind = ...
    def __init__(self, data, **kwargs):
        ...
    
    @classmethod
    def _plot(cls, ax, x, y, style: Optional[Any] = ..., column_num: Optional[Any] = ..., stacking_id: Optional[Any] = ..., is_errorbar: bool = ..., **kwds):
        ...
    
    def _add_legend_handle(self, handle, label, index: Optional[Any] = ...):
        ...
    
    def _post_plot_logic(self, ax, data):
        ...
    


class BarPlot(MPLPlot):
    _kind = ...
    _default_rot = ...
    orientation = ...
    def __init__(self, data, **kwargs):
        self.bar_width = ...
        self.tick_pos = ...
        self.bottom = ...
        self.left = ...
        self.log = ...
        self.ax_pos = ...
    
    def _args_adjust(self):
        ...
    
    @classmethod
    def _plot(cls, ax, x, y, w, start=..., log: bool = ..., **kwds):
        ...
    
    @property
    def _start_base(self):
        ...
    
    def _make_plot(self):
        ...
    
    def _post_plot_logic(self, ax, data):
        ...
    
    def _decorate_ticks(self, ax, name, ticklabels, start_edge, end_edge):
        ...
    


class BarhPlot(BarPlot):
    _kind = ...
    _default_rot = ...
    orientation = ...
    @property
    def _start_base(self):
        ...
    
    @classmethod
    def _plot(cls, ax, x, y, w, start=..., log: bool = ..., **kwds):
        ...
    
    def _decorate_ticks(self, ax, name, ticklabels, start_edge, end_edge):
        ...
    


class HistPlot(LinePlot):
    _kind = ...
    def __init__(self, data, bins=..., bottom=..., **kwargs):
        self.bins = ...
        self.bottom = ...
    
    def _args_adjust(self):
        ...
    
    @classmethod
    def _plot(cls, ax, y, style: Optional[Any] = ..., bins: Optional[Any] = ..., bottom=..., column_num=..., stacking_id: Optional[Any] = ..., **kwds):
        ...
    
    def _make_plot(self):
        ...
    
    def _make_plot_keywords(self, kwds, y):
        """merge BoxPlot/KdePlot properties to passed kwds"""
        ...
    
    def _post_plot_logic(self, ax, data):
        ...
    
    @property
    def orientation(self):
        ...
    


class KdePlot(HistPlot):
    _kind = ...
    orientation = ...
    def __init__(self, data, bw_method: Optional[Any] = ..., ind: Optional[Any] = ..., **kwargs):
        self.bw_method = ...
        self.ind = ...
    
    def _args_adjust(self):
        ...
    
    def _get_ind(self, y):
        ...
    
    @classmethod
    def _plot(cls, ax, y, style: Optional[Any] = ..., bw_method: Optional[Any] = ..., ind: Optional[Any] = ..., column_num: Optional[Any] = ..., stacking_id: Optional[Any] = ..., **kwds):
        ...
    
    def _make_plot_keywords(self, kwds, y):
        ...
    
    def _post_plot_logic(self, ax, data):
        ...
    


class PiePlot(MPLPlot):
    _kind = ...
    _layout_type = ...
    def __init__(self, data, kind: Optional[Any] = ..., **kwargs):
        ...
    
    def _args_adjust(self):
        self.grid = ...
        self.logy = ...
        self.logx = ...
        self.loglog = ...
    
    def _validate_color_args(self):
        ...
    
    def _make_plot(self):
        ...
    


class BoxPlot(LinePlot):
    _kind = ...
    _layout_type = ...
    _valid_return_types = ...
    BP = ...
    def __init__(self, data, return_type=..., **kwargs):
        self.return_type = ...
    
    def _args_adjust(self):
        ...
    
    @classmethod
    def _plot(cls, ax, y, column_num: Optional[Any] = ..., return_type=..., **kwds):
        ...
    
    def _validate_color_args(self):
        ...
    
    def _get_colors(self, num_colors: Optional[Any] = ..., color_kwds=...):
        ...
    
    def maybe_color_bp(self, bp):
        ...
    
    def _make_plot(self):
        ...
    
    def _set_ticklabels(self, ax, labels):
        ...
    
    def _make_legend(self):
        ...
    
    def _post_plot_logic(self, ax, data):
        ...
    
    @property
    def orientation(self):
        ...
    
    @property
    def result(self):
        ...
    


_common_kinds = ['line', 'bar', 'barh', 'kde', 'density', 'area', 'hist', 'box']
_dataframe_kinds = ['scatter', 'hexbin']
_series_kinds = ['pie']
_all_kinds = _common_kinds + _dataframe_kinds + _series_kinds
_klasses = [LinePlot, BarPlot, BarhPlot, KdePlot, HistPlot, BoxPlot, ScatterPlot, HexBinPlot, AreaPlot, PiePlot]
_plot_klass = {  }
def _plot(data, x: Optional[Any] = ..., y: Optional[Any] = ..., subplots: bool = ..., ax: Optional[Any] = ..., kind=..., **kwds):
    ...

df_kind = """- 'scatter' : scatter plot
        - 'hexbin' : hexbin plot"""
series_kind = ""
df_coord = """x : label or position, default None
    y : label or position, default None
        Allows plotting of one column versus another"""
series_coord = ""
df_unique = """stacked : boolean, default False in line and
        bar plots, and True in area plot. If True, create stacked plot.
    sort_columns : boolean, default False
        Sort column names to determine plot ordering
    secondary_y : boolean or sequence, default False
        Whether to plot on the secondary y-axis
        If a list/tuple, which columns to plot on secondary y-axis"""
series_unique = """label : label argument to provide to plot
    secondary_y : boolean or sequence of ints, default False
        If True then y-axis will be on the right"""
df_ax = """ax : matplotlib axes object, default None
    subplots : boolean, default False
        Make separate subplots for each column
    sharex : boolean, default True if ax is None else False
        In case subplots=True, share x axis and set some x axis labels to
        invisible; defaults to True if ax is None otherwise False if an ax
        is passed in; Be aware, that passing in both an ax and sharex=True
        will alter all x axis labels for all axis in a figure!
    sharey : boolean, default False
        In case subplots=True, share y axis and set some y axis labels to
        invisible
    layout : tuple (optional)
        (rows, columns) for the layout of subplots"""
series_ax = """ax : matplotlib axes object
        If not passed, uses gca()"""
df_note = """- If `kind` = 'scatter' and the argument `c` is the name of a dataframe
      column, the values of that column are used to color each point.
    - If `kind` = 'hexbin', you can control the size of the bins with the
      `gridsize` argument. By default, a histogram of the counts around each
      `(x, y)` point is computed. You can specify alternative aggregations
      by passing values to the `C` and `reduce_C_function` arguments.
      `C` specifies the value at each `(x, y)` point and `reduce_C_function`
      is a function of one argument that reduces all the values in a bin to
      a single number (e.g. `mean`, `max`, `sum`, `std`)."""
series_note = ""
_shared_doc_df_kwargs = dict(klass='DataFrame', klass_obj='df', klass_kind=df_kind, klass_coord=df_coord, klass_ax=df_ax, klass_unique=df_unique, klass_note=df_note)
_shared_doc_series_kwargs = dict(klass='Series', klass_obj='s', klass_kind=series_kind, klass_coord=series_coord, klass_ax=series_ax, klass_unique=series_unique, klass_note=series_note)
@Appender(_shared_docs['plot'] % _shared_doc_df_kwargs)
def plot_frame(data, x: Optional[Any] = ..., y: Optional[Any] = ..., kind=..., ax: Optional[Any] = ..., subplots: bool = ..., sharex: Optional[Any] = ..., sharey: bool = ..., layout: Optional[Any] = ..., figsize: Optional[Any] = ..., use_index: bool = ..., title: Optional[Any] = ..., grid: Optional[Any] = ..., legend: bool = ..., style: Optional[Any] = ..., logx: bool = ..., logy: bool = ..., loglog: bool = ..., xticks: Optional[Any] = ..., yticks: Optional[Any] = ..., xlim: Optional[Any] = ..., ylim: Optional[Any] = ..., rot: Optional[Any] = ..., fontsize: Optional[Any] = ..., colormap: Optional[Any] = ..., table: bool = ..., yerr: Optional[Any] = ..., xerr: Optional[Any] = ..., secondary_y: bool = ..., sort_columns: bool = ..., **kwds):
    ...

@Appender(_shared_docs['plot'] % _shared_doc_series_kwargs)
def plot_series(data, kind=..., ax: Optional[Any] = ..., figsize: Optional[Any] = ..., use_index: bool = ..., title: Optional[Any] = ..., grid: Optional[Any] = ..., legend: bool = ..., style: Optional[Any] = ..., logx: bool = ..., logy: bool = ..., loglog: bool = ..., xticks: Optional[Any] = ..., yticks: Optional[Any] = ..., xlim: Optional[Any] = ..., ylim: Optional[Any] = ..., rot: Optional[Any] = ..., fontsize: Optional[Any] = ..., colormap: Optional[Any] = ..., table: bool = ..., yerr: Optional[Any] = ..., xerr: Optional[Any] = ..., label: Optional[Any] = ..., secondary_y: bool = ..., **kwds):
    ...

@Appender(_shared_docs['boxplot'] % _shared_doc_kwargs)
def boxplot(data, column: Optional[Any] = ..., by: Optional[Any] = ..., ax: Optional[Any] = ..., fontsize: Optional[Any] = ..., rot=..., grid: bool = ..., figsize: Optional[Any] = ..., layout: Optional[Any] = ..., return_type: Optional[Any] = ..., **kwds):
    ...

@Appender(_shared_docs['boxplot'] % _shared_doc_kwargs)
def boxplot_frame(self, column: Optional[Any] = ..., by: Optional[Any] = ..., ax: Optional[Any] = ..., fontsize: Optional[Any] = ..., rot=..., grid: bool = ..., figsize: Optional[Any] = ..., layout: Optional[Any] = ..., return_type: Optional[Any] = ..., **kwds):
    ...

def scatter_plot(data, x, y, by: Optional[Any] = ..., ax: Optional[Any] = ..., figsize: Optional[Any] = ..., grid: bool = ..., **kwargs):
    """
    Make a scatter plot from two DataFrame columns

    Parameters
    ----------
    data : DataFrame
    x : Column name for the x-axis values
    y : Column name for the y-axis values
    ax : Matplotlib axis object
    figsize : A tuple (width, height) in inches
    grid : Setting this to True will show the grid
    kwargs : other plotting keyword arguments
        To be passed to scatter function

    Returns
    -------
    fig : matplotlib.Figure
    """
    ...

def hist_frame(data, column: Optional[Any] = ..., by: Optional[Any] = ..., grid: bool = ..., xlabelsize: Optional[Any] = ..., xrot: Optional[Any] = ..., ylabelsize: Optional[Any] = ..., yrot: Optional[Any] = ..., ax: Optional[Any] = ..., sharex: bool = ..., sharey: bool = ..., figsize: Optional[Any] = ..., layout: Optional[Any] = ..., bins=..., **kwds):
    """
    Draw histogram of the DataFrame's series using matplotlib / pylab.

    Parameters
    ----------
    data : DataFrame
    column : string or sequence
        If passed, will be used to limit data to a subset of columns
    by : object, optional
        If passed, then used to form histograms for separate groups
    grid : boolean, default True
        Whether to show axis grid lines
    xlabelsize : int, default None
        If specified changes the x-axis label size
    xrot : float, default None
        rotation of x axis labels
    ylabelsize : int, default None
        If specified changes the y-axis label size
    yrot : float, default None
        rotation of y axis labels
    ax : matplotlib axes object, default None
    sharex : boolean, default True if ax is None else False
        In case subplots=True, share x axis and set some x axis labels to
        invisible; defaults to True if ax is None otherwise False if an ax
        is passed in; Be aware, that passing in both an ax and sharex=True
        will alter all x axis labels for all subplots in a figure!
    sharey : boolean, default False
        In case subplots=True, share y axis and set some y axis labels to
        invisible
    figsize : tuple
        The size of the figure to create in inches by default
    layout : tuple, optional
        Tuple of (rows, columns) for the layout of the histograms
    bins : integer, default 10
        Number of histogram bins to be used
    kwds : other plotting keyword arguments
        To be passed to hist function
    """
    ...

def hist_series(self, by: Optional[Any] = ..., ax: Optional[Any] = ..., grid: bool = ..., xlabelsize: Optional[Any] = ..., xrot: Optional[Any] = ..., ylabelsize: Optional[Any] = ..., yrot: Optional[Any] = ..., figsize: Optional[Any] = ..., bins=..., **kwds):
    """
    Draw histogram of the input series using matplotlib

    Parameters
    ----------
    by : object, optional
        If passed, then used to form histograms for separate groups
    ax : matplotlib axis object
        If not passed, uses gca()
    grid : boolean, default True
        Whether to show axis grid lines
    xlabelsize : int, default None
        If specified changes the x-axis label size
    xrot : float, default None
        rotation of x axis labels
    ylabelsize : int, default None
        If specified changes the y-axis label size
    yrot : float, default None
        rotation of y axis labels
    figsize : tuple, default None
        figure size in inches by default
    bins: integer, default 10
        Number of histogram bins to be used
    kwds : keywords
        To be passed to the actual plotting function

    Notes
    -----
    See matplotlib documentation online for more on this

    """
    ...

def grouped_hist(data, column: Optional[Any] = ..., by: Optional[Any] = ..., ax: Optional[Any] = ..., bins=..., figsize: Optional[Any] = ..., layout: Optional[Any] = ..., sharex: bool = ..., sharey: bool = ..., rot=..., grid: bool = ..., xlabelsize: Optional[Any] = ..., xrot: Optional[Any] = ..., ylabelsize: Optional[Any] = ..., yrot: Optional[Any] = ..., **kwargs):
    """
    Grouped histogram

    Parameters
    ----------
    data: Series/DataFrame
    column: object, optional
    by: object, optional
    ax: axes, optional
    bins: int, default 50
    figsize: tuple, optional
    layout: optional
    sharex: boolean, default False
    sharey: boolean, default False
    rot: int, default 90
    grid: bool, default True
    kwargs: dict, keyword arguments passed to matplotlib.Axes.hist

    Returns
    -------
    axes: collection of Matplotlib Axes
    """
    ...

def boxplot_frame_groupby(grouped, subplots: bool = ..., column: Optional[Any] = ..., fontsize: Optional[Any] = ..., rot=..., grid: bool = ..., ax: Optional[Any] = ..., figsize: Optional[Any] = ..., layout: Optional[Any] = ..., **kwds):
    """
    Make box plots from DataFrameGroupBy data.

    Parameters
    ----------
    grouped : Grouped DataFrame
    subplots :
        * ``False`` - no subplots will be used
        * ``True`` - create a subplot for each group
    column : column name or list of names, or vector
        Can be any valid input to groupby
    fontsize : int or string
    rot : label rotation angle
    grid : Setting this to True will show the grid
    ax : Matplotlib axis object, default None
    figsize : A tuple (width, height) in inches
    layout : tuple (optional)
        (rows, columns) for the layout of the plot
    kwds : other plotting keyword arguments to be passed to matplotlib boxplot
           function

    Returns
    -------
    dict of key/value = group key/DataFrame.boxplot return value
    or DataFrame.boxplot return value in case subplots=figures=False

    Examples
    --------
    >>> import pandas
    >>> import numpy as np
    >>> import itertools
    >>>
    >>> tuples = [t for t in itertools.product(range(1000), range(4))]
    >>> index = pandas.MultiIndex.from_tuples(tuples, names=['lvl0', 'lvl1'])
    >>> data = np.random.randn(len(index),4)
    >>> df = pandas.DataFrame(data, columns=list('ABCD'), index=index)
    >>>
    >>> grouped = df.groupby(level='lvl1')
    >>> boxplot_frame_groupby(grouped)
    >>>
    >>> grouped = df.unstack(level='lvl1').groupby(level=0, axis=1)
    >>> boxplot_frame_groupby(grouped, subplots=False)
    """
    ...

def _grouped_plot(plotf, data, column: Optional[Any] = ..., by: Optional[Any] = ..., numeric_only: bool = ..., figsize: Optional[Any] = ..., sharex: bool = ..., sharey: bool = ..., layout: Optional[Any] = ..., rot=..., ax: Optional[Any] = ..., **kwargs):
    ...

def _grouped_plot_by_column(plotf, data, columns: Optional[Any] = ..., by: Optional[Any] = ..., numeric_only: bool = ..., grid: bool = ..., figsize: Optional[Any] = ..., ax: Optional[Any] = ..., layout: Optional[Any] = ..., return_type: Optional[Any] = ..., **kwargs):
    ...

class BasePlotMethods(PandasObject):
    def __init__(self, data):
        ...
    
    def __call__(self, *args, **kwargs):
        ...
    


class SeriesPlotMethods(BasePlotMethods):
    """Series plotting accessor and method

    Examples
    --------
    >>> s.plot.line()
    >>> s.plot.bar()
    >>> s.plot.hist()

    Plotting methods can also be accessed by calling the accessor as a method
    with the ``kind`` argument:
    ``s.plot(kind='line')`` is equivalent to ``s.plot.line()``
    """
    def __call__(self, kind=..., ax: Optional[Any] = ..., figsize: Optional[Any] = ..., use_index: bool = ..., title: Optional[Any] = ..., grid: Optional[Any] = ..., legend: bool = ..., style: Optional[Any] = ..., logx: bool = ..., logy: bool = ..., loglog: bool = ..., xticks: Optional[Any] = ..., yticks: Optional[Any] = ..., xlim: Optional[Any] = ..., ylim: Optional[Any] = ..., rot: Optional[Any] = ..., fontsize: Optional[Any] = ..., colormap: Optional[Any] = ..., table: bool = ..., yerr: Optional[Any] = ..., xerr: Optional[Any] = ..., label: Optional[Any] = ..., secondary_y: bool = ..., **kwds):
        ...
    
    def line(self, **kwds):
        """
        Line plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def bar(self, **kwds):
        """
        Vertical bar plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def barh(self, **kwds):
        """
        Horizontal bar plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def box(self, **kwds):
        """
        Boxplot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def hist(self, bins=..., **kwds):
        """
        Histogram

        .. versionadded:: 0.17.0

        Parameters
        ----------
        bins: integer, default 10
            Number of histogram bins to be used
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def kde(self, **kwds):
        """
        Kernel Density Estimate plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    density = ...
    def area(self, **kwds):
        """
        Area plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def pie(self, **kwds):
        """
        Pie chart

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.Series.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    


class FramePlotMethods(BasePlotMethods):
    """DataFrame plotting accessor and method

    Examples
    --------
    >>> df.plot.line()
    >>> df.plot.scatter('x', 'y')
    >>> df.plot.hexbin()

    These plotting methods can also be accessed by calling the accessor as a
    method with the ``kind`` argument:
    ``df.plot(kind='line')`` is equivalent to ``df.plot.line()``
    """
    def __call__(self, x: Optional[Any] = ..., y: Optional[Any] = ..., kind=..., ax: Optional[Any] = ..., subplots: bool = ..., sharex: Optional[Any] = ..., sharey: bool = ..., layout: Optional[Any] = ..., figsize: Optional[Any] = ..., use_index: bool = ..., title: Optional[Any] = ..., grid: Optional[Any] = ..., legend: bool = ..., style: Optional[Any] = ..., logx: bool = ..., logy: bool = ..., loglog: bool = ..., xticks: Optional[Any] = ..., yticks: Optional[Any] = ..., xlim: Optional[Any] = ..., ylim: Optional[Any] = ..., rot: Optional[Any] = ..., fontsize: Optional[Any] = ..., colormap: Optional[Any] = ..., table: bool = ..., yerr: Optional[Any] = ..., xerr: Optional[Any] = ..., secondary_y: bool = ..., sort_columns: bool = ..., **kwds):
        ...
    
    def line(self, x: Optional[Any] = ..., y: Optional[Any] = ..., **kwds):
        """
        Line plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        x, y : label or position, optional
            Coordinates for each point.
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def bar(self, x: Optional[Any] = ..., y: Optional[Any] = ..., **kwds):
        """
        Vertical bar plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        x, y : label or position, optional
            Coordinates for each point.
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def barh(self, x: Optional[Any] = ..., y: Optional[Any] = ..., **kwds):
        """
        Horizontal bar plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        x, y : label or position, optional
            Coordinates for each point.
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def box(self, by: Optional[Any] = ..., **kwds):
        r"""
        Boxplot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        by : string or sequence
            Column in the DataFrame to group by.
        \*\*kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def hist(self, by: Optional[Any] = ..., bins=..., **kwds):
        """
        Histogram

        .. versionadded:: 0.17.0

        Parameters
        ----------
        by : string or sequence
            Column in the DataFrame to group by.
        bins: integer, default 10
            Number of histogram bins to be used
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def kde(self, **kwds):
        """
        Kernel Density Estimate plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    density = ...
    def area(self, x: Optional[Any] = ..., y: Optional[Any] = ..., **kwds):
        """
        Area plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        x, y : label or position, optional
            Coordinates for each point.
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def pie(self, y: Optional[Any] = ..., **kwds):
        """
        Pie chart

        .. versionadded:: 0.17.0

        Parameters
        ----------
        y : label or position, optional
            Column to plot.
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def scatter(self, x, y, s: Optional[Any] = ..., c: Optional[Any] = ..., **kwds):
        """
        Scatter plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        x, y : label or position, optional
            Coordinates for each point.
        s : scalar or array_like, optional
            Size of each point.
        c : label or position, optional
            Color of each point.
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    
    def hexbin(self, x, y, C: Optional[Any] = ..., reduce_C_function: Optional[Any] = ..., gridsize: Optional[Any] = ..., **kwds):
        """
        Hexbin plot

        .. versionadded:: 0.17.0

        Parameters
        ----------
        x, y : label or position, optional
            Coordinates for each point.
        C : label or position, optional
            The value at each `(x, y)` point.
        reduce_C_function : callable, optional
            Function of one argument that reduces all the values in a bin to
            a single number (e.g. `mean`, `max`, `sum`, `std`).
        gridsize : int, optional
            Number of bins.
        **kwds : optional
            Keyword arguments to pass on to :py:meth:`pandas.DataFrame.plot`.

        Returns
        -------
        axes : matplotlib.AxesSubplot or np.array of them
        """
        ...
    


