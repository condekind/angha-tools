"""
This type stub file was generated by pyright.
"""

import functools
import itertools
import sys
import platform
import types
import struct
import inspect
import re
import dateutil
from distutils.version import LooseVersion
from itertools import product
from unicodedata import east_asian_width
from collections import Counter, OrderedDict, namedtuple
from pandas.compat.chainmap import DeepChainMap
from typing import Any, Optional
from dateutil import parser as _date_parser

"""
compat
======

Cross-compatible functions for Python 2 and 3.

Key items to import for 2/3 compatible code:
* iterators: range(), map(), zip(), filter(), reduce()
* lists: lrange(), lmap(), lzip(), lfilter()
* unicode: u() [no unicode builtin in Python 3]
* longs: long (int in Python 3)
* callable
* iterable method compatibility: iteritems, iterkeys, itervalues
  * Uses the original method if available, otherwise uses items, keys, values.
* types:
    * text_type: unicode in Python 2, str in Python 3
    * binary_type: str in Python 2, bytes in Python 3
    * string_types: basestring in Python 2, str in Python 3
* bind_method: binds functions to classes
* add_metaclass(metaclass) - class decorator that recreates class with with the
  given metaclass instead (and avoids intermediary class creation)

Other items:
* platform checker
"""
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] >= 3
PY35 = sys.version_info >= (3, 5)
PY36 = sys.version_info >= (3, 6)
PYPY = platform.python_implementation() == 'PyPy'
if PY3:
    def isidentifier(s):
        ...
    
    def str_to_bytes(s, encoding: Optional[Any] = ...):
        ...
    
    def bytes_to_str(b, encoding: Optional[Any] = ...):
        ...
    
    def signature(f):
        ...
    
    def get_range_parameters(data):
        """Gets the start, stop, and step parameters from a range object"""
        ...
    
    range = range
    map = map
    zip = zip
    filter = filter
    intern = sys.intern
    reduce = functools.reduce
    long = int
    unichr = chr
    FileNotFoundError = FileNotFoundError
    def lrange(*args, **kwargs):
        ...
    
    def lzip(*args, **kwargs):
        ...
    
    def lmap(*args, **kwargs):
        ...
    
    def lfilter(*args, **kwargs):
        ...
    
else:
    _name_re = re.compile(r"[a-zA-Z_][a-zA-Z0-9_]*$")
    FileNotFoundError = IOError
    def isidentifier(s, dotted: bool = ...):
        ...
    
    def str_to_bytes(s, encoding=...):
        ...
    
    def bytes_to_str(b, encoding=...):
        ...
    
    def signature(f):
        ...
    
    def get_range_parameters(data):
        """Gets the start, stop, and step parameters from a range object"""
        ...
    
    range = xrange
    intern = intern
    zip = itertools.izip
    filter = itertools.ifilter
    map = itertools.imap
    reduce = reduce
    long = long
    unichr = unichr
    lrange = builtins.range
    lzip = builtins.zip
    lmap = builtins.map
    lfilter = builtins.filter
if PY2:
    def iteritems(obj, **kw):
        ...
    
    def iterkeys(obj, **kw):
        ...
    
    def itervalues(obj, **kw):
        ...
    
    next = lambda it: it.next()
else:
    def iteritems(obj, **kw):
        ...
    
    def iterkeys(obj, **kw):
        ...
    
    def itervalues(obj, **kw):
        ...
    
    next = next
def bind_method(cls, name, func):
    """Bind a method to class, python 2 and python 3 compatible.

    Parameters
    ----------

    cls : type
        class to receive bound method
    name : basestring
        name of method on class instance
    func : function
        function to be bound as method


    Returns
    -------
    None
    """
    ...

_EAW_MAP = { 'Na': 1,'N': 1,'W': 2,'F': 2,'H': 1 }
if PY3:
    string_types = (str, )
    integer_types = (int, )
    class_types = (type, )
    text_type = str
    binary_type = bytes
    def u(s):
        ...
    
    def u_safe(s):
        ...
    
    def to_str(s):
        """
        Convert bytes and non-string into Python 3 str
        """
        ...
    
    def strlen(data, encoding: Optional[Any] = ...):
        ...
    
    def east_asian_len(data, encoding: Optional[Any] = ..., ambiguous_width=...):
        """
        Calculate display width considering unicode East Asian Width
        """
        ...
    
    def import_lzma():
        """ import lzma from the std library """
        ...
    
    def set_function_name(f, name, cls):
        """ Bind the name/qualname attributes of the function """
        ...
    
    ResourceWarning = ResourceWarning
else:
    string_types = (basestring, )
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str
    def u(s):
        ...
    
    def u_safe(s):
        ...
    
    def to_str(s):
        """
        Convert unicode and non-string into Python 2 str
        """
        ...
    
    def strlen(data, encoding: Optional[Any] = ...):
        ...
    
    def east_asian_len(data, encoding: Optional[Any] = ..., ambiguous_width=...):
        """
        Calculate display width considering unicode East Asian Width
        """
        ...
    
    def import_lzma():
        """ import the backported lzma library
        or raise ImportError if not available """
        ...
    
    def set_function_name(f, name, cls):
        """ Bind the name attributes of the function """
        ...
    
    class ResourceWarning(Warning):
        ...
    
    
string_and_binary_types = string_types + (binary_type, )
def add_metaclass(metaclass):
    """Class decorator for creating a class with a metaclass."""
    ...

if PY3:
    def raise_with_traceback(exc, traceback=...):
        ...
    
else:
    ...
if PY2 and LooseVersion(dateutil.__version__) == '2.0':
    ...
if LooseVersion(dateutil.__version__) < '2.0':
    @functools.wraps(_date_parser.parse)
    def parse_date(timestr, *args, **kwargs):
        ...
    
else:
    parse_date = _date_parser.parse
def is_platform_little_endian():
    """ am I little endian """
    ...

def is_platform_windows():
    ...

def is_platform_linux():
    ...

def is_platform_mac():
    ...

def is_platform_32bit():
    ...

