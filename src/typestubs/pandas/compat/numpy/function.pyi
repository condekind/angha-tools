"""
This type stub file was generated by pyright.
"""

from pandas.compat import OrderedDict
from typing import Any, Optional

"""
For compatibility with numpy libraries, pandas functions or
methods have to accept '*args' and '**kwargs' parameters to
accommodate numpy arguments that are not actually used or
respected in the pandas implementation.

To ensure that users do not abuse these parameters, validation
is performed in 'validators.py' to make sure that any extra
parameters passed correspond ONLY to those in the numpy signature.
Part of that validation includes whether or not the user attempted
to pass in non-default values for these extraneous parameters. As we
want to discourage users from relying on these parameters when calling
the pandas implementation, we want them only to pass in the default values
for these parameters.

This module provides a set of commonly used default arguments for functions
and methods that are spread throughout the codebase. This module will make it
easier to adjust to future upstream changes in the analogous numpy signatures.
"""
class CompatValidator(object):
    def __init__(self, defaults, fname: Optional[Any] = ..., method: Optional[Any] = ..., max_fname_arg_count: Optional[Any] = ...):
        self.fname = ...
        self.method = ...
        self.defaults = ...
        self.max_fname_arg_count = ...
    
    def __call__(self, args, kwargs, fname: Optional[Any] = ..., max_fname_arg_count: Optional[Any] = ..., method: Optional[Any] = ...):
        ...
    


ARGMINMAX_DEFAULTS = dict(out=None)
validate_argmin = CompatValidator(ARGMINMAX_DEFAULTS, fname='argmin', method='both', max_fname_arg_count=1)
validate_argmax = CompatValidator(ARGMINMAX_DEFAULTS, fname='argmax', method='both', max_fname_arg_count=1)
def process_skipna(skipna, args):
    ...

def validate_argmin_with_skipna(skipna, args, kwargs):
    """
    If 'Series.argmin' is called via the 'numpy' library,
    the third parameter in its signature is 'out', which
    takes either an ndarray or 'None', so check if the
    'skipna' parameter is either an instance of ndarray or
    is None, since 'skipna' itself should be a boolean
    """
    ...

def validate_argmax_with_skipna(skipna, args, kwargs):
    """
    If 'Series.argmax' is called via the 'numpy' library,
    the third parameter in its signature is 'out', which
    takes either an ndarray or 'None', so check if the
    'skipna' parameter is either an instance of ndarray or
    is None, since 'skipna' itself should be a boolean
    """
    ...

ARGSORT_DEFAULTS = OrderedDict()
validate_argsort = CompatValidator(ARGSORT_DEFAULTS, fname='argsort', max_fname_arg_count=0, method='both')
ARGSORT_DEFAULTS_KIND = OrderedDict()
validate_argsort_kind = CompatValidator(ARGSORT_DEFAULTS_KIND, fname='argsort', max_fname_arg_count=0, method='both')
def validate_argsort_with_ascending(ascending, args, kwargs):
    """
    If 'Categorical.argsort' is called via the 'numpy' library, the
    first parameter in its signature is 'axis', which takes either
    an integer or 'None', so check if the 'ascending' parameter has
    either integer type or is None, since 'ascending' itself should
    be a boolean
    """
    ...

CLIP_DEFAULTS = dict(out=None)
validate_clip = CompatValidator(CLIP_DEFAULTS, fname='clip', method='both', max_fname_arg_count=3)
def validate_clip_with_axis(axis, args, kwargs):
    """
    If 'NDFrame.clip' is called via the numpy library, the third
    parameter in its signature is 'out', which can takes an ndarray,
    so check if the 'axis' parameter is an instance of ndarray, since
    'axis' itself should either be an integer or None
    """
    ...

COMPRESS_DEFAULTS = OrderedDict()
validate_compress = CompatValidator(COMPRESS_DEFAULTS, fname='compress', method='both', max_fname_arg_count=1)
CUM_FUNC_DEFAULTS = OrderedDict()
validate_cum_func = CompatValidator(CUM_FUNC_DEFAULTS, method='both', max_fname_arg_count=1)
validate_cumsum = CompatValidator(CUM_FUNC_DEFAULTS, fname='cumsum', method='both', max_fname_arg_count=1)
def validate_cum_func_with_skipna(skipna, args, kwargs, name):
    """
    If this function is called via the 'numpy' library, the third
    parameter in its signature is 'dtype', which takes either a
    'numpy' dtype or 'None', so check if the 'skipna' parameter is
    a boolean or not
    """
    ...

ALLANY_DEFAULTS = OrderedDict()
validate_all = CompatValidator(ALLANY_DEFAULTS, fname='all', method='both', max_fname_arg_count=1)
validate_any = CompatValidator(ALLANY_DEFAULTS, fname='any', method='both', max_fname_arg_count=1)
LOGICAL_FUNC_DEFAULTS = dict(out=None)
validate_logical_func = CompatValidator(LOGICAL_FUNC_DEFAULTS, method='kwargs')
MINMAX_DEFAULTS = dict(out=None)
validate_min = CompatValidator(MINMAX_DEFAULTS, fname='min', method='both', max_fname_arg_count=1)
validate_max = CompatValidator(MINMAX_DEFAULTS, fname='max', method='both', max_fname_arg_count=1)
RESHAPE_DEFAULTS = dict(order='C')
validate_reshape = CompatValidator(RESHAPE_DEFAULTS, fname='reshape', method='both', max_fname_arg_count=1)
REPEAT_DEFAULTS = dict(axis=None)
validate_repeat = CompatValidator(REPEAT_DEFAULTS, fname='repeat', method='both', max_fname_arg_count=1)
ROUND_DEFAULTS = dict(out=None)
validate_round = CompatValidator(ROUND_DEFAULTS, fname='round', method='both', max_fname_arg_count=1)
SORT_DEFAULTS = OrderedDict()
validate_sort = CompatValidator(SORT_DEFAULTS, fname='sort', method='kwargs')
STAT_FUNC_DEFAULTS = OrderedDict()
validate_stat_func = CompatValidator(STAT_FUNC_DEFAULTS, method='kwargs')
validate_sum = CompatValidator(STAT_FUNC_DEFAULTS, fname='sort', method='both', max_fname_arg_count=1)
validate_mean = CompatValidator(STAT_FUNC_DEFAULTS, fname='mean', method='both', max_fname_arg_count=1)
STAT_DDOF_FUNC_DEFAULTS = OrderedDict()
validate_stat_ddof_func = CompatValidator(STAT_DDOF_FUNC_DEFAULTS, method='kwargs')
TAKE_DEFAULTS = OrderedDict()
validate_take = CompatValidator(TAKE_DEFAULTS, fname='take', method='kwargs')
def validate_take_with_convert(convert, args, kwargs):
    """
    If this function is called via the 'numpy' library, the third
    parameter in its signature is 'axis', which takes either an
    ndarray or 'None', so check if the 'convert' parameter is either
    an instance of ndarray or is None
    """
    ...

TRANSPOSE_DEFAULTS = dict(axes=None)
validate_transpose = CompatValidator(TRANSPOSE_DEFAULTS, fname='transpose', method='both', max_fname_arg_count=0)
def validate_transpose_for_generic(inst, kwargs):
    ...

def validate_window_func(name, args, kwargs):
    ...

def validate_rolling_func(name, args, kwargs):
    ...

def validate_expanding_func(name, args, kwargs):
    ...

def validate_groupby_func(name, args, kwargs, allowed: Optional[Any] = ...):
    """
    'args' and 'kwargs' should be empty, except for allowed
    kwargs because all of
    their necessary parameters are explicitly listed in
    the function signature
    """
    ...

RESAMPLER_NUMPY_OPS = ('min', 'max', 'sum', 'prod', 'mean', 'std', 'var')
def validate_resampler_func(method, args, kwargs):
    """
    'args' and 'kwargs' should be empty because all of
    their necessary parameters are explicitly listed in
    the function signature
    """
    ...

