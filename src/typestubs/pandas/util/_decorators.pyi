"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

def deprecate(name, alternative, alt_name: Optional[Any] = ..., klass: Optional[Any] = ..., stacklevel=..., msg: Optional[Any] = ...):
    """
    Return a new function that emits a deprecation warning on use.

    Parameters
    ----------
    name : str
        Name of function to deprecate
    alternative : str
        Name of function to use instead
    alt_name : str, optional
        Name to use in preference of alternative.__name__
    klass : Warning, default FutureWarning
    stacklevel : int, default 2
    msg : str
          The message to display in the warning.
          Default is '{name} is deprecated. Use {alt_name} instead.'
    """
    ...

def deprecate_kwarg(old_arg_name, new_arg_name, mapping: Optional[Any] = ..., stacklevel=...):
    """
    Decorator to deprecate a keyword argument of a function.

    Parameters
    ----------
    old_arg_name : str
        Name of argument in function to deprecate
    new_arg_name : str
        Name of preferred argument in function
    mapping : dict or callable
        If mapping is present, use it to translate old arguments to
        new arguments. A callable must do its own value checking;
        values not found in a dict will be forwarded unchanged.

    Examples
    --------
    The following deprecates 'cols', using 'columns' instead

    >>> @deprecate_kwarg(old_arg_name='cols', new_arg_name='columns')
    ... def f(columns=''):
    ...     print(columns)
    ...
    >>> f(columns='should work ok')
    should work ok
    >>> f(cols='should raise warning')
    FutureWarning: cols is deprecated, use columns instead
      warnings.warn(msg, FutureWarning)
    should raise warning
    >>> f(cols='should error', columns="can\'t pass do both")
    TypeError: Can only specify 'cols' or 'columns', not both
    >>> @deprecate_kwarg('old', 'new', {'yes': True, 'no': False})
    ... def f(new=False):
    ...     print('yes!' if new else 'no!')
    ...
    >>> f(old='yes')
    FutureWarning: old='yes' is deprecated, use new=True instead
      warnings.warn(msg, FutureWarning)
    yes!
    """
    ...

def rewrite_axis_style_signature(name, extra_params):
    ...

class Substitution(object):
    """
    A decorator to take a function's docstring and perform string
    substitution on it.

    This decorator should be robust even if func.__doc__ is None
    (for example, if -OO was passed to the interpreter)

    Usage: construct a docstring.Substitution with a sequence or
    dictionary suitable for performing substitution; then
    decorate a suitable function with the constructed object. e.g.

    sub_author_name = Substitution(author='Jason')

    @sub_author_name
    def some_function(x):
        "%(author)s wrote this function"

    # note that some_function.__doc__ is now "Jason wrote this function"

    One can also use positional arguments.

    sub_first_last_names = Substitution('Edgar Allen', 'Poe')

    @sub_first_last_names
    def some_function(x):
        "%s %s wrote the Raven"
    """
    def __init__(self, *args, **kwargs):
        self.params = ...
    
    def __call__(self, func):
        ...
    
    def update(self, *args, **kwargs):
        """
        Update self.params with supplied args.

        If called, we assume self.params is a dict.
        """
        ...
    
    @classmethod
    def from_params(cls, params):
        """
        In the case where the params is a mutable sequence (list or dictionary)
        and it may change before this class is called, one may explicitly use a
        reference to the params rather than using *args or **kwargs which will
        copy the values and not reference them.
        """
        ...
    


class Appender(object):
    """
    A function decorator that will append an addendum to the docstring
    of the target function.

    This decorator should be robust even if func.__doc__ is None
    (for example, if -OO was passed to the interpreter).

    Usage: construct a docstring.Appender with a string to be joined to
    the original docstring. An optional 'join' parameter may be supplied
    which will be used to join the docstring and addendum. e.g.

    add_copyright = Appender("Copyright (c) 2009", join='\n')

    @add_copyright
    def my_dog(has='fleas'):
        "This docstring will have a copyright below"
        pass
    """
    def __init__(self, addendum, join=..., indents=...):
        self.join = ...
    
    def __call__(self, func):
        self.addendum = ...
    


def indent(text, indents=...):
    ...

def make_signature(func):
    """
    Returns a string repr of the arg list of a func call, with any defaults.

    Examples
    --------
    >>> def f(a,b,c=2) :
    >>>     return a*b*c
    >>> print(_make_signature(f))
    a,b,c=2
    """
    ...

class docstring_wrapper(object):
    """
    Decorator to wrap a function and provide
    a dynamically evaluated doc-string.

    Parameters
    ----------
    func : callable
    creator : callable
        return the doc-string
    default : str, optional
        return this doc-string on error
    """
    _attrs = ...
    def __init__(self, func, creator, default: Optional[Any] = ...):
        self.func = ...
        self.creator = ...
        self.default = ...
    
    def __get__(self, instance, cls: Optional[Any] = ...):
        ...
    
    def __call__(self, *args, **kwargs):
        ...
    
    @property
    def __doc__(self):
        ...
    


