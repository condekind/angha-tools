"""
This type stub file was generated by pyright.
"""

from pandas.compat import long
from pandas.tseries.offsets import Day, Hour, Micro, Milli, Minute, Nano, Second
from pandas.util._decorators import cache_readonly, deprecate_kwarg
from pandas._libs import tslib

class FreqGroup(object):
    FR_ANN = ...
    FR_QTR = ...
    FR_MTH = ...
    FR_WK = ...
    FR_BUS = ...
    FR_DAY = ...
    FR_HR = ...
    FR_MIN = ...
    FR_SEC = ...
    FR_MS = ...
    FR_US = ...
    FR_NS = ...


RESO_NS = 0
RESO_US = 1
RESO_MS = 2
RESO_SEC = 3
RESO_MIN = 4
RESO_HR = 5
RESO_DAY = 6
class Resolution(object):
    RESO_US = ...
    RESO_MS = ...
    RESO_SEC = ...
    RESO_MIN = ...
    RESO_HR = ...
    RESO_DAY = ...
    _reso_str_map = ...
    _reso_mult_map = ...
    _reso_str_bump_map = ...
    _str_reso_map = ...
    _reso_freq_map = ...
    _freq_reso_map = ...
    @classmethod
    def get_str(cls, reso):
        """
        Return resolution str against resolution code.

        Example
        -------
        >>> Resolution.get_str(Resolution.RESO_SEC)
        'second'
        """
        ...
    
    @classmethod
    def get_reso(cls, resostr):
        """
        Return resolution str against resolution code.

        Example
        -------
        >>> Resolution.get_reso('second')
        2

        >>> Resolution.get_reso('second') == Resolution.RESO_SEC
        True
        """
        ...
    
    @classmethod
    def get_freq_group(cls, resostr):
        """
        Return frequency str against resolution str.

        Example
        -------
        >>> f.Resolution.get_freq_group('day')
        4000
        """
        ...
    
    @classmethod
    def get_freq(cls, resostr):
        """
        Return frequency str against resolution str.

        Example
        -------
        >>> f.Resolution.get_freq('day')
        'D'
        """
        ...
    
    @classmethod
    def get_str_from_freq(cls, freq):
        """
        Return resolution str against frequency str.

        Example
        -------
        >>> Resolution.get_str_from_freq('H')
        'hour'
        """
        ...
    
    @classmethod
    def get_reso_from_freq(cls, freq):
        """
        Return resolution code against frequency str.

        Example
        -------
        >>> Resolution.get_reso_from_freq('H')
        4

        >>> Resolution.get_reso_from_freq('H') == Resolution.RESO_HR
        True
        """
        ...
    
    @classmethod
    def get_stride_from_decimal(cls, value, freq):
        """
        Convert freq with decimal stride into a higher freq with integer stride

        Parameters
        ----------
        value : integer or float
        freq : string
            Frequency string

        Raises
        ------
        ValueError
            If the float cannot be converted to an integer at any resolution.

        Example
        -------
        >>> Resolution.get_stride_from_decimal(1.5, 'T')
        (90, 'S')

        >>> Resolution.get_stride_from_decimal(1.04, 'H')
        (3744, 'S')

        >>> Resolution.get_stride_from_decimal(1, 'D')
        (1, 'D')
        """
        ...
    


def get_to_timestamp_base(base):
    """
    Return frequency code group used for base of to_timestamp against
    frequency code.

    Example
    -------
    # Return day freq code against longer freq than day
    >>> get_to_timestamp_base(get_freq_code('D')[0])
    6000
    >>> get_to_timestamp_base(get_freq_code('W')[0])
    6000
    >>> get_to_timestamp_base(get_freq_code('M')[0])
    6000

    # Return second freq code against hour between second
    >>> get_to_timestamp_base(get_freq_code('H')[0])
    9000
    >>> get_to_timestamp_base(get_freq_code('S')[0])
    9000
    """
    ...

def get_freq_group(freq):
    """
    Return frequency code group of given frequency str or offset.

    Example
    -------
    >>> get_freq_group('W-MON')
    4000

    >>> get_freq_group('W-FRI')
    4000
    """
    ...

def get_freq(freq):
    """
    Return frequency code of given frequency str.
    If input is not string, return input as it is.

    Example
    -------
    >>> get_freq('A')
    1000

    >>> get_freq('3A')
    1000
    """
    ...

def _get_freq_str(base, mult=...):
    ...

_offset_map = {  }
_offset_to_period_map = { 'WEEKDAY': 'D','EOM': 'M','BM': 'M','BQS': 'Q','QS': 'Q','BQ': 'Q','BA': 'A','AS': 'A','BAS': 'A','MS': 'M','D': 'D','C': 'C','B': 'B','T': 'T','S': 'S','L': 'L','U': 'U','N': 'N','H': 'H','Q': 'Q','A': 'A','W': 'W','M': 'M','Y': 'A','BY': 'A','YS': 'A','BYS': 'A' }
need_suffix = ['QS', 'BQ', 'BQS', 'YS', 'AS', 'BY', 'BA', 'BYS', 'BAS']
_days = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
def get_period_alias(offset_str):
    """ alias to closest period strings BQ->Q etc"""
    ...

_name_to_offset_map = { 'days': Day(1),'hours': Hour(1),'minutes': Minute(1),'seconds': Second(1),'milliseconds': Milli(1),'microseconds': Micro(1),'nanoseconds': Nano(1) }
@deprecate_kwarg(old_arg_name='freqstr', new_arg_name='freq')
def to_offset(freq):
    """
    Return DateOffset object from string or tuple representation
    or datetime.timedelta object

    Parameters
    ----------
    freq : str, tuple, datetime.timedelta, DateOffset or None

    Returns
    -------
    delta : DateOffset
        None if freq is None

    Raises
    ------
    ValueError
        If freq is an invalid frequency

    See Also
    --------
    pandas.DateOffset

    Examples
    --------
    >>> to_offset('5min')
    <5 * Minutes>

    >>> to_offset('1D1H')
    <25 * Hours>

    >>> to_offset(('W', 2))
    <2 * Weeks: weekday=6>

    >>> to_offset((2, 'B'))
    <2 * BusinessDays>

    >>> to_offset(datetime.timedelta(days=1))
    <Day>

    >>> to_offset(Hour())
    <Hour>
    """
    ...

def get_base_alias(freqstr):
    """
    Returns the base frequency alias, e.g., '5D' -> 'D'
    """
    ...

def get_offset(name):
    """
    Return DateOffset object associated with rule name

    Examples
    --------
    get_offset('EOM') --> BMonthEnd(1)
    """
    ...

getOffset = get_offset
def get_standard_freq(freq):
    """
    Return the standardized frequency string
    """
    ...

def infer_freq(index, warn: bool = ...):
    """
    Infer the most likely frequency given the input index. If the frequency is
    uncertain, a warning will be printed.

    Parameters
    ----------
    index : DatetimeIndex or TimedeltaIndex
      if passed a Series will use the values of the series (NOT THE INDEX)
    warn : boolean, default True

    Returns
    -------
    freq : string or None
        None if no discernible frequency
        TypeError if the index is not datetime-like
        ValueError if there are less than three values.
    """
    ...

_ONE_MICRO = long(1000)
_ONE_MILLI = _ONE_MICRO * 1000
_ONE_SECOND = _ONE_MILLI * 1000
_ONE_MINUTE = 60 * _ONE_SECOND
_ONE_HOUR = 60 * _ONE_MINUTE
_ONE_DAY = 24 * _ONE_HOUR
class _FrequencyInferer(object):
    """
    Not sure if I can avoid the state machine here
    """
    def __init__(self, index, warn: bool = ...):
        self.index = ...
        self.values = ...
        self.warn = ...
        self.is_monotonic = ...
    
    @cache_readonly
    def deltas(self):
        ...
    
    @cache_readonly
    def deltas_asi8(self):
        ...
    
    @cache_readonly
    def is_unique(self):
        ...
    
    @cache_readonly
    def is_unique_asi8(self):
        ...
    
    def get_freq(self):
        ...
    
    @cache_readonly
    def day_deltas(self):
        ...
    
    @cache_readonly
    def hour_deltas(self):
        ...
    
    @cache_readonly
    def fields(self):
        ...
    
    @cache_readonly
    def rep_stamp(self):
        ...
    
    def month_position_check(self):
        ...
    
    @cache_readonly
    def mdiffs(self):
        ...
    
    @cache_readonly
    def ydiffs(self):
        ...
    
    def _infer_daily_rule(self):
        ...
    
    def _get_annual_rule(self):
        ...
    
    def _get_quarterly_rule(self):
        ...
    
    def _get_monthly_rule(self):
        ...
    
    def _is_business_daily(self):
        ...
    
    def _get_wom_rule(self):
        ...
    


class _TimedeltaFrequencyInferer(_FrequencyInferer):
    def _infer_daily_rule(self):
        ...
    


def _maybe_add_count(base, count):
    ...

def _maybe_coerce_freq(code):
    """ we might need to coerce a code to a rule_code
    and uppercase it

    Parameters
    ----------
    source : string
        Frequency converting from

    Returns
    -------
    string code
    """
    ...

def is_subperiod(source, target):
    """
    Returns True if downsampling is possible between source and target
    frequencies

    Parameters
    ----------
    source : string
        Frequency converting from
    target : string
        Frequency converting to

    Returns
    -------
    is_subperiod : boolean
    """
    ...

def is_superperiod(source, target):
    """
    Returns True if upsampling is possible between source and target
    frequencies

    Parameters
    ----------
    source : string
        Frequency converting from
    target : string
        Frequency converting to

    Returns
    -------
    is_superperiod : boolean
    """
    ...

_get_rule_month = tslib._get_rule_month
def _is_annual(rule):
    ...

def _quarter_months_conform(source, target):
    ...

def _is_quarterly(rule):
    ...

def _is_monthly(rule):
    ...

def _is_weekly(rule):
    ...

DAYS = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
MONTHS = tslib._MONTHS
_month_numbers = tslib._MONTH_NUMBERS
_month_aliases = tslib._MONTH_ALIASES
_weekday_rule_aliases = dict((k, v) for (k, v) in enumerate(DAYS))
def _is_multiple(us, mult):
    ...

