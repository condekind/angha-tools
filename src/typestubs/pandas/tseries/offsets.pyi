"""
This type stub file was generated by pyright.
"""

from dateutil.relativedelta import weekday
from pandas._libs import tslib
from pandas.util._decorators import cache_readonly
from typing import Any, Optional

__all__ = ['Day', 'BusinessDay', 'BDay', 'CustomBusinessDay', 'CDay', 'CBMonthEnd', 'CBMonthBegin', 'MonthBegin', 'BMonthBegin', 'MonthEnd', 'BMonthEnd', 'SemiMonthEnd', 'SemiMonthBegin', 'BusinessHour', 'CustomBusinessHour', 'YearBegin', 'BYearBegin', 'YearEnd', 'BYearEnd', 'QuarterBegin', 'BQuarterBegin', 'QuarterEnd', 'BQuarterEnd', 'LastWeekOfMonth', 'FY5253Quarter', 'FY5253', 'Week', 'WeekOfMonth', 'Easter', 'Hour', 'Minute', 'Second', 'Milli', 'Micro', 'Nano', 'DateOffset']
def as_timestamp(obj):
    ...

def as_datetime(obj):
    ...

def apply_wraps(func):
    ...

def apply_index_wraps(func):
    ...

def _is_normalized(dt):
    ...

class ApplyTypeError(TypeError):
    ...


class CacheableOffset(object):
    _cacheable = ...


class DateOffset(object):
    """
    Standard kind of date increment used for a date range.

    Works exactly like relativedelta in terms of the keyword args you
    pass in, use of the keyword n is discouraged-- you would be better
    off specifying n in the keywords you use, but regardless it is
    there for you. n is needed for DateOffset subclasses.

    DateOffets work as follows.  Each offset specify a set of dates
    that conform to the DateOffset.  For example, Bday defines this
    set to be the set of dates that are weekdays (M-F).  To test if a
    date is in the set of a DateOffset dateOffset we can use the
    onOffset method: dateOffset.onOffset(date).

    If a date is not on a valid date, the rollback and rollforward
    methods can be used to roll the date to the nearest valid date
    before/after the date.

    DateOffsets can be created to move dates forward a given number of
    valid dates.  For example, Bday(2) can be added to a date to move
    it two business days forward.  If the date does not start on a
    valid date, first it is moved to a valid date.  Thus pseudo code
    is:

    def __add__(date):
      date = rollback(date) # does nothing if date is valid
      return date + <n number of periods>

    When a date offset is created for a negative number of periods,
    the date is first rolled forward.  The pseudo code is:

    def __add__(date):
      date = rollforward(date) # does nothing is date is valid
      return date + <n number of periods>

    Zero presents a problem.  Should it roll forward or back?  We
    arbitrarily have it rollforward:

    date + BDay(0) == BDay.rollforward(date)

    Since 0 is a bit weird, we suggest avoiding its use.
    """
    _cacheable = ...
    _normalize_cache = ...
    _kwds_use_relativedelta = ...
    _use_relativedelta = ...
    _adjust_dst = ...
    _typ = ...
    normalize = ...
    def __init__(self, n=..., normalize: bool = ..., **kwds):
        self.n = ...
        self.normalize = ...
        self.kwds = ...
    
    def _determine_offset(self):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        """
        Vectorized apply of DateOffset to DatetimeIndex,
        raises NotImplentedError for offsets without a
        vectorized implementation

        .. versionadded:: 0.17.0

        Parameters
        ----------
        i : DatetimeIndex

        Returns
        -------
        y : DatetimeIndex
        """
        ...
    
    def isAnchored(self):
        ...
    
    def copy(self):
        ...
    
    def _should_cache(self):
        ...
    
    def _params(self):
        ...
    
    def __repr__(self):
        ...
    
    def _repr_attrs(self):
        ...
    
    @property
    def name(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __hash__(self):
        ...
    
    def __call__(self, other):
        ...
    
    def __add__(self, other):
        ...
    
    def __radd__(self, other):
        ...
    
    def __sub__(self, other):
        ...
    
    def __rsub__(self, other):
        ...
    
    def __mul__(self, someInt):
        ...
    
    def __rmul__(self, someInt):
        ...
    
    def __neg__(self):
        ...
    
    def rollback(self, dt):
        """Roll provided date backward to next offset only if not on offset"""
        ...
    
    def rollforward(self, dt):
        """Roll provided date forward to next offset only if not on offset"""
        ...
    
    def onOffset(self, dt):
        ...
    
    def _beg_apply_index(self, i, freq):
        """Offsets index to beginning of Period frequency"""
        ...
    
    def _end_apply_index(self, i, freq):
        """Offsets index to end of Period frequency"""
        ...
    
    @property
    def _prefix(self):
        ...
    
    @property
    def rule_code(self):
        ...
    
    @property
    def freqstr(self):
        ...
    
    def _offset_str(self):
        ...
    
    @property
    def nanos(self):
        ...
    


class SingleConstructorOffset(DateOffset):
    @classmethod
    def _from_name(cls, suffix: Optional[Any] = ...):
        ...
    


class BusinessMixin(object):
    """ mixin to business types to provide related functions """
    @property
    def offset(self):
        """Alias for self._offset"""
        ...
    
    def _repr_attrs(self):
        ...
    
    def __getstate__(self):
        """Return a pickleable state"""
        ...
    
    def __setstate__(self, state):
        """Reconstruct an instance from a pickled state"""
        self.__dict__ = ...
    


class BusinessDay(BusinessMixin, SingleConstructorOffset):
    """
    DateOffset subclass representing possibly n business days
    """
    _prefix = ...
    _adjust_dst = ...
    def __init__(self, n=..., normalize: bool = ..., offset=...):
        self.n = ...
        self.normalize = ...
        self.kwds = ...
    
    def _offset_str(self):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    


class BusinessHourMixin(BusinessMixin):
    def __init__(self, start=..., end=..., offset=...):
        self.start = ...
        self.end = ...
        self.kwds = ...
    
    def _validate_time(self, t_input):
        ...
    
    def _get_daytime_flag(self):
        ...
    
    def _next_opening_time(self, other):
        """
        If n is positive, return tomorrow's business day opening time.
        Otherwise yesterday's business day's opening time.

        Opening time always locates on BusinessDay.
        Otherwise, closing time may not if business hour extends over midnight.
        """
        ...
    
    def _prev_opening_time(self, other):
        """
        If n is positive, return yesterday's business day opening time.
        Otherwise yesterday business day's opening time.
        """
        ...
    
    def _get_business_hours_by_sec(self):
        """
        Return business hours in a day by seconds.
        """
        ...
    
    @apply_wraps
    def rollback(self, dt):
        """Roll provided date backward to next offset only if not on offset"""
        ...
    
    @apply_wraps
    def rollforward(self, dt):
        """Roll provided date forward to next offset only if not on offset"""
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    def onOffset(self, dt):
        ...
    
    def _onOffset(self, dt, businesshours):
        """
        Slight speedups using calculated values
        """
        ...
    
    def _repr_attrs(self):
        ...
    


class BusinessHour(BusinessHourMixin, SingleConstructorOffset):
    """
    DateOffset subclass representing possibly n business days

    .. versionadded: 0.16.1

    """
    _prefix = ...
    _anchor = ...
    def __init__(self, n=..., normalize: bool = ..., start=..., end=..., offset=...):
        self.n = ...
        self.normalize = ...
    
    @cache_readonly
    def next_bday(self):
        ...
    


class CustomBusinessDay(BusinessDay):
    """
    DateOffset subclass representing possibly n custom business days,
    excluding holidays

    Parameters
    ----------
    n : int, default 1
    offset : timedelta, default timedelta(0)
    normalize : bool, default False
        Normalize start/end dates to midnight before generating date range
    weekmask : str, Default 'Mon Tue Wed Thu Fri'
        weekmask of valid business days, passed to ``numpy.busdaycalendar``
    holidays : list
        list/array of dates to exclude from the set of valid business days,
        passed to ``numpy.busdaycalendar``
    calendar : pd.HolidayCalendar or np.busdaycalendar
    """
    _cacheable = ...
    _prefix = ...
    def __init__(self, n=..., normalize: bool = ..., weekmask=..., holidays: Optional[Any] = ..., calendar: Optional[Any] = ..., offset=...):
        self.n = ...
        self.normalize = ...
        self.kwds = ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    


class CustomBusinessHour(BusinessHourMixin, SingleConstructorOffset):
    """
    DateOffset subclass representing possibly n custom business days

    .. versionadded: 0.18.1

    """
    _prefix = ...
    _anchor = ...
    def __init__(self, n=..., normalize: bool = ..., weekmask=..., holidays: Optional[Any] = ..., calendar: Optional[Any] = ..., start=..., end=..., offset=...):
        self.n = ...
        self.normalize = ...
    
    @cache_readonly
    def next_bday(self):
        ...
    


class MonthOffset(SingleConstructorOffset):
    _adjust_dst = ...
    @property
    def name(self):
        ...
    


class MonthEnd(MonthOffset):
    """DateOffset of one month end"""
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    
    _prefix = ...


class MonthBegin(MonthOffset):
    """DateOffset of one month at beginning"""
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    
    _prefix = ...


class SemiMonthOffset(DateOffset):
    _adjust_dst = ...
    _default_day_of_month = ...
    _min_day_of_month = ...
    def __init__(self, n=..., normalize: bool = ..., day_of_month: Optional[Any] = ...):
        self.n = ...
        self.normalize = ...
        self.kwds = ...
    
    @classmethod
    def _from_name(cls, suffix: Optional[Any] = ...):
        ...
    
    @property
    def rule_code(self):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    def _apply(self, n, other):
        """Handle specific apply logic for child classes"""
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def _get_roll(self, i, before_day_of_month, after_day_of_month):
        """Return an array with the correct n for each date in i.

        The roll array is based on the fact that i gets rolled back to
        the first day of the month.
        """
        ...
    
    def _apply_index_days(self, i, roll):
        """Apply the correct day for each date in i"""
        ...
    


class SemiMonthEnd(SemiMonthOffset):
    """
    Two DateOffset's per month repeating on the last
    day of the month and day_of_month.

    .. versionadded:: 0.19.0

    Parameters
    ----------
    n: int
    normalize : bool, default False
    day_of_month: int, {1, 3,...,27}, default 15
    """
    _prefix = ...
    _min_day_of_month = ...
    def onOffset(self, dt):
        ...
    
    def _apply(self, n, other):
        ...
    
    def _get_roll(self, i, before_day_of_month, after_day_of_month):
        ...
    
    def _apply_index_days(self, i, roll):
        ...
    


class SemiMonthBegin(SemiMonthOffset):
    """
    Two DateOffset's per month repeating on the first
    day of the month and day_of_month.

    .. versionadded:: 0.19.0

    Parameters
    ----------
    n: int
    normalize : bool, default False
    day_of_month: int, {2, 3,...,27}, default 15
    """
    _prefix = ...
    def onOffset(self, dt):
        ...
    
    def _apply(self, n, other):
        ...
    
    def _get_roll(self, i, before_day_of_month, after_day_of_month):
        ...
    
    def _apply_index_days(self, i, roll):
        ...
    


class BusinessMonthEnd(MonthOffset):
    """DateOffset increments between business EOM dates"""
    @apply_wraps
    def apply(self, other):
        ...
    
    _prefix = ...


class BusinessMonthBegin(MonthOffset):
    """DateOffset of one business month at beginning"""
    @apply_wraps
    def apply(self, other):
        ...
    
    def onOffset(self, dt):
        ...
    
    _prefix = ...


class CustomBusinessMonthEnd(BusinessMixin, MonthOffset):
    """
    DateOffset subclass representing one custom business month, incrementing
    between end of month dates

    Parameters
    ----------
    n : int, default 1
    offset : timedelta, default timedelta(0)
    normalize : bool, default False
        Normalize start/end dates to midnight before generating date range
    weekmask : str, Default 'Mon Tue Wed Thu Fri'
        weekmask of valid business days, passed to ``numpy.busdaycalendar``
    holidays : list
        list/array of dates to exclude from the set of valid business days,
        passed to ``numpy.busdaycalendar``
    calendar : pd.HolidayCalendar or np.busdaycalendar
    """
    _cacheable = ...
    _prefix = ...
    def __init__(self, n=..., normalize: bool = ..., weekmask=..., holidays: Optional[Any] = ..., calendar: Optional[Any] = ..., offset=...):
        self.n = ...
        self.normalize = ...
        self.kwds = ...
    
    @cache_readonly
    def cbday(self):
        ...
    
    @cache_readonly
    def m_offset(self):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    


class CustomBusinessMonthBegin(BusinessMixin, MonthOffset):
    """
    DateOffset subclass representing one custom business month, incrementing
    between beginning of month dates

    Parameters
    ----------
    n : int, default 1
    offset : timedelta, default timedelta(0)
    normalize : bool, default False
        Normalize start/end dates to midnight before generating date range
    weekmask : str, Default 'Mon Tue Wed Thu Fri'
        weekmask of valid business days, passed to ``numpy.busdaycalendar``
    holidays : list
        list/array of dates to exclude from the set of valid business days,
        passed to ``numpy.busdaycalendar``
    calendar : pd.HolidayCalendar or np.busdaycalendar
    """
    _cacheable = ...
    _prefix = ...
    def __init__(self, n=..., normalize: bool = ..., weekmask=..., holidays: Optional[Any] = ..., calendar: Optional[Any] = ..., offset=...):
        self.n = ...
        self.normalize = ...
        self.kwds = ...
    
    @cache_readonly
    def cbday(self):
        ...
    
    @cache_readonly
    def m_offset(self):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    


class Week(DateOffset):
    """
    Weekly offset

    Parameters
    ----------
    weekday : int, default None
        Always generate specific day of week. 0 for Monday
    """
    _adjust_dst = ...
    _inc = ...
    def __init__(self, n=..., normalize: bool = ..., weekday: Optional[Any] = ...):
        self.n = ...
        self.normalize = ...
        self.weekday = ...
        self.kwds = ...
    
    def isAnchored(self):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    
    _prefix = ...
    @property
    def rule_code(self):
        ...
    
    @classmethod
    def _from_name(cls, suffix: Optional[Any] = ...):
        ...
    


class WeekDay(object):
    MON = ...
    TUE = ...
    WED = ...
    THU = ...
    FRI = ...
    SAT = ...
    SUN = ...


_int_to_weekday = { WeekDay.MON: 'MON',WeekDay.TUE: 'TUE',WeekDay.WED: 'WED',WeekDay.THU: 'THU',WeekDay.FRI: 'FRI',WeekDay.SAT: 'SAT',WeekDay.SUN: 'SUN' }
_weekday_to_int = dict((v, k) for (k, v) in _int_to_weekday.items())
class WeekOfMonth(DateOffset):
    """
    Describes monthly dates like "the Tuesday of the 2nd week of each month"

    Parameters
    ----------
    n : int
    week : {0, 1, 2, 3, ...}, default None
        0 is 1st week of month, 1 2nd week, etc.
    weekday : {0, 1, ..., 6}, default None
        0: Mondays
        1: Tuesdays
        2: Wednesdays
        3: Thursdays
        4: Fridays
        5: Saturdays
        6: Sundays
    """
    _adjust_dst = ...
    def __init__(self, n=..., normalize: bool = ..., week: Optional[Any] = ..., weekday: Optional[Any] = ...):
        self.n = ...
        self.normalize = ...
        self.weekday = ...
        self.week = ...
        self.kwds = ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    def getOffsetOfMonth(self, dt):
        ...
    
    def onOffset(self, dt):
        ...
    
    @property
    def rule_code(self):
        ...
    
    _prefix = ...
    @classmethod
    def _from_name(cls, suffix: Optional[Any] = ...):
        ...
    


class LastWeekOfMonth(DateOffset):
    """
    Describes monthly dates in last week of month like "the last Tuesday of
    each month"

    Parameters
    ----------
    n : int, default 1
    weekday : {0, 1, ..., 6}, default None
        0: Mondays
        1: Tuesdays
        2: Wednesdays
        3: Thursdays
        4: Fridays
        5: Saturdays
        6: Sundays

    """
    def __init__(self, n=..., normalize: bool = ..., weekday: Optional[Any] = ...):
        self.n = ...
        self.normalize = ...
        self.weekday = ...
        self.kwds = ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    def getOffsetOfMonth(self, dt):
        ...
    
    def onOffset(self, dt):
        ...
    
    @property
    def rule_code(self):
        ...
    
    _prefix = ...
    @classmethod
    def _from_name(cls, suffix: Optional[Any] = ...):
        ...
    


class QuarterOffset(DateOffset):
    """Quarter representation - doesn't call super"""
    _default_startingMonth = ...
    _from_name_startingMonth = ...
    _adjust_dst = ...
    def __init__(self, n=..., normalize: bool = ..., startingMonth: Optional[Any] = ...):
        self.n = ...
        self.normalize = ...
        self.startingMonth = ...
        self.kwds = ...
    
    def isAnchored(self):
        ...
    
    @classmethod
    def _from_name(cls, suffix: Optional[Any] = ...):
        ...
    
    @property
    def rule_code(self):
        ...
    


class BQuarterEnd(QuarterOffset):
    """DateOffset increments between business Quarter dates
    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
    """
    _outputName = ...
    _default_startingMonth = ...
    _from_name_startingMonth = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    
    def onOffset(self, dt):
        ...
    


_int_to_month = tslib._MONTH_ALIASES
_month_to_int = dict((v, k) for (k, v) in _int_to_month.items())
class BQuarterBegin(QuarterOffset):
    _outputName = ...
    _default_startingMonth = ...
    _from_name_startingMonth = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    


class QuarterEnd(QuarterOffset):
    """DateOffset increments between business Quarter dates
    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
    startingMonth = 3 corresponds to dates like 3/31/2007, 6/30/2007, ...
    """
    _outputName = ...
    _default_startingMonth = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    


class QuarterBegin(QuarterOffset):
    _outputName = ...
    _default_startingMonth = ...
    _from_name_startingMonth = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    


class YearOffset(DateOffset):
    """DateOffset that just needs a month"""
    _adjust_dst = ...
    def __init__(self, n=..., normalize: bool = ..., month: Optional[Any] = ...):
        self.month = ...
    
    @classmethod
    def _from_name(cls, suffix: Optional[Any] = ...):
        ...
    
    @property
    def rule_code(self):
        ...
    


class BYearEnd(YearOffset):
    """DateOffset increments between business EOM dates"""
    _outputName = ...
    _default_month = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    


class BYearBegin(YearOffset):
    """DateOffset increments between business year begin dates"""
    _outputName = ...
    _default_month = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    


class YearEnd(YearOffset):
    """DateOffset increments between calendar year ends"""
    _default_month = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    


class YearBegin(YearOffset):
    """DateOffset increments between calendar year begin dates"""
    _default_month = ...
    _prefix = ...
    @apply_wraps
    def apply(self, other):
        ...
    
    @apply_index_wraps
    def apply_index(self, i):
        ...
    
    def onOffset(self, dt):
        ...
    


class FY5253(DateOffset):
    """
    Describes 52-53 week fiscal year. This is also known as a 4-4-5 calendar.

    It is used by companies that desire that their
    fiscal year always end on the same day of the week.

    It is a method of managing accounting periods.
    It is a common calendar structure for some industries,
    such as retail, manufacturing and parking industry.

    For more information see:
    http://en.wikipedia.org/wiki/4%E2%80%934%E2%80%935_calendar


    The year may either:
    - end on the last X day of the Y month.
    - end on the last X day closest to the last day of the Y month.

    X is a specific day of the week.
    Y is a certain month of the year

    Parameters
    ----------
    n : int
    weekday : {0, 1, ..., 6}
        0: Mondays
        1: Tuesdays
        2: Wednesdays
        3: Thursdays
        4: Fridays
        5: Saturdays
        6: Sundays
    startingMonth : The month in which fiscal years end. {1, 2, ... 12}
    variation : str
        {"nearest", "last"} for "LastOfMonth" or "NearestEndMonth"
    """
    _prefix = ...
    _suffix_prefix_last = ...
    _suffix_prefix_nearest = ...
    _adjust_dst = ...
    def __init__(self, n=..., normalize: bool = ..., weekday=..., startingMonth=..., variation=...):
        self.n = ...
        self.normalize = ...
        self.startingMonth = ...
        self.weekday = ...
        self.variation = ...
        self.kwds = ...
    
    @cache_readonly
    def _relativedelta_forward(self):
        ...
    
    @cache_readonly
    def _relativedelta_backward(self):
        ...
    
    @cache_readonly
    def _offset_lwom(self):
        ...
    
    def isAnchored(self):
        ...
    
    def onOffset(self, dt):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    def get_year_end(self, dt):
        ...
    
    def get_target_month_end(self, dt):
        ...
    
    def _get_year_end_nearest(self, dt):
        ...
    
    def _get_year_end_last(self, dt):
        ...
    
    @property
    def rule_code(self):
        ...
    
    def _get_prefix(self):
        ...
    
    def _get_suffix_prefix(self):
        ...
    
    def get_rule_code_suffix(self):
        ...
    
    @classmethod
    def _parse_suffix(cls, varion_code, startingMonth_code, weekday_code):
        ...
    
    @classmethod
    def _from_name(cls, *args):
        ...
    


class FY5253Quarter(DateOffset):
    """
    DateOffset increments between business quarter dates
    for 52-53 week fiscal year (also known as a 4-4-5 calendar).

    It is used by companies that desire that their
    fiscal year always end on the same day of the week.

    It is a method of managing accounting periods.
    It is a common calendar structure for some industries,
    such as retail, manufacturing and parking industry.

    For more information see:
    http://en.wikipedia.org/wiki/4%E2%80%934%E2%80%935_calendar

    The year may either:
    - end on the last X day of the Y month.
    - end on the last X day closest to the last day of the Y month.

    X is a specific day of the week.
    Y is a certain month of the year

    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...

    Parameters
    ----------
    n : int
    weekday : {0, 1, ..., 6}
        0: Mondays
        1: Tuesdays
        2: Wednesdays
        3: Thursdays
        4: Fridays
        5: Saturdays
        6: Sundays
    startingMonth : The month in which fiscal years end. {1, 2, ... 12}
    qtr_with_extra_week : The quarter number that has the leap
        or 14 week when needed. {1,2,3,4}
    variation : str
        {"nearest", "last"} for "LastOfMonth" or "NearestEndMonth"
    """
    _prefix = ...
    _adjust_dst = ...
    def __init__(self, n=..., normalize: bool = ..., weekday=..., startingMonth=..., qtr_with_extra_week=..., variation=...):
        self.n = ...
        self.normalize = ...
        self.weekday = ...
        self.startingMonth = ...
        self.qtr_with_extra_week = ...
        self.variation = ...
        self.kwds = ...
    
    @cache_readonly
    def _offset(self):
        ...
    
    def isAnchored(self):
        ...
    
    @apply_wraps
    def apply(self, other):
        ...
    
    def get_weeks(self, dt):
        ...
    
    def year_has_extra_week(self, dt):
        ...
    
    def onOffset(self, dt):
        ...
    
    @property
    def rule_code(self):
        ...
    
    @classmethod
    def _from_name(cls, *args):
        ...
    


class Easter(DateOffset):
    """
    DateOffset for the Easter holiday using
    logic defined in dateutil.  Right now uses
    the revised method which is valid in years
    1583-4099.
    """
    _adjust_dst = ...
    @apply_wraps
    def apply(self, other):
        ...
    
    def onOffset(self, dt):
        ...
    


def _tick_comp(op):
    ...

class Tick(SingleConstructorOffset):
    _inc = ...
    __gt__ = ...
    __ge__ = ...
    __lt__ = ...
    __le__ = ...
    __eq__ = ...
    __ne__ = ...
    def __add__(self, other):
        ...
    
    def __eq__(self, other):
        ...
    
    def __hash__(self):
        ...
    
    def __ne__(self, other):
        ...
    
    @property
    def delta(self):
        ...
    
    @property
    def nanos(self):
        ...
    
    def apply(self, other):
        ...
    
    _prefix = ...
    def isAnchored(self):
        ...
    


def _delta_to_tick(delta):
    ...

_delta_to_nanoseconds = tslib._delta_to_nanoseconds
class Day(Tick):
    _inc = ...
    _prefix = ...


class Hour(Tick):
    _inc = ...
    _prefix = ...


class Minute(Tick):
    _inc = ...
    _prefix = ...


class Second(Tick):
    _inc = ...
    _prefix = ...


class Milli(Tick):
    _inc = ...
    _prefix = ...


class Micro(Tick):
    _inc = ...
    _prefix = ...


class Nano(Tick):
    _inc = ...
    _prefix = ...


BDay = BusinessDay
BMonthEnd = BusinessMonthEnd
BMonthBegin = BusinessMonthBegin
CBMonthEnd = CustomBusinessMonthEnd
CBMonthBegin = CustomBusinessMonthBegin
CDay = CustomBusinessDay
def _get_calendar(weekmask, holidays, calendar):
    """Generate busdaycalendar"""
    ...

def _to_dt64(dt, dtype=...):
    ...

def _get_firstbday(wkday):
    """
    wkday is the result of monthrange(year, month)

    If it's a saturday or sunday, increment first business day to reflect this
    """
    ...

def generate_range(start: Optional[Any] = ..., end: Optional[Any] = ..., periods: Optional[Any] = ..., offset=..., time_rule: Optional[Any] = ...):
    """
    Generates a sequence of dates corresponding to the specified time
    offset. Similar to dateutil.rrule except uses pandas DateOffset
    objects to represent time increments

    Parameters
    ----------
    start : datetime (default None)
    end : datetime (default None)
    periods : int, optional
    time_rule : (legacy) name of DateOffset object to be used, optional
        Corresponds with names expected by tseries.frequencies.get_offset

    Notes
    -----
    * This method is faster for generating weekdays than dateutil.rrule
    * At least two of (start, end, periods) must be specified.
    * If both start and end are specified, the returned dates will
    satisfy start <= date <= end.
    * If both time_rule and offset are specified, time_rule supersedes offset.

    Returns
    -------
    dates : generator object

    """
    ...

prefix_mapping = dict((offset._prefix, offset) for offset in [YearBegin, YearEnd, BYearBegin, BYearEnd, BusinessDay, BusinessMonthBegin, BusinessMonthEnd, BQuarterEnd, BQuarterBegin, BusinessHour, CustomBusinessDay, CustomBusinessMonthEnd, CustomBusinessMonthBegin, CustomBusinessHour, MonthEnd, MonthBegin, Nano, SemiMonthEnd, SemiMonthBegin, Week, Second, Minute, Micro, QuarterEnd, QuarterBegin, Milli, Hour, Day, WeekOfMonth, FY5253, FY5253Quarter])
