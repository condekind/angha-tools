"""
This type stub file was generated by pyright.
"""

import pandas._libs.json as json
from pandas.io.common import BaseIterator
from typing import Any, Optional

loads = json.loads
dumps = json.dumps
TABLE_SCHEMA_VERSION = '0.20.0'
def to_json(path_or_buf, obj, orient: Optional[Any] = ..., date_format=..., double_precision=..., force_ascii: bool = ..., date_unit=..., default_handler: Optional[Any] = ..., lines: bool = ..., compression: Optional[Any] = ...):
    ...

class Writer(object):
    def __init__(self, obj, orient, date_format, double_precision, ensure_ascii, date_unit, default_handler: Optional[Any] = ...):
        self.obj = ...
        self.orient = ...
        self.date_format = ...
        self.double_precision = ...
        self.ensure_ascii = ...
        self.date_unit = ...
        self.default_handler = ...
        self.is_copy = ...
    
    def _format_axes(self):
        ...
    
    def write(self):
        ...
    


class SeriesWriter(Writer):
    _default_orient = ...
    def _format_axes(self):
        ...
    


class FrameWriter(Writer):
    _default_orient = ...
    def _format_axes(self):
        """ try to axes if they are datelike """
        ...
    


class JSONTableWriter(FrameWriter):
    _default_orient = ...
    def __init__(self, obj, orient, date_format, double_precision, ensure_ascii, date_unit, default_handler: Optional[Any] = ...):
        """
        Adds a `schema` attribut with the Table Schema, resets
        the index (can't do in caller, because the schema inference needs
        to know what the index is, forces orient to records, and forces
        date_format to 'iso'.
        """
        self.schema = ...
        self.obj = ...
        self.date_format = ...
        self.orient = ...
    
    def write(self):
        ...
    


def read_json(path_or_buf: Optional[Any] = ..., orient: Optional[Any] = ..., typ=..., dtype: bool = ..., convert_axes: bool = ..., convert_dates: bool = ..., keep_default_dates: bool = ..., numpy: bool = ..., precise_float: bool = ..., date_unit: Optional[Any] = ..., encoding: Optional[Any] = ..., lines: bool = ..., chunksize: Optional[Any] = ..., compression=...):
    """
    Convert a JSON string to pandas object

    Parameters
    ----------
    path_or_buf : a valid JSON string or file-like, default: None
        The string could be a URL. Valid URL schemes include http, ftp, s3, and
        file. For file URLs, a host is expected. For instance, a local file
        could be ``file://localhost/path/to/table.json``

    orient : string,
        Indication of expected JSON string format.
        Compatible JSON strings can be produced by ``to_json()`` with a
        corresponding orient value.
        The set of possible orients is:

        - ``'split'`` : dict like
          ``{index -> [index], columns -> [columns], data -> [values]}``
        - ``'records'`` : list like
          ``[{column -> value}, ... , {column -> value}]``
        - ``'index'`` : dict like ``{index -> {column -> value}}``
        - ``'columns'`` : dict like ``{column -> {index -> value}}``
        - ``'values'`` : just the values array

        The allowed and default values depend on the value
        of the `typ` parameter.

        * when ``typ == 'series'``,

          - allowed orients are ``{'split','records','index'}``
          - default is ``'index'``
          - The Series index must be unique for orient ``'index'``.

        * when ``typ == 'frame'``,

          - allowed orients are ``{'split','records','index',
            'columns','values'}``
          - default is ``'columns'``
          - The DataFrame index must be unique for orients ``'index'`` and
            ``'columns'``.
          - The DataFrame columns must be unique for orients ``'index'``,
            ``'columns'``, and ``'records'``.

    typ : type of object to recover (series or frame), default 'frame'
    dtype : boolean or dict, default True
        If True, infer dtypes, if a dict of column to dtype, then use those,
        if False, then don't infer dtypes at all, applies only to the data.
    convert_axes : boolean, default True
        Try to convert the axes to the proper dtypes.
    convert_dates : boolean, default True
        List of columns to parse for dates; If True, then try to parse
        datelike columns default is True; a column label is datelike if

        * it ends with ``'_at'``,

        * it ends with ``'_time'``,

        * it begins with ``'timestamp'``,

        * it is ``'modified'``, or

        * it is ``'date'``

    keep_default_dates : boolean, default True
        If parsing dates, then parse the default datelike columns
    numpy : boolean, default False
        Direct decoding to numpy arrays. Supports numeric data only, but
        non-numeric column and index labels are supported. Note also that the
        JSON ordering MUST be the same for each term if numpy=True.
    precise_float : boolean, default False
        Set to enable usage of higher precision (strtod) function when
        decoding string to double values. Default (False) is to use fast but
        less precise builtin functionality
    date_unit : string, default None
        The timestamp unit to detect if converting dates. The default behaviour
        is to try and detect the correct precision, but if this is not desired
        then pass one of 's', 'ms', 'us' or 'ns' to force parsing only seconds,
        milliseconds, microseconds or nanoseconds respectively.
    lines : boolean, default False
        Read the file as a json object per line.

        .. versionadded:: 0.19.0

    encoding : str, default is 'utf-8'
        The encoding to use to decode py3 bytes.

        .. versionadded:: 0.19.0

    chunksize: integer, default None
        Return JsonReader object for iteration.
        See the `line-delimted json docs
        <http://pandas.pydata.org/pandas-docs/stable/io.html#io-jsonl>`_
        for more information on ``chunksize``.
        This can only be passed if `lines=True`.
        If this is None, the file will be read into memory all at once.

        .. versionadded:: 0.21.0

    compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'
        For on-the-fly decompression of on-disk data. If 'infer', then use
        gzip, bz2, zip or xz if path_or_buf is a string ending in
        '.gz', '.bz2', '.zip', or 'xz', respectively, and no decompression
        otherwise. If using 'zip', the ZIP file must contain only one data
        file to be read in. Set to None for no decompression.

        .. versionadded:: 0.21.0

    Returns
    -------
    result : Series or DataFrame, depending on the value of `typ`.

    See Also
    --------
    DataFrame.to_json

    Examples
    --------

    >>> df = pd.DataFrame([['a', 'b'], ['c', 'd']],
    ...                   index=['row 1', 'row 2'],
    ...                   columns=['col 1', 'col 2'])

    Encoding/decoding a Dataframe using ``'split'`` formatted JSON:

    >>> df.to_json(orient='split')
    '{"columns":["col 1","col 2"],
      "index":["row 1","row 2"],
      "data":[["a","b"],["c","d"]]}'
    >>> pd.read_json(_, orient='split')
          col 1 col 2
    row 1     a     b
    row 2     c     d

    Encoding/decoding a Dataframe using ``'index'`` formatted JSON:

    >>> df.to_json(orient='index')
    '{"row 1":{"col 1":"a","col 2":"b"},"row 2":{"col 1":"c","col 2":"d"}}'
    >>> pd.read_json(_, orient='index')
          col 1 col 2
    row 1     a     b
    row 2     c     d

    Encoding/decoding a Dataframe using ``'records'`` formatted JSON.
    Note that index labels are not preserved with this encoding.

    >>> df.to_json(orient='records')
    '[{"col 1":"a","col 2":"b"},{"col 1":"c","col 2":"d"}]'
    >>> pd.read_json(_, orient='records')
      col 1 col 2
    0     a     b
    1     c     d

    Encoding with Table Schema

    >>> df.to_json(orient='table')
    '{"schema": {"fields": [{"name": "index", "type": "string"},
                            {"name": "col 1", "type": "string"},
                            {"name": "col 2", "type": "string"}],
                    "primaryKey": "index",
                    "pandas_version": "0.20.0"},
        "data": [{"index": "row 1", "col 1": "a", "col 2": "b"},
                {"index": "row 2", "col 1": "c", "col 2": "d"}]}'
    """
    ...

class JsonReader(BaseIterator):
    """
    JsonReader provides an interface for reading in a JSON file.

    If initialized with ``lines=True`` and ``chunksize``, can be iterated over
    ``chunksize`` lines at a time. Otherwise, calling ``read`` reads in the
    whole document.
    """
    def __init__(self, filepath_or_buffer, orient, typ, dtype, convert_axes, convert_dates, keep_default_dates, numpy, precise_float, date_unit, encoding, lines, chunksize, compression):
        self.path_or_buf = ...
        self.orient = ...
        self.typ = ...
        self.dtype = ...
        self.convert_axes = ...
        self.convert_dates = ...
        self.keep_default_dates = ...
        self.numpy = ...
        self.precise_float = ...
        self.date_unit = ...
        self.encoding = ...
        self.compression = ...
        self.lines = ...
        self.chunksize = ...
        self.nrows_seen = ...
        self.should_close = ...
        self.data = ...
    
    def _preprocess_data(self, data):
        """
        At this point, the data either has a `read` attribute (e.g. a file
        object or a StringIO) or is a string that is a JSON document.

        If self.chunksize, we prepare the data for the `__next__` method.
        Otherwise, we read it into memory for the `read` method.
        """
        ...
    
    def _get_data_from_filepath(self, filepath_or_buffer):
        """
        read_json accepts three input types:
            1. filepath (string-like)
            2. file-like object (e.g. open file object, StringIO)
            3. JSON string

        This method turns (1) into (2) to simplify the rest of the processing.
        It returns input types (2) and (3) unchanged.
        """
        ...
    
    def _combine_lines(self, lines):
        """Combines a list of JSON objects into one JSON object"""
        ...
    
    def read(self):
        """Read the whole JSON input into a pandas object"""
        ...
    
    def _get_object_parser(self, json):
        """parses a json document into a pandas object"""
        ...
    
    def close(self):
        """
        If we opened a  stream earlier, in _get_data_from_filepath, we should
        close it. If an open stream or file was passed, we leave it open.
        """
        ...
    
    def __next__(self):
        ...
    


class Parser(object):
    _STAMP_UNITS = ...
    _MIN_STAMPS = ...
    def __init__(self, json, orient, dtype: bool = ..., convert_axes: bool = ..., convert_dates: bool = ..., keep_default_dates: bool = ..., numpy: bool = ..., precise_float: bool = ..., date_unit: Optional[Any] = ...):
        self.json = ...
        self.orient = ...
        self.dtype = ...
        self.numpy = ...
        self.precise_float = ...
        self.convert_axes = ...
        self.convert_dates = ...
        self.date_unit = ...
        self.keep_default_dates = ...
        self.obj = ...
    
    def check_keys_split(self, decoded):
        "checks that dict has only the appropriate keys for orient='split'"
        ...
    
    def parse(self):
        ...
    
    def _convert_axes(self):
        """ try to convert axes """
        ...
    
    def _try_convert_types(self):
        ...
    
    def _try_convert_data(self, name, data, use_dtypes: bool = ..., convert_dates: bool = ...):
        """ try to parse a ndarray like into a column by inferring dtype """
        ...
    
    def _try_convert_to_date(self, data):
        """ try to parse a ndarray like into a date column
            try to coerce object in epoch/iso formats and
            integer/float in epcoh formats, return a boolean if parsing
            was successful """
        ...
    
    def _try_convert_dates(self):
        ...
    


class SeriesParser(Parser):
    _default_orient = ...
    _split_keys = ...
    def _parse_no_numpy(self):
        ...
    
    def _parse_numpy(self):
        ...
    
    def _try_convert_types(self):
        ...
    


class FrameParser(Parser):
    _default_orient = ...
    _split_keys = ...
    def _parse_numpy(self):
        ...
    
    def _parse_no_numpy(self):
        ...
    
    def _process_converter(self, f, filt: Optional[Any] = ...):
        """ take a conversion function and possibly recreate the frame """
        ...
    
    def _try_convert_types(self):
        ...
    
    def _try_convert_dates(self):
        ...
    


