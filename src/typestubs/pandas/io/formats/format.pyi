"""
This type stub file was generated by pyright.
"""

from pandas.io.formats.printing import justify
from typing import Any, Optional

"""
Internal module for formatting output data in csv, html,
and latex files. This module also applies to display formatting.
"""
common_docstring = """
    Parameters
    ----------
    buf : StringIO-like, optional
        buffer to write to
    columns : sequence, optional
        the subset of columns to write; default None writes all columns
    col_space : int, optional
        the minimum width of each column
    header : bool, optional
        %(header)s
    index : bool, optional
        whether to print index (row) labels, default True
    na_rep : string, optional
        string representation of NAN to use, default 'NaN'
    formatters : list or dict of one-parameter functions, optional
        formatter functions to apply to columns' elements by position or name,
        default None. The result of each function must be a unicode string.
        List must be of length equal to the number of columns.
    float_format : one-parameter function, optional
        formatter function to apply to columns' elements if they are floats,
        default None. The result of this function must be a unicode string.
    sparsify : bool, optional
        Set to False for a DataFrame with a hierarchical index to print every
        multiindex key at each row, default True
    index_names : bool, optional
        Prints the names of the indexes, default True
    line_width : int, optional
        Width to wrap a line in characters, default no wrap"""
_VALID_JUSTIFY_PARAMETERS = ("left", "right", "center", "justify", "justify-all", "start", "end", "inherit", "match-parent", "initial", "unset")
justify_docstring = """
    justify : {'left', 'right', 'center', 'justify',
               'justify-all', 'start', 'end', 'inherit',
               'match-parent', 'initial', 'unset'}, default None
        How to justify the column labels. If None uses the option from
        the print configuration (controlled by set_option), 'right' out
        of the box."""
return_docstring = """

    Returns
    -------
    formatted : string (or unicode, depending on data and options)"""
docstring_to_string = common_docstring + justify_docstring + return_docstring
class CategoricalFormatter(object):
    def __init__(self, categorical, buf: Optional[Any] = ..., length: bool = ..., na_rep=..., footer: bool = ...):
        self.categorical = ...
        self.buf = ...
        self.na_rep = ...
        self.length = ...
        self.footer = ...
    
    def _get_footer(self):
        ...
    
    def _get_formatted_values(self):
        ...
    
    def to_string(self):
        ...
    


class SeriesFormatter(object):
    def __init__(self, series, buf: Optional[Any] = ..., length: bool = ..., header: bool = ..., index: bool = ..., na_rep=..., name: bool = ..., float_format: Optional[Any] = ..., dtype: bool = ..., max_rows: Optional[Any] = ...):
        self.series = ...
        self.buf = ...
        self.name = ...
        self.na_rep = ...
        self.header = ...
        self.length = ...
        self.index = ...
        self.max_rows = ...
        self.float_format = ...
        self.dtype = ...
        self.adj = ...
    
    def _chk_truncate(self):
        self.tr_series = ...
        self.truncate_v = ...
    
    def _get_footer(self):
        ...
    
    def _get_formatted_index(self):
        ...
    
    def _get_formatted_values(self):
        ...
    
    def to_string(self):
        ...
    


class TextAdjustment(object):
    def __init__(self):
        self.encoding = ...
    
    def len(self, text):
        ...
    
    def justify(self, texts, max_len, mode=...):
        ...
    
    def adjoin(self, space, *lists, **kwargs):
        ...
    


class EastAsianTextAdjustment(TextAdjustment):
    def __init__(self):
        ...
    
    def len(self, text):
        ...
    
    def justify(self, texts, max_len, mode=...):
        ...
    


def _get_adjustment():
    ...

class TableFormatter(object):
    is_truncated = ...
    show_dimensions = ...
    @property
    def should_show_dimensions(self):
        ...
    
    def _get_formatter(self, i):
        ...
    


class DataFrameFormatter(TableFormatter):
    """
    Render a DataFrame

    self.to_string() : console-friendly tabular output
    self.to_html()   : html table
    self.to_latex()   : LaTeX tabular environment table

    """
    __doc__ = ...
    def __init__(self, frame, buf: Optional[Any] = ..., columns: Optional[Any] = ..., col_space: Optional[Any] = ..., header: bool = ..., index: bool = ..., na_rep=..., formatters: Optional[Any] = ..., justify: Optional[Any] = ..., float_format: Optional[Any] = ..., sparsify: Optional[Any] = ..., index_names: bool = ..., line_width: Optional[Any] = ..., max_rows: Optional[Any] = ..., max_cols: Optional[Any] = ..., show_dimensions: bool = ..., decimal=..., **kwds):
        self.frame = ...
        self.show_index_names = ...
        self.sparsify = ...
        self.float_format = ...
        self.formatters = ...
        self.na_rep = ...
        self.decimal = ...
        self.col_space = ...
        self.header = ...
        self.index = ...
        self.line_width = ...
        self.max_rows = ...
        self.max_cols = ...
        self.max_rows_displayed = ...
        self.show_dimensions = ...
        self.kwds = ...
        self.adj = ...
    
    def _chk_truncate(self):
        """
        Checks whether the frame should be truncated. If so, slices
        the frame up.
        """
        self.tr_size_col = ...
        self.tr_frame = ...
        self.truncate_h = ...
        self.truncate_v = ...
        self.is_truncated = ...
    
    def _to_str_columns(self):
        """
        Render a DataFrame to a list of columns (as lists of strings).
        """
        ...
    
    def to_string(self):
        """
        Render a DataFrame to a console-friendly tabular output.
        """
        ...
    
    def _join_multiline(self, *strcols):
        ...
    
    def to_latex(self, column_format: Optional[Any] = ..., longtable: bool = ..., encoding: Optional[Any] = ..., multicolumn: bool = ..., multicolumn_format: Optional[Any] = ..., multirow: bool = ...):
        """
        Render a DataFrame to a LaTeX tabular/longtable environment output.
        """
        ...
    
    def _format_col(self, i):
        ...
    
    def to_html(self, classes: Optional[Any] = ..., notebook: bool = ..., border: Optional[Any] = ...):
        """
        Render a DataFrame to a html table.

        Parameters
        ----------
        classes : str or list-like
            classes to include in the `class` attribute of the opening
            ``<table>`` tag, in addition to the default "dataframe".
        notebook : {True, False}, optional, default False
            Whether the generated HTML is for IPython Notebook.
        border : int
            A ``border=border`` attribute is included in the opening
            ``<table>`` tag. Default ``pd.options.html.border``.

            .. versionadded:: 0.19.0
         """
        ...
    
    def _get_formatted_column_labels(self, frame):
        ...
    
    @property
    def has_index_names(self):
        ...
    
    @property
    def has_column_names(self):
        ...
    
    def _get_formatted_index(self, frame):
        ...
    
    def _get_column_name_list(self):
        ...
    


class LatexFormatter(TableFormatter):
    """ Used to render a DataFrame to a LaTeX tabular/longtable environment
    output.

    Parameters
    ----------
    formatter : `DataFrameFormatter`
    column_format : str, default None
        The columns format as specified in `LaTeX table format
        <https://en.wikibooks.org/wiki/LaTeX/Tables>`__ e.g 'rcl' for 3 columns
    longtable : boolean, default False
        Use a longtable environment instead of tabular.

    See also
    --------
    HTMLFormatter
    """
    def __init__(self, formatter, column_format: Optional[Any] = ..., longtable: bool = ..., multicolumn: bool = ..., multicolumn_format: Optional[Any] = ..., multirow: bool = ...):
        self.fmt = ...
        self.frame = ...
        self.bold_rows = ...
        self.column_format = ...
        self.longtable = ...
        self.multicolumn = ...
        self.multicolumn_format = ...
        self.multirow = ...
    
    def write_result(self, buf):
        """
        Render a DataFrame to a LaTeX tabular/longtable environment output.
        """
        self.clinebuf = ...
    
    def _format_multicolumn(self, row, ilevels):
        """
        Combine columns belonging to a group to a single multicolumn entry
        according to self.multicolumn_format

        e.g.:
        a &  &  & b & c &
        will become
        \multicolumn{3}{l}{a} & b & \multicolumn{2}{l}{c}
        """
        ...
    
    def _format_multirow(self, row, ilevels, i, rows):
        """
        Check following rows, whether row should be a multirow

        e.g.:     becomes:
        a & 0 &   \multirow{2}{*}{a} & 0 &
          & 1 &     & 1 &
        b & 0 &   \cline{1-2}
                  b & 0 &
        """
        ...
    
    def _print_cline(self, buf, i, icol):
        """
        Print clines after multirow-blocks are finished
        """
        self.clinebuf = ...
    


class HTMLFormatter(TableFormatter):
    indent_delta = ...
    def __init__(self, formatter, classes: Optional[Any] = ..., max_rows: Optional[Any] = ..., max_cols: Optional[Any] = ..., notebook: bool = ..., border: Optional[Any] = ...):
        self.fmt = ...
        self.classes = ...
        self.frame = ...
        self.columns = ...
        self.elements = ...
        self.bold_rows = ...
        self.escape = ...
        self.max_rows = ...
        self.max_cols = ...
        self.show_dimensions = ...
        self.is_truncated = ...
        self.notebook = ...
        self.border = ...
    
    def write(self, s, indent=...):
        ...
    
    def write_th(self, s, indent=..., tags: Optional[Any] = ...):
        ...
    
    def write_td(self, s, indent=..., tags: Optional[Any] = ...):
        ...
    
    def _write_cell(self, s, kind=..., indent=..., tags: Optional[Any] = ...):
        ...
    
    def write_tr(self, line, indent=..., indent_delta=..., header: bool = ..., align: Optional[Any] = ..., tags: Optional[Any] = ..., nindex_levels=...):
        ...
    
    def write_style(self):
        ...
    
    def write_result(self, buf):
        ...
    
    def _write_header(self, indent):
        ...
    
    def _write_body(self, indent):
        ...
    
    def _write_regular_rows(self, fmt_values, indent):
        ...
    
    def _write_hierarchical_rows(self, fmt_values, indent):
        ...
    


class CSVFormatter(object):
    def __init__(self, obj, path_or_buf: Optional[Any] = ..., sep=..., na_rep=..., float_format: Optional[Any] = ..., cols: Optional[Any] = ..., header: bool = ..., index: bool = ..., index_label: Optional[Any] = ..., mode=..., nanRep: Optional[Any] = ..., encoding: Optional[Any] = ..., compression: Optional[Any] = ..., quoting: Optional[Any] = ..., line_terminator=..., chunksize: Optional[Any] = ..., tupleize_cols: bool = ..., quotechar=..., date_format: Optional[Any] = ..., doublequote: bool = ..., escapechar: Optional[Any] = ..., decimal=...):
        self.obj = ...
        self.path_or_buf = ...
        self.sep = ...
        self.na_rep = ...
        self.float_format = ...
        self.decimal = ...
        self.header = ...
        self.index = ...
        self.index_label = ...
        self.mode = ...
        self.encoding = ...
        self.compression = ...
        self.quoting = ...
        self.quotechar = ...
        self.doublequote = ...
        self.escapechar = ...
        self.line_terminator = ...
        self.date_format = ...
        self.tupleize_cols = ...
        self.has_mi_columns = ...
        self.cols = ...
        self.blocks = ...
        self.data = ...
        self.chunksize = ...
        self.data_index = ...
        self.nlevels = ...
    
    def save(self):
        ...
    
    def _save_header(self):
        ...
    
    def _save(self):
        ...
    
    def _save_chunk(self, start_i, end_i):
        ...
    


def format_array(values, formatter, float_format: Optional[Any] = ..., na_rep=..., digits: Optional[Any] = ..., space: Optional[Any] = ..., justify=..., decimal=...):
    ...

class GenericArrayFormatter(object):
    def __init__(self, values, digits=..., formatter: Optional[Any] = ..., na_rep=..., space=..., float_format: Optional[Any] = ..., justify=..., decimal=..., quoting: Optional[Any] = ..., fixed_width: bool = ...):
        self.values = ...
        self.digits = ...
        self.na_rep = ...
        self.space = ...
        self.formatter = ...
        self.float_format = ...
        self.justify = ...
        self.decimal = ...
        self.quoting = ...
        self.fixed_width = ...
    
    def get_result(self):
        ...
    
    def _format_strings(self):
        ...
    


class FloatArrayFormatter(GenericArrayFormatter):
    """

    """
    def __init__(self, *args, **kwargs):
        ...
    
    def _value_formatter(self, float_format: Optional[Any] = ..., threshold: Optional[Any] = ...):
        """Returns a function to be applied on each value to format it
        """
        ...
    
    def get_result_as_array(self):
        """
        Returns the float values converted into strings using
        the parameters given at initalisation, as a numpy array
        """
        ...
    
    def _format_strings(self):
        ...
    


class IntArrayFormatter(GenericArrayFormatter):
    def _format_strings(self):
        ...
    


class Datetime64Formatter(GenericArrayFormatter):
    def __init__(self, values, nat_rep=..., date_format: Optional[Any] = ..., **kwargs):
        self.nat_rep = ...
        self.date_format = ...
    
    def _format_strings(self):
        """ we by definition have DO NOT have a TZ """
        ...
    


class IntervalArrayFormatter(GenericArrayFormatter):
    def __init__(self, values, *args, **kwargs):
        ...
    
    def _format_strings(self):
        ...
    


class PeriodArrayFormatter(IntArrayFormatter):
    def _format_strings(self):
        ...
    


class CategoricalArrayFormatter(GenericArrayFormatter):
    def __init__(self, values, *args, **kwargs):
        ...
    
    def _format_strings(self):
        ...
    


def format_percentiles(percentiles):
    """
    Outputs rounded and formatted percentiles.

    Parameters
    ----------
    percentiles : list-like, containing floats from interval [0,1]

    Returns
    -------
    formatted : list of strings

    Notes
    -----
    Rounding precision is chosen so that: (1) if any two elements of
    ``percentiles`` differ, they remain different after rounding
    (2) no entry is *rounded* to 0% or 100%.
    Any non-integer is always rounded to at least 1 decimal place.

    Examples
    --------
    Keeps all entries different after rounding:

    >>> format_percentiles([0.01999, 0.02001, 0.5, 0.666666, 0.9999])
    ['1.999%', '2.001%', '50%', '66.667%', '99.99%']

    No element is rounded to 0% or 100% (unless already equal to it).
    Duplicates are allowed:

    >>> format_percentiles([0, 0.5, 0.02001, 0.5, 0.666666, 0.9999])
    ['0%', '50%', '2.0%', '50%', '66.67%', '99.99%']
    """
    ...

def _is_dates_only(values):
    ...

def _format_datetime64(x, tz: Optional[Any] = ..., nat_rep=...):
    ...

def _format_datetime64_dateonly(x, nat_rep=..., date_format: Optional[Any] = ...):
    ...

def _get_format_datetime64(is_dates_only, nat_rep=..., date_format: Optional[Any] = ...):
    ...

def _get_format_datetime64_from_values(values, date_format):
    """ given values and a date_format, return a string format """
    ...

class Datetime64TZFormatter(Datetime64Formatter):
    def _format_strings(self):
        """ we by definition have a TZ """
        ...
    


class Timedelta64Formatter(GenericArrayFormatter):
    def __init__(self, values, nat_rep=..., box: bool = ..., **kwargs):
        self.nat_rep = ...
        self.box = ...
    
    def _format_strings(self):
        ...
    


def _get_format_timedelta64(values, nat_rep=..., box: bool = ...):
    """
    Return a formatter function for a range of timedeltas.
    These will all have the same format argument

    If box, then show the return in quotes
    """
    ...

def _make_fixed_width(strings, justify=..., minimum: Optional[Any] = ..., adj: Optional[Any] = ...):
    ...

def _trim_zeros(str_floats, na_rep=...):
    """
    Trims zeros, leaving just one before the decimal points if need be.
    """
    ...

def single_column_table(column, align: Optional[Any] = ..., style: Optional[Any] = ...):
    ...

def single_row_table(row):
    ...

def _has_names(index):
    ...

class EngFormatter(object):
    """
    Formats float values according to engineering format.

    Based on matplotlib.ticker.EngFormatter
    """
    ENG_PREFIXES = ...
    def __init__(self, accuracy: Optional[Any] = ..., use_eng_prefix: bool = ...):
        self.accuracy = ...
        self.use_eng_prefix = ...
    
    def __call__(self, num):
        """ Formats a number in engineering notation, appending a letter
        representing the power of 1000 of the original number. Some examples:

        >>> format_eng(0)       # for self.accuracy = 0
        ' 0'

        >>> format_eng(1000000) # for self.accuracy = 1,
                                #     self.use_eng_prefix = True
        ' 1.0M'

        >>> format_eng("-1e-6") # for self.accuracy = 2
                                #     self.use_eng_prefix = False
        '-1.00E-06'

        @param num: the value to represent
        @type num: either a numeric value or a string that can be converted to
                   a numeric value (as per decimal.Decimal constructor)

        @return: engineering formatted string
        """
        ...
    


def set_eng_float_format(accuracy=..., use_eng_prefix: bool = ...):
    """
    Alter default behavior on how float is formatted in DataFrame.
    Format float in engineering format. By accuracy, we mean the number of
    decimal digits after the floating point.

    See also EngFormatter.
    """
    ...

def _put_lines(buf, lines):
    ...

def _binify(cols, line_width):
    ...

