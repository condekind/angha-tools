"""
This type stub file was generated by pyright.
"""

import datetime
from pandas.core.base import StringMixin
from pandas.io.common import BaseIterator
from pandas.util._decorators import Appender, deprecate_kwarg
from typing import Any, Optional

"""
Module contains tools for processing Stata files into DataFrames

The StataReader below was originally written by Joe Presbrey as part of PyDTA.
It has been extended and improved by Skipper Seabold from the Statsmodels
project who also developed the StataWriter and was finally added to pandas in
a once again improved version.

You can find more information on http://presbrey.mit.edu/PyDTA and
http://www.statsmodels.org/devel/
"""
VALID_ENCODINGS = ('ascii', 'us-ascii', 'latin-1', 'latin_1', 'iso-8859-1', 'iso8859-1', '8859', 'cp819', 'latin', 'latin1', 'L1')
_version_error = "Version of given Stata file is not 104, 105, 108, " "111 (Stata 7SE), 113 (Stata 8/9), 114 (Stata 10/11), " "115 (Stata 12), 117 (Stata 13), or 118 (Stata 14)"
_statafile_processing_params1 = """\
convert_dates : boolean, defaults to True
    Convert date variables to DataFrame time values
convert_categoricals : boolean, defaults to True
    Read value labels and convert columns to Categorical/Factor variables"""
_encoding_params = """\
encoding : string, None or encoding
    Encoding used to parse the files. None defaults to latin-1."""
_statafile_processing_params2 = """\
index_col : string, optional, default: None
    Column to set as index
convert_missing : boolean, defaults to False
    Flag indicating whether to convert missing values to their Stata
    representations.  If False, missing values are replaced with nan.
    If True, columns containing missing values are returned with
    object data types and missing values are represented by
    StataMissingValue objects.
preserve_dtypes : boolean, defaults to True
    Preserve Stata datatypes. If False, numeric data are upcast to pandas
    default types for foreign data (float64 or int64)
columns : list or None
    Columns to retain.  Columns will be returned in the given order.  None
    returns all columns
order_categoricals : boolean, defaults to True
    Flag indicating whether converted categorical data are ordered."""
_chunksize_params = """\
chunksize : int, default None
    Return StataReader object for iterations, returns chunks with
    given number of lines"""
_iterator_params = """\
iterator : boolean, default False
    Return StataReader object"""
_read_stata_doc = """Read Stata file into DataFrame

Parameters
----------
filepath_or_buffer : string or file-like object
    Path to .dta file or object implementing a binary read() functions
%s
%s
%s
%s
%s

Returns
-------
DataFrame or StataReader

Examples
--------
Read a Stata dta file:

>>> df = pandas.read_stata('filename.dta')

Read a Stata dta file in 10,000 line chunks:

>>> itr = pandas.read_stata('filename.dta', chunksize=10000)
>>> for chunk in itr:
>>>     do_something(chunk)
""" % (_statafile_processing_params1, _encoding_params, _statafile_processing_params2, _chunksize_params, _iterator_params)
_data_method_doc = """\
Reads observations from Stata file, converting them into a dataframe

    .. deprecated::
       This is a legacy method.  Use `read` in new code.

Parameters
----------
%s
%s

Returns
-------
DataFrame
""" % (_statafile_processing_params1, _statafile_processing_params2)
_read_method_doc = """\
Reads observations from Stata file, converting them into a dataframe

Parameters
----------
nrows : int
    Number of lines to read from data file, if None read whole file.
%s
%s

Returns
-------
DataFrame
""" % (_statafile_processing_params1, _statafile_processing_params2)
_stata_reader_doc = """\
Class for reading Stata dta files.

Parameters
----------
path_or_buf : string or file-like object
    Path to .dta file or object implementing a binary read() functions
%s
%s
%s
%s
""" % (_statafile_processing_params1, _statafile_processing_params2, _encoding_params, _chunksize_params)
@Appender(_read_stata_doc)
@deprecate_kwarg(old_arg_name='index', new_arg_name='index_col')
def read_stata(filepath_or_buffer, convert_dates: bool = ..., convert_categoricals: bool = ..., encoding: Optional[Any] = ..., index_col: Optional[Any] = ..., convert_missing: bool = ..., preserve_dtypes: bool = ..., columns: Optional[Any] = ..., order_categoricals: bool = ..., chunksize: Optional[Any] = ..., iterator: bool = ...):
    ...

_date_formats = ["%tc", "%tC", "%td", "%d", "%tw", "%tm", "%tq", "%th", "%ty"]
stata_epoch = datetime.datetime(1960, 1, 1)
def _stata_elapsed_date_to_datetime_vec(dates, fmt):
    """
    Convert from SIF to datetime. http://www.stata.com/help.cgi?datetime

    Parameters
    ----------
    dates : Series
        The Stata Internal Format date to convert to datetime according to fmt
    fmt : str
        The format to convert to. Can be, tc, td, tw, tm, tq, th, ty
        Returns

    Returns
    -------
    converted : Series
        The converted dates

    Examples
    --------
    >>> import pandas as pd
    >>> dates = pd.Series([52])
    >>> _stata_elapsed_date_to_datetime_vec(dates , "%tw")
    0   1961-01-01
    dtype: datetime64[ns]

    Notes
    -----
    datetime/c - tc
        milliseconds since 01jan1960 00:00:00.000, assuming 86,400 s/day
    datetime/C - tC - NOT IMPLEMENTED
        milliseconds since 01jan1960 00:00:00.000, adjusted for leap seconds
    date - td
        days since 01jan1960 (01jan1960 = 0)
    weekly date - tw
        weeks since 1960w1
        This assumes 52 weeks in a year, then adds 7 * remainder of the weeks.
        The datetime value is the start of the week in terms of days in the
        year, not ISO calendar weeks.
    monthly date - tm
        months since 1960m1
    quarterly date - tq
        quarters since 1960q1
    half-yearly date - th
        half-years since 1960h1 yearly
    date - ty
        years since 0000

    If you don't have pandas with datetime support, then you can't do
    milliseconds accurately.
    """
    ...

def _datetime_to_stata_elapsed_vec(dates, fmt):
    """
    Convert from datetime to SIF. http://www.stata.com/help.cgi?datetime

    Parameters
    ----------
    dates : Series
        Series or array containing datetime.datetime or datetime64[ns] to
        convert to the Stata Internal Format given by fmt
    fmt : str
        The format to convert to. Can be, tc, td, tw, tm, tq, th, ty
    """
    ...

excessive_string_length_error = """
Fixed width strings in Stata .dta files are limited to 244 (or fewer)
characters.  Column '%s' does not satisfy this restriction.
"""
class PossiblePrecisionLoss(Warning):
    ...


precision_loss_doc = """
Column converted from %s to %s, and some data are outside of the lossless
conversion range. This may result in a loss of precision in the saved data.
"""
class ValueLabelTypeMismatch(Warning):
    ...


value_label_mismatch_doc = """
Stata value labels (pandas categories) must be strings. Column {0} contains
non-string labels which will be converted to strings.  Please check that the
Stata data file created has not lost information due to duplicate labels.
"""
class InvalidColumnName(Warning):
    ...


invalid_name_doc = """
Not all pandas column names were valid Stata variable names.
The following replacements have been made:

    {0}

If this is not what you expect, please make sure you have Stata-compliant
column names in your DataFrame (strings only, max 32 characters, only
alphanumerics and underscores, no Stata reserved words)
"""
def _cast_to_stata_types(data):
    """Checks the dtypes of the columns of a pandas DataFrame for
    compatibility with the data types and ranges supported by Stata, and
    converts if necessary.

    Parameters
    ----------
    data : DataFrame
        The DataFrame to check and convert

    Notes
    -----
    Numeric columns in Stata must be one of int8, int16, int32, float32 or
    float64, with some additional value restrictions.  int8 and int16 columns
    are checked for violations of the value restrictions and upcast if needed.
    int64 data is not usable in Stata, and so it is downcast to int32 whenever
    the value are in the int32 range, and sidecast to float64 when larger than
    this range.  If the int64 values are outside of the range of those
    perfectly representable as float64 values, a warning is raised.

    bool columns are cast to int8.  uint columns are converted to int of the
    same size if there is no loss in precision, otherwise are upcast to a
    larger type.  uint64 is currently not supported since it is concerted to
    object in a DataFrame.
    """
    ...

class StataValueLabel(object):
    """
    Parse a categorical column and prepare formatted output

    Parameters
    -----------
    value : int8, int16, int32, float32 or float64
        The Stata missing value code

    Attributes
    ----------
    string : string
        String representation of the Stata missing value
    value : int8, int16, int32, float32 or float64
        The original encoded missing value

    Methods
    -------
    generate_value_label

    """
    def __init__(self, catarray):
        self.labname = ...
        self.value_labels = ...
        self.text_len = ...
        self.off = ...
        self.val = ...
        self.txt = ...
        self.n = ...
        self.off = ...
        self.val = ...
        self.len = ...
    
    def _encode(self, s):
        """
        Python 3 compatability shim
        """
        ...
    
    def generate_value_label(self, byteorder, encoding):
        """
        Parameters
        ----------
        byteorder : str
            Byte order of the output
        encoding : str
            File encoding

        Returns
        -------
        value_label : bytes
            Bytes containing the formatted value label
        """
        ...
    


class StataMissingValue(StringMixin):
    """
    An observation's missing value.

    Parameters
    -----------
    value : int8, int16, int32, float32 or float64
        The Stata missing value code

    Attributes
    ----------
    string : string
        String representation of the Stata missing value
    value : int8, int16, int32, float32 or float64
        The original encoded missing value

    Notes
    -----
    More information: <http://www.stata.com/help.cgi?missing>

    Integer missing values make the code '.', '.a', ..., '.z' to the ranges
    101 ... 127 (for int8), 32741 ... 32767  (for int16) and 2147483621 ...
    2147483647 (for int32).  Missing values for floating point data types are
    more complex but the pattern is simple to discern from the following table.

    np.float32 missing values (float in Stata)
    0000007f    .
    0008007f    .a
    0010007f    .b
    ...
    00c0007f    .x
    00c8007f    .y
    00d0007f    .z

    np.float64 missing values (double in Stata)
    000000000000e07f    .
    000000000001e07f    .a
    000000000002e07f    .b
    ...
    000000000018e07f    .x
    000000000019e07f    .y
    00000000001ae07f    .z
    """
    MISSING_VALUES = ...
    bases = ...
    float32_base = ...
    increment = ...
    float64_base = ...
    increment = ...
    BASE_MISSING_VALUES = ...
    def __init__(self, value):
        ...
    
    string = ...
    value = ...
    def __unicode__(self):
        ...
    
    def __repr__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    @classmethod
    def get_base_missing_value(cls, dtype):
        ...
    


class StataParser(object):
    _default_encoding = ...
    def __init__(self, encoding):
        self.DTYPE_MAP = ...
        self.DTYPE_MAP_XML = ...
        self.TYPE_MAP = ...
        self.TYPE_MAP_XML = ...
        self.VALID_RANGE = ...
        self.OLD_TYPE_MAPPING = ...
        self.MISSING_VALUES = ...
        self.NUMPY_TYPE_MAP = ...
        self.RESERVED_WORDS = ...
    


class StataReader(StataParser, BaseIterator):
    __doc__ = ...
    @deprecate_kwarg(old_arg_name='index', new_arg_name='index_col')
    def __init__(self, path_or_buf, convert_dates: bool = ..., convert_categoricals: bool = ..., index_col: Optional[Any] = ..., convert_missing: bool = ..., preserve_dtypes: bool = ..., columns: Optional[Any] = ..., order_categoricals: bool = ..., encoding=..., chunksize: Optional[Any] = ...):
        self.col_sizes = ...
    
    def __enter__(self):
        """ enter context manager """
        ...
    
    def __exit__(self, exc_type, exc_value, traceback):
        """ exit context manager """
        ...
    
    def close(self):
        """ close the handle if its open """
        ...
    
    def _read_header(self):
        self.has_string_data = ...
        self.col_sizes = ...
    
    def _read_new_header(self, first_char):
        self.format_version = ...
        self.byteorder = ...
        self.nvar = ...
        self.nobs = ...
        self.data_label = ...
        self.time_stamp = ...
        self.data_location = ...
        self.seek_strls = ...
        self.seek_value_labels = ...
        self.varlist = ...
        self.srtlist = ...
        self.fmtlist = ...
        self.lbllist = ...
    
    def _get_dtypes(self, seek_vartypes):
        ...
    
    def _get_varlist(self):
        ...
    
    def _get_fmtlist(self):
        ...
    
    def _get_lbllist(self):
        ...
    
    def _get_variable_labels(self):
        ...
    
    def _get_nobs(self):
        ...
    
    def _get_data_label(self):
        ...
    
    def _get_time_stamp(self):
        ...
    
    def _get_seek_variable_labels(self):
        ...
    
    def _read_old_header(self, first_char):
        self.format_version = ...
        self.byteorder = ...
        self.filetype = ...
        self.nvar = ...
        self.nobs = ...
        self.data_label = ...
        self.time_stamp = ...
        self.srtlist = ...
        self.fmtlist = ...
        self.lbllist = ...
        self.data_location = ...
    
    def _setup_dtype(self):
        """Map between numpy and state dtypes"""
        ...
    
    def _calcsize(self, fmt):
        ...
    
    def _decode(self, s):
        ...
    
    def _null_terminate(self, s):
        ...
    
    def _read_value_labels(self):
        self.value_label_dict = ...
    
    def _read_strls(self):
        self.GSO = ...
    
    @Appender(_data_method_doc)
    def data(self, **kwargs):
        ...
    
    def __next__(self):
        ...
    
    def get_chunk(self, size: Optional[Any] = ...):
        """
        Reads lines from Stata file and returns as dataframe

        Parameters
        ----------
        size : int, defaults to None
            Number of lines to read.  If None, reads whole file.

        Returns
        -------
        DataFrame
        """
        ...
    
    @Appender(_read_method_doc)
    @deprecate_kwarg(old_arg_name='index', new_arg_name='index_col')
    def read(self, nrows: Optional[Any] = ..., convert_dates: Optional[Any] = ..., convert_categoricals: Optional[Any] = ..., index_col: Optional[Any] = ..., convert_missing: Optional[Any] = ..., preserve_dtypes: Optional[Any] = ..., columns: Optional[Any] = ..., order_categoricals: Optional[Any] = ...):
        ...
    
    def _do_convert_missing(self, data, convert_missing):
        ...
    
    def _insert_strls(self, data):
        ...
    
    def _do_select_columns(self, data, columns):
        ...
    
    def _do_convert_categoricals(self, data, value_label_dict, lbllist, order_categoricals):
        """
        Converts categorical columns to Categorical type.
        """
        ...
    
    def data_label(self):
        """Returns data label of Stata file"""
        ...
    
    def variable_labels(self):
        """Returns variable labels as a dict, associating each variable name
        with corresponding label
        """
        ...
    
    def value_labels(self):
        """Returns a dict, associating each variable name a dict, associating
        each value its corresponding label
        """
        ...
    


def _open_file_binary_write(fname, encoding):
    ...

def _set_endianness(endianness):
    ...

def _pad_bytes(name, length):
    """
    Takes a char string and pads it with null bytes until it's length chars
    """
    ...

def _convert_datetime_to_stata_type(fmt):
    """
    Converts from one of the stata date formats to a type in TYPE_MAP
    """
    ...

def _maybe_convert_to_int_keys(convert_dates, varlist):
    ...

def _dtype_to_stata_type(dtype, column):
    """
    Converts dtype types to stata types. Returns the byte of the given ordinal.
    See TYPE_MAP and comments for an explanation. This is also explained in
    the dta spec.
    1 - 244 are strings of this length
                         Pandas    Stata
    251 - chr(251) - for int8      byte
    252 - chr(252) - for int16     int
    253 - chr(253) - for int32     long
    254 - chr(254) - for float32   float
    255 - chr(255) - for double    double

    If there are dates to convert, then dtype will already have the correct
    type inserted.
    """
    ...

def _dtype_to_default_stata_fmt(dtype, column):
    """
    Maps numpy dtype to stata's default format for this type. Not terribly
    important since users can change this in Stata. Semantics are

    object  -> "%DDs" where DD is the length of the string.  If not a string,
                raise ValueError
    float64 -> "%10.0g"
    float32 -> "%9.0g"
    int64   -> "%9.0g"
    int32   -> "%12.0g"
    int16   -> "%8.0g"
    int8    -> "%8.0g"
    """
    ...

class StataWriter(StataParser):
    """
    A class for writing Stata binary dta files

    Parameters
    ----------
    fname : str or buffer
        String path of file-like object
    data : DataFrame
        Input to save
    convert_dates : dict
        Dictionary mapping columns containing datetime types to stata internal
        format to use when wirting the dates. Options are 'tc', 'td', 'tm',
        'tw', 'th', 'tq', 'ty'. Column can be either an integer or a name.
        Datetime columns that do not have a conversion type specified will be
        converted to 'tc'. Raises NotImplementedError if a datetime column has
        timezone information
    write_index : bool
        Write the index to Stata dataset.
    encoding : str
        Default is latin-1. Only latin-1 and ascii are supported.
    byteorder : str
        Can be ">", "<", "little", or "big". default is `sys.byteorder`
    time_stamp : datetime
        A datetime to use as file creation date.  Default is the current time
    dataset_label : str
        A label for the data set.  Must be 80 characters or smaller.
    variable_labels : dict
        Dictionary containing columns as keys and variable labels as values.
        Each label must be 80 characters or smaller.

        .. versionadded:: 0.19.0

    Returns
    -------
    writer : StataWriter instance
        The StataWriter instance has a write_file method, which will
        write the file to the given `fname`.

    Raises
    ------
    NotImplementedError
        * If datetimes contain timezone information
    ValueError
        * Columns listed in convert_dates are noth either datetime64[ns]
          or datetime.datetime
        * Column dtype is not representable in Stata
        * Column listed in convert_dates is not in DataFrame
        * Categorical label contains more than 32,000 characters

    Examples
    --------
    >>> import pandas as pd
    >>> data = pd.DataFrame([[1.0, 1]], columns=['a', 'b'])
    >>> writer = StataWriter('./data_file.dta', data)
    >>> writer.write_file()

    Or with dates
    >>> from datetime import datetime
    >>> data = pd.DataFrame([[datetime(2000,1,1)]], columns=['date'])
    >>> writer = StataWriter('./date_data_file.dta', data, {'date' : 'tw'})
    >>> writer.write_file()
    """
    def __init__(self, fname, data, convert_dates: Optional[Any] = ..., write_index: bool = ..., encoding=..., byteorder: Optional[Any] = ..., time_stamp: Optional[Any] = ..., data_label: Optional[Any] = ..., variable_labels: Optional[Any] = ...):
        self.type_converters = ...
    
    def _write(self, to_write):
        """
        Helper to call encode before writing to file for Python 3 compat.
        """
        ...
    
    def _prepare_categoricals(self, data):
        """Check for categorical columns, retain categorical information for
        Stata file and convert categorical data to int"""
        ...
    
    def _replace_nans(self, data):
        """Checks floating point data columns for nans, and replaces these with
        the generic Stata for missing value (.)"""
        ...
    
    def _check_column_names(self, data):
        """
        Checks column names to ensure that they are valid Stata column names.
        This includes checks for:
            * Non-string names
            * Stata keywords
            * Variables that start with numbers
            * Variables with names that are too long

        When an illegal variable name is detected, it is converted, and if
        dates are exported, the variable name is propagated to the date
        conversion dictionary
        """
        ...
    
    def _prepare_pandas(self, data):
        self.data = ...
        self.varlist = ...
        self.typlist = ...
        self.fmtlist = ...
    
    def write_file(self):
        ...
    
    def _write_value_labels(self):
        ...
    
    def _write_header(self, data_label: Optional[Any] = ..., time_stamp: Optional[Any] = ...):
        ...
    
    def _write_descriptors(self, typlist: Optional[Any] = ..., varlist: Optional[Any] = ..., srtlist: Optional[Any] = ..., fmtlist: Optional[Any] = ..., lbllist: Optional[Any] = ...):
        ...
    
    def _write_variable_labels(self):
        ...
    
    def _prepare_data(self):
        ...
    
    def _write_data(self):
        ...
    
    def _null_terminate(self, s, as_string: bool = ...):
        ...
    


