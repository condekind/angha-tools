"""
This type stub file was generated by pyright.
"""

from . import artist, docstring
from typing import Any, Optional

_patch_alias_map = { 'antialiased': ['aa'],'edgecolor': ['ec'],'facecolor': ['fc'],'linewidth': ['lw'],'linestyle': ['ls'] }
class Patch(artist.Artist):
    """
    A patch is a 2D artist with a face color and an edge color.

    If any of *edgecolor*, *facecolor*, *linewidth*, or *antialiased*
    are *None*, they default to their rc params setting.
    """
    zorder = ...
    validCap = ...
    validJoin = ...
    _edge_default = ...
    def __str__(self):
        ...
    
    def __init__(self, edgecolor: Optional[Any] = ..., facecolor: Optional[Any] = ..., color: Optional[Any] = ..., linewidth: Optional[Any] = ..., linestyle: Optional[Any] = ..., antialiased: Optional[Any] = ..., hatch: Optional[Any] = ..., fill: bool = ..., capstyle: Optional[Any] = ..., joinstyle: Optional[Any] = ..., **kwargs):
        """
        The following kwarg properties are supported

        %(Patch)s
        """
        ...
    
    def get_verts(self):
        """
        Return a copy of the vertices used in this patch

        If the patch contains Bezier curves, the curves will be
        interpolated by line segments.  To access the curves as
        curves, use :meth:`get_path`.
        """
        ...
    
    def _process_radius(self, radius):
        ...
    
    def contains(self, mouseevent, radius: Optional[Any] = ...):
        """Test whether the mouse event occurred in the patch.

        Returns T/F, {}
        """
        ...
    
    def contains_point(self, point, radius: Optional[Any] = ...):
        """
        Returns ``True`` if the given *point* is inside the path
        (transformed with its transform attribute).

        *radius* allows the path to be made slightly larger or smaller.
        """
        ...
    
    def contains_points(self, points, radius: Optional[Any] = ...):
        """
        Returns a bool array which is ``True`` if the (closed) path
        contains the corresponding point.
        (transformed with its transform attribute).

        *points* must be Nx2 array.
        *radius* allows the path to be made slightly larger or smaller.
        """
        ...
    
    def update_from(self, other):
        """
        Updates this :class:`Patch` from the properties of *other*.
        """
        ...
    
    def get_extents(self):
        """
        Return a :class:`~matplotlib.transforms.Bbox` object defining
        the axis-aligned extents of the :class:`Patch`.
        """
        ...
    
    def get_transform(self):
        """
        Return the :class:`~matplotlib.transforms.Transform` applied
        to the :class:`Patch`.
        """
        ...
    
    def get_data_transform(self):
        """
        Return the :class:`~matplotlib.transforms.Transform` instance which
        maps data coordinates to physical coordinates.
        """
        ...
    
    def get_patch_transform(self):
        """
        Return the :class:`~matplotlib.transforms.Transform` instance which
        takes patch coordinates to data coordinates.

        For example, one may define a patch of a circle which represents a
        radius of 5 by providing coordinates for a unit circle, and a
        transform which scales the coordinates (the patch coordinate) by 5.
        """
        ...
    
    def get_antialiased(self):
        """
        Returns True if the :class:`Patch` is to be drawn with antialiasing.
        """
        ...
    
    get_aa = ...
    def get_edgecolor(self):
        """
        Return the edge color of the :class:`Patch`.
        """
        ...
    
    get_ec = ...
    def get_facecolor(self):
        """
        Return the face color of the :class:`Patch`.
        """
        ...
    
    get_fc = ...
    def get_linewidth(self):
        """
        Return the line width in points.
        """
        ...
    
    get_lw = ...
    def get_linestyle(self):
        """
        Return the linestyle.  Will be one of ['solid' | 'dashed' |
        'dashdot' | 'dotted']
        """
        ...
    
    get_ls = ...
    def set_antialiased(self, aa):
        """
        Set whether to use antialiased rendering.

        Parameters
        ----------
        b : bool or None
            .. ACCEPTS: bool or None
        """
        self.stale = ...
    
    def set_aa(self, aa):
        """alias for set_antialiased"""
        ...
    
    def _set_edgecolor(self, color):
        self.stale = ...
    
    def set_edgecolor(self, color):
        """
        Set the patch edge color

        ACCEPTS: mpl color spec, None, 'none', or 'auto'
        """
        ...
    
    def set_ec(self, color):
        """alias for set_edgecolor"""
        ...
    
    def _set_facecolor(self, color):
        self.stale = ...
    
    def set_facecolor(self, color):
        """
        Set the patch face color

        ACCEPTS: mpl color spec, or None for default, or 'none' for no color
        """
        ...
    
    def set_fc(self, color):
        """alias for set_facecolor"""
        ...
    
    def set_color(self, c):
        """
        Set both the edgecolor and the facecolor.

        ACCEPTS: matplotlib color spec

        .. seealso::

            :meth:`set_facecolor`, :meth:`set_edgecolor`
               For setting the edge or face color individually.
        """
        ...
    
    def set_alpha(self, alpha):
        """
        Set the alpha tranparency of the patch.

        ACCEPTS: float or None
        """
        ...
    
    def set_linewidth(self, w):
        """
        Set the patch linewidth in points

        ACCEPTS: float or None for default
        """
        self.stale = ...
    
    def set_lw(self, lw):
        """alias for set_linewidth"""
        ...
    
    def set_linestyle(self, ls):
        """
        Set the patch linestyle

        ===========================   =================
        linestyle                     description
        ===========================   =================
        ``'-'`` or ``'solid'``        solid line
        ``'--'`` or  ``'dashed'``     dashed line
        ``'-.'`` or  ``'dashdot'``    dash-dotted line
        ``':'`` or ``'dotted'``       dotted line
        ===========================   =================

        Alternatively a dash tuple of the following form can be provided::

            (offset, onoffseq),

        where ``onoffseq`` is an even length tuple of on and off ink
        in points.

        ACCEPTS: ['solid' | 'dashed', 'dashdot', 'dotted' |
                   (offset, on-off-dash-seq) |
                   ``'-'`` | ``'--'`` | ``'-.'`` | ``':'`` | ``'None'`` |
                   ``' '`` | ``''``]

        Parameters
        ----------
        ls : { '-',  '--', '-.', ':'} and more see description
            The line style.
        """
        self.stale = ...
    
    def set_ls(self, ls):
        """alias for set_linestyle"""
        ...
    
    def set_fill(self, b):
        """
        Set whether to fill the patch.

        Parameters
        ----------
        b : bool
            .. ACCEPTS: bool
        """
        self.stale = ...
    
    def get_fill(self):
        'return whether fill is set'
        ...
    
    fill = ...
    def set_capstyle(self, s):
        """
        Set the patch capstyle

        ACCEPTS: ['butt' | 'round' | 'projecting']
        """
        self.stale = ...
    
    def get_capstyle(self):
        "Return the current capstyle"
        ...
    
    def set_joinstyle(self, s):
        """
        Set the patch joinstyle

        ACCEPTS: ['miter' | 'round' | 'bevel']
        """
        self.stale = ...
    
    def get_joinstyle(self):
        "Return the current joinstyle"
        ...
    
    def set_hatch(self, hatch):
        """
        Set the hatching pattern

        *hatch* can be one of::

          /   - diagonal hatching
          \\   - back diagonal
          |   - vertical
          -   - horizontal
          +   - crossed
          x   - crossed diagonal
          o   - small circle
          O   - large circle
          .   - dots
          *   - stars

        Letters can be combined, in which case all the specified
        hatchings are done.  If same letter repeats, it increases the
        density of hatching of that pattern.

        Hatching is supported in the PostScript, PDF, SVG and Agg
        backends only.

        ACCEPTS: ['/' | '\\\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*']
        """
        self.stale = ...
    
    def get_hatch(self):
        'Return the current hatching pattern'
        ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        'Draw the :class:`Patch` to the given *renderer*.'
        self.stale = ...
    
    def get_path(self):
        """
        Return the path of this patch
        """
        ...
    
    def get_window_extent(self, renderer: Optional[Any] = ...):
        ...
    


patchdoc = artist.kwdoc(Patch)
class Shadow(Patch):
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, patch, ox, oy, props: Optional[Any] = ..., **kwargs):
        """
        Create a shadow of the given *patch* offset by *ox*, *oy*.
        *props*, if not *None*, is a patch property update dictionary.
        If *None*, the shadow will have have the same color as the face,
        but darkened.

        kwargs are
        %(Patch)s
        """
        self.patch = ...
        self.props = ...
    
    def _update(self):
        ...
    
    def _update_transform(self, renderer):
        ...
    
    def _get_ox(self):
        ...
    
    def _set_ox(self, ox):
        ...
    
    def _get_oy(self):
        ...
    
    def _set_oy(self, oy):
        ...
    
    def get_path(self):
        ...
    
    def get_patch_transform(self):
        ...
    
    def draw(self, renderer):
        ...
    


class Rectangle(Patch):
    """
    Draw a rectangle with lower left at *xy* = (*x*, *y*) with
    specified *width*, *height* and rotation *angle*.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, width, height, angle=..., **kwargs):
        """
        Parameters
        ----------
        xy: length-2 tuple
            The bottom and left rectangle coordinates
        width:
            Rectangle width
        height:
            Rectangle height
        angle: float, optional
          rotation in degrees anti-clockwise about *xy* (default is 0.0)
        fill: bool, optional
            Whether to fill the rectangle (default is ``True``)

        Notes
        -----
        Valid kwargs are:
        %(Patch)s
        """
        self.angle = ...
    
    def get_path(self):
        """
        Return the vertices of the rectangle
        """
        ...
    
    def _update_patch_transform(self):
        """NOTE: This cannot be called until after this has been added
                 to an Axes, otherwise unit conversion will fail. This
                 makes it very important to call the accessor method and
                 not directly access the transformation member variable.
        """
        ...
    
    def _update_x1(self):
        ...
    
    def _update_y1(self):
        ...
    
    def _convert_units(self):
        '''
        Convert bounds of the rectangle
        '''
        ...
    
    def get_patch_transform(self):
        ...
    
    def get_x(self):
        "Return the left coord of the rectangle"
        ...
    
    def get_y(self):
        "Return the bottom coord of the rectangle"
        ...
    
    def get_xy(self):
        "Return the left and bottom coords of the rectangle"
        ...
    
    def get_width(self):
        "Return the width of the rectangle"
        ...
    
    def get_height(self):
        "Return the height of the rectangle"
        ...
    
    def set_x(self, x):
        "Set the left coord of the rectangle"
        self.stale = ...
    
    def set_y(self, y):
        "Set the bottom coord of the rectangle"
        self.stale = ...
    
    def set_xy(self, xy):
        """
        Set the left and bottom coords of the rectangle

        ACCEPTS: 2-item sequence
        """
        self.stale = ...
    
    def set_width(self, w):
        "Set the width of the rectangle"
        self.stale = ...
    
    def set_height(self, h):
        "Set the height of the rectangle"
        self.stale = ...
    
    def set_bounds(self, *args):
        """
        Set the bounds of the rectangle: l,b,w,h

        ACCEPTS: (left, bottom, width, height)
        """
        self.stale = ...
    
    def get_bbox(self):
        ...
    
    xy = ...


class RegularPolygon(Patch):
    """
    A regular polygon patch.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, numVertices, radius=..., orientation=..., **kwargs):
        """
        Constructor arguments:

        *xy*
          A length 2 tuple (*x*, *y*) of the center.

        *numVertices*
          the number of vertices.

        *radius*
          The distance from the center to each of the vertices.

        *orientation*
          rotates the polygon (in radians).

        Valid kwargs are:
        %(Patch)s
        """
        ...
    
    def _update_transform(self):
        ...
    
    def _get_xy(self):
        ...
    
    def _set_xy(self, xy):
        ...
    
    xy = ...
    def _get_orientation(self):
        ...
    
    def _set_orientation(self, orientation):
        ...
    
    orientation = ...
    def _get_radius(self):
        ...
    
    def _set_radius(self, radius):
        ...
    
    radius = ...
    def _get_numvertices(self):
        ...
    
    def _set_numvertices(self, numVertices):
        ...
    
    numvertices = ...
    def get_path(self):
        ...
    
    def get_patch_transform(self):
        ...
    


class PathPatch(Patch):
    """
    A general polycurve path patch.
    """
    _edge_default = ...
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, path, **kwargs):
        """
        *path* is a :class:`matplotlib.path.Path` object.

        Valid kwargs are:
        %(Patch)s

        .. seealso::

            :class:`Patch`
                For additional kwargs

        """
        ...
    
    def get_path(self):
        ...
    


class Polygon(Patch):
    """
    A general polygon patch.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, closed: bool = ..., **kwargs):
        """
        *xy* is a numpy array with shape Nx2.

        If *closed* is *True*, the polygon will be closed so the
        starting and ending points are the same.

        Valid kwargs are:
        %(Patch)s

        .. seealso::

            :class:`Patch`
                For additional kwargs

        """
        ...
    
    def get_path(self):
        """
        Get the path of the polygon

        Returns
        -------
        path : Path
           The :class:`~matplotlib.path.Path` object for
           the polygon
        """
        ...
    
    def get_closed(self):
        """
        Returns if the polygon is closed

        Returns
        -------
        closed : bool
            If the path is closed
        """
        ...
    
    def set_closed(self, closed):
        """
        Set if the polygon is closed

        Parameters
        ----------
        closed : bool
           True if the polygon is closed
        """
        self.stale = ...
    
    def get_xy(self):
        """
        Get the vertices of the path

        Returns
        -------
        vertices : numpy array
            The coordinates of the vertices as a Nx2
            ndarray.
        """
        ...
    
    def set_xy(self, xy):
        """
        Set the vertices of the polygon

        Parameters
        ----------
        xy : numpy array or iterable of pairs
            The coordinates of the vertices as a Nx2
            ndarray or iterable of pairs.
        """
        self.stale = ...
    
    _get_xy = ...
    _set_xy = ...
    xy = ...


class Wedge(Patch):
    """
    Wedge shaped patch.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, center, r, theta1, theta2, width: Optional[Any] = ..., **kwargs):
        """
        Draw a wedge centered at *x*, *y* center with radius *r* that
        sweeps *theta1* to *theta2* (in degrees).  If *width* is given,
        then a partial wedge is drawn from inner radius *r* - *width*
        to outer radius *r*.

        Valid kwargs are:

        %(Patch)s
        """
        self.center = ...
    
    def _recompute_path(self):
        ...
    
    def set_center(self, center):
        self.center = ...
        self.stale = ...
    
    def set_radius(self, radius):
        self.r = ...
        self.stale = ...
    
    def set_theta1(self, theta1):
        self.theta1 = ...
        self.stale = ...
    
    def set_theta2(self, theta2):
        self.theta2 = ...
        self.stale = ...
    
    def set_width(self, width):
        self.width = ...
        self.stale = ...
    
    def get_path(self):
        ...
    


class Arrow(Patch):
    """
    An arrow patch.
    """
    def __str__(self):
        ...
    
    _path = ...
    @docstring.dedent_interpd
    def __init__(self, x, y, dx, dy, width=..., **kwargs):
        """
        Draws an arrow from (*x*, *y*) to (*x* + *dx*, *y* + *dy*).
        The width of the arrow is scaled by *width*.

        Parameters
        ----------
        x : scalar
            x coordinate of the arrow tail
        y : scalar
            y coordinate of the arrow tail
        dx : scalar
            Arrow length in the x direction
        dy : scalar
            Arrow length in the y direction
        width : scalar, optional (default: 1)
            Scale factor for the width of the arrow. With a default value of
            1, the tail width is 0.2 and head width is 0.6.
        **kwargs :
            Keyword arguments control the :class:`~matplotlib.patches.Patch`
            properties:

            %(Patch)s

        See Also
        --------
        :class:`FancyArrow` :
            Patch that allows independent control of the head and tail
            properties
        """
        ...
    
    def get_path(self):
        ...
    
    def get_patch_transform(self):
        ...
    


class FancyArrow(Polygon):
    """
    Like Arrow, but lets you set head width and head height independently.
    """
    _edge_default = ...
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, x, y, dx, dy, width=..., length_includes_head: bool = ..., head_width: Optional[Any] = ..., head_length: Optional[Any] = ..., shape=..., overhang=..., head_starts_at_zero: bool = ..., **kwargs):
        """
        Constructor arguments
          *width*: float (default: 0.001)
            width of full arrow tail

          *length_includes_head*: bool (default: False)
            True if head is to be counted in calculating the length.

          *head_width*: float or None (default: 3*width)
            total width of the full arrow head

          *head_length*: float or None (default: 1.5 * head_width)
            length of arrow head

          *shape*: ['full', 'left', 'right'] (default: 'full')
            draw the left-half, right-half, or full arrow

          *overhang*: float (default: 0)
            fraction that the arrow is swept back (0 overhang means
            triangular shape). Can be negative or greater than one.

          *head_starts_at_zero*: bool (default: False)
            if True, the head starts being drawn at coordinate 0
            instead of ending at coordinate 0.

        Other valid kwargs (inherited from :class:`Patch`) are:
        %(Patch)s

        """
        ...
    


class YAArrow(Patch):
    """
    Yet another arrow class.

    This is an arrow that is defined in display space and has a tip at
    *x1*, *y1* and a base at *x2*, *y2*.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, figure, xytip, xybase, width=..., frac=..., headwidth=..., **kwargs):
        """
        Constructor arguments:

        *xytip*
          (*x*, *y*) location of arrow tip

        *xybase*
          (*x*, *y*) location the arrow base mid point

        *figure*
          The :class:`~matplotlib.figure.Figure` instance
          (fig.dpi)

        *width*
          The width of the arrow in points

        *frac*
          The fraction of the arrow length occupied by the head

        *headwidth*
          The width of the base of the arrow head in points

        Valid kwargs are:
        %(Patch)s

        """
        self.xytip = ...
        self.xybase = ...
        self.width = ...
        self.frac = ...
        self.headwidth = ...
        self.figure = ...
    
    def get_path(self):
        ...
    
    def get_patch_transform(self):
        ...
    
    def getpoints(self, x1, y1, x2, y2, k):
        """
        For line segment defined by (*x1*, *y1*) and (*x2*, *y2*)
        return the points on the line that is perpendicular to the
        line and intersects (*x2*, *y2*) and the distance from (*x2*,
        *y2*) of the returned points is *k*.
        """
        ...
    


class CirclePolygon(RegularPolygon):
    """
    A polygon-approximation of a circle patch.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, radius=..., resolution=..., **kwargs):
        """
        Create a circle at *xy* = (*x*, *y*) with given *radius*.
        This circle is approximated by a regular polygon with
        *resolution* sides.  For a smoother circle drawn with splines,
        see :class:`~matplotlib.patches.Circle`.

        Valid kwargs are:
        %(Patch)s

        """
        ...
    


class Ellipse(Patch):
    """
    A scale-free ellipse.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, width, height, angle=..., **kwargs):
        """
        *xy*
          center of ellipse

        *width*
          total length (diameter) of horizontal axis

        *height*
          total length (diameter) of vertical axis

        *angle*
          rotation in degrees (anti-clockwise)

        Valid kwargs are:
        %(Patch)s
        """
        self.center = ...
        self.angle = ...
    
    def _recompute_transform(self):
        """NOTE: This cannot be called until after this has been added
                 to an Axes, otherwise unit conversion will fail. This
                 makes it very important to call the accessor method and
                 not directly access the transformation member variable.
        """
        ...
    
    def get_path(self):
        """
        Return the vertices of the rectangle
        """
        ...
    
    def get_patch_transform(self):
        ...
    


class Circle(Ellipse):
    """
    A circle patch.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, radius=..., **kwargs):
        """
        Create true circle at center *xy* = (*x*, *y*) with given
        *radius*.  Unlike :class:`~matplotlib.patches.CirclePolygon`
        which is a polygonal approximation, this uses BÃ©zier splines
        and is much closer to a scale-free circle.

        Valid kwargs are:
        %(Patch)s

        """
        self.radius = ...
    
    def set_radius(self, radius):
        """
        Set the radius of the circle

        ACCEPTS: float
        """
        self.width = ...
        self.stale = ...
    
    def get_radius(self):
        'return the radius of the circle'
        ...
    
    radius = ...


class Arc(Ellipse):
    """
    An elliptical arc.  Because it performs various optimizations, it
    can not be filled.

    The arc must be used in an :class:`~matplotlib.axes.Axes`
    instance---it can not be added directly to a
    :class:`~matplotlib.figure.Figure`---because it is optimized to
    only render the segments that are inside the axes bounding box
    with high resolution.
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, width, height, angle=..., theta1=..., theta2=..., **kwargs):
        """
        The following args are supported:

        *xy*
          center of ellipse

        *width*
          length of horizontal axis

        *height*
          length of vertical axis

        *angle*
          rotation in degrees (anti-clockwise)

        *theta1*
          starting angle of the arc in degrees

        *theta2*
          ending angle of the arc in degrees

        If *theta1* and *theta2* are not provided, the arc will form a
        complete ellipse.

        Valid kwargs are:

        %(Patch)s
        """
        self.theta1 = ...
        self.theta2 = ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        """
        Ellipses are normally drawn using an approximation that uses
        eight cubic bezier splines.  The error of this approximation
        is 1.89818e-6, according to this unverified source:

          Lancaster, Don.  Approximating a Circle or an Ellipse Using
          Four Bezier Cubic Splines.

          http://www.tinaja.com/glib/ellipse4.pdf

        There is a use case where very large ellipses must be drawn
        with very high accuracy, and it is too expensive to render the
        entire ellipse with enough segments (either splines or line
        segments).  Therefore, in the case where either radius of the
        ellipse is large enough that the error of the spline
        approximation will be visible (greater than one pixel offset
        from the ideal), a different technique is used.

        In that case, only the visible parts of the ellipse are drawn,
        with each visible arc using a fixed number of spline segments
        (8).  The algorithm proceeds as follows:

          1. The points where the ellipse intersects the axes bounding
             box are located.  (This is done be performing an inverse
             transformation on the axes bbox such that it is relative
             to the unit circle -- this makes the intersection
             calculation much easier than doing rotated ellipse
             intersection directly).

             This uses the "line intersecting a circle" algorithm
             from:

               Vince, John.  Geometry for Computer Graphics: Formulae,
               Examples & Proofs.  London: Springer-Verlag, 2005.

          2. The angles of each of the intersection points are
             calculated.

          3. Proceeding counterclockwise starting in the positive
             x-direction, each of the visible arc-segments between the
             pairs of vertices are drawn using the bezier arc
             approximation technique implemented in
             :meth:`matplotlib.path.Path.arc`.
        """
        ...
    


def bbox_artist(artist, renderer, props: Optional[Any] = ..., fill: bool = ...):
    """
    This is a debug function to draw a rectangle around the bounding
    box returned by
    :meth:`~matplotlib.artist.Artist.get_window_extent` of an artist,
    to test whether the artist is returning the correct bbox.

    *props* is a dict of rectangle props with the additional property
    'pad' that sets the padding around the bbox in points.
    """
    ...

def draw_bbox(bbox, renderer, color=..., trans: Optional[Any] = ...):
    """
    This is a debug function to draw a rectangle around the bounding
    box returned by
    :meth:`~matplotlib.artist.Artist.get_window_extent` of an artist,
    to test whether the artist is returning the correct bbox.
    """
    ...

def _pprint_table(_table, leadingspace=...):
    """
    Given the list of list of strings, return a string of REST table format.
    """
    ...

def _pprint_styles(_styles):
    """
    A helper function for the _Style class.  Given the dictionary of
    (stylename : styleclass), return a formatted string listing all the
    styles. Used to update the documentation.
    """
    ...

def _simpleprint_styles(_styles):
    """
    A helper function for the _Style class.  Given the dictionary of
    (stylename : styleclass), return a string rep of the list of keys.
    Used to update the documentation.
    """
    ...

class _Style(object):
    """
    A base class for the Styles. It is meant to be a container class,
    where actual styles are declared as subclass of it, and it
    provides some helper functions.
    """
    def __new__(self, stylename, **kw):
        """
        return the instance of the subclass with the given style name.
        """
        ...
    
    @classmethod
    def get_styles(klass):
        """
        A class method which returns a dictionary of available styles.
        """
        ...
    
    @classmethod
    def pprint_styles(klass):
        """
        A class method which returns a string of the available styles.
        """
        ...
    
    @classmethod
    def register(klass, name, style):
        """
        Register a new style.
        """
        ...
    


class BoxStyle(_Style):
    """
    :class:`BoxStyle` is a container class which defines several
    boxstyle classes, which are used for :class:`FancyBboxPatch`.

    A style object can be created as::

           BoxStyle.Round(pad=0.2)

    or::

           BoxStyle("Round", pad=0.2)

    or::

           BoxStyle("Round, pad=0.2")

    Following boxstyle classes are defined.

    %(AvailableBoxstyles)s

    An instance of any boxstyle class is an callable object,
    whose call signature is::

       __call__(self, x0, y0, width, height, mutation_size, aspect_ratio=1.)

    and returns a :class:`Path` instance. *x0*, *y0*, *width* and
    *height* specify the location and size of the box to be
    drawn. *mutation_scale* determines the overall size of the
    mutation (by which I mean the transformation of the rectangle to
    the fancy box).  *mutation_aspect* determines the aspect-ratio of
    the mutation.
    """
    _style_list = ...
    class _Base(object):
        """
        :class:`BBoxTransmuterBase` and its derivatives are used to make a
        fancy box around a given rectangle. The :meth:`__call__` method
        returns the :class:`~matplotlib.path.Path` of the fancy box. This
        class is not an artist and actual drawing of the fancy box is done
        by the :class:`FancyBboxPatch` class.
        """
        def __init__(self):
            """
            initializtion.
            """
            ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            """
            The transmute method is a very core of the
            :class:`BboxTransmuter` class and must be overridden in the
            subclasses. It receives the location and size of the
            rectangle, and the mutation_size, with which the amount of
            padding and etc. will be scaled. It returns a
            :class:`~matplotlib.path.Path` instance.
            """
            ...
        
        def __call__(self, x0, y0, width, height, mutation_size, aspect_ratio=...):
            """
            Given the location and size of the box, return the path of
            the box around it.

              - *x0*, *y0*, *width*, *height* : location and size of the box
              - *mutation_size* : a reference scale for the mutation.
              - *aspect_ratio* : aspect-ration for the mutation.
            """
            ...
        
        def __reduce__(self):
            ...
        
    
    
    class Square(_Base):
        """
        A simple square box.
        """
        def __init__(self, pad=...):
            """
             *pad*
                amount of padding
            """
            self.pad = ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class Circle(_Base):
        """A simple circle box."""
        def __init__(self, pad=...):
            """
            Parameters
            ----------
            pad : float
                The amount of padding around the original box.
            """
            self.pad = ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class LArrow(_Base):
        """
        (left) Arrow Box
        """
        def __init__(self, pad=...):
            self.pad = ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class RArrow(LArrow):
        """
        (right) Arrow Box
        """
        def __init__(self, pad=...):
            ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class DArrow(_Base):
        """
        (Double) Arrow Box
        """
        def __init__(self, pad=...):
            self.pad = ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class Round(_Base):
        """
        A box with round corners.
        """
        def __init__(self, pad=..., rounding_size: Optional[Any] = ...):
            """
            *pad*
              amount of padding

            *rounding_size*
              rounding radius of corners. *pad* if None
            """
            self.pad = ...
            self.rounding_size = ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class Round4(_Base):
        """
        Another box with round edges.
        """
        def __init__(self, pad=..., rounding_size: Optional[Any] = ...):
            """
            *pad*
              amount of padding

            *rounding_size*
              rounding size of edges. *pad* if None
            """
            self.pad = ...
            self.rounding_size = ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class Sawtooth(_Base):
        """
        A sawtooth box.
        """
        def __init__(self, pad=..., tooth_size: Optional[Any] = ...):
            """
            *pad*
              amount of padding

            *tooth_size*
              size of the sawtooth. pad* if None
            """
            self.pad = ...
            self.tooth_size = ...
        
        def _get_sawtooth_vertices(self, x0, y0, width, height, mutation_size):
            ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    class Roundtooth(Sawtooth):
        """A rounded tooth box."""
        def __init__(self, pad=..., tooth_size: Optional[Any] = ...):
            """
            *pad*
              amount of padding

            *tooth_size*
              size of the sawtooth. pad* if None
            """
            ...
        
        def transmute(self, x0, y0, width, height, mutation_size):
            ...
        
    
    
    if __doc__:
        __doc__ = ...


class FancyBboxPatch(Patch):
    """
    Draw a fancy box around a rectangle with lower left at *xy*=(*x*,
    *y*) with specified width and height.

    :class:`FancyBboxPatch` class is similar to :class:`Rectangle`
    class, but it draws a fancy box around the rectangle. The
    transformation of the rectangle box to the fancy box is delegated
    to the :class:`BoxTransmuterBase` and its derived classes.

    """
    _edge_default = ...
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xy, width, height, boxstyle=..., bbox_transmuter: Optional[Any] = ..., mutation_scale=..., mutation_aspect: Optional[Any] = ..., **kwargs):
        """
        *xy* = lower left corner

        *width*, *height*

        *boxstyle* determines what kind of fancy box will be drawn. It
        can be a string of the style name with a comma separated
        attribute, or an instance of :class:`BoxStyle`. Following box
        styles are available.

        %(AvailableBoxstyles)s

        *mutation_scale* : a value with which attributes of boxstyle
        (e.g., pad) will be scaled. default=1.

        *mutation_aspect* : The height of the rectangle will be
        squeezed by this value before the mutation and the mutated
        box will be stretched by the inverse of it. default=None.

        Valid kwargs are:
        %(Patch)s
        """
        self.stale = ...
    
    @docstring.dedent_interpd
    def set_boxstyle(self, boxstyle: Optional[Any] = ..., **kw):
        """
        Set the box style.

        *boxstyle* can be a string with boxstyle name with optional
        comma-separated attributes. Alternatively, the attrs can
        be provided as keywords::

            set_boxstyle("round,pad=0.2")
            set_boxstyle("round", pad=0.2)

        Old attrs simply are forgotten.

        Without argument (or with *boxstyle* = None), it returns
        available box styles.

        The following boxstyles are available:
        %(AvailableBoxstyles)s

        ACCEPTS: %(ListBoxstyles)s

        """
        self.stale = ...
    
    def set_mutation_scale(self, scale):
        """
        Set the mutation scale.

        ACCEPTS: float
        """
        self.stale = ...
    
    def get_mutation_scale(self):
        """
        Return the mutation scale.
        """
        ...
    
    def set_mutation_aspect(self, aspect):
        """
        Set the aspect ratio of the bbox mutation.

        ACCEPTS: float
        """
        self.stale = ...
    
    def get_mutation_aspect(self):
        """
        Return the aspect ratio of the bbox mutation.
        """
        ...
    
    def get_boxstyle(self):
        "Return the boxstyle object"
        ...
    
    def get_path(self):
        """
        Return the mutated path of the rectangle
        """
        ...
    
    def get_x(self):
        "Return the left coord of the rectangle"
        ...
    
    def get_y(self):
        "Return the bottom coord of the rectangle"
        ...
    
    def get_width(self):
        "Return the width of the  rectangle"
        ...
    
    def get_height(self):
        "Return the height of the rectangle"
        ...
    
    def set_x(self, x):
        """
        Set the left coord of the rectangle

        ACCEPTS: float
        """
        self.stale = ...
    
    def set_y(self, y):
        """
        Set the bottom coord of the rectangle

        ACCEPTS: float
        """
        self.stale = ...
    
    def set_width(self, w):
        """
        Set the width rectangle

        ACCEPTS: float
        """
        self.stale = ...
    
    def set_height(self, h):
        """
        Set the width rectangle

        ACCEPTS: float
        """
        self.stale = ...
    
    def set_bounds(self, *args):
        """
        Set the bounds of the rectangle: l,b,w,h

        ACCEPTS: (left, bottom, width, height)
        """
        self.stale = ...
    
    def get_bbox(self):
        ...
    


class ConnectionStyle(_Style):
    """
    :class:`ConnectionStyle` is a container class which defines
    several connectionstyle classes, which is used to create a path
    between two points. These are mainly used with
    :class:`FancyArrowPatch`.

    A connectionstyle object can be either created as::

           ConnectionStyle.Arc3(rad=0.2)

    or::

           ConnectionStyle("Arc3", rad=0.2)

    or::

           ConnectionStyle("Arc3, rad=0.2")

    The following classes are defined

    %(AvailableConnectorstyles)s


    An instance of any connection style class is an callable object,
    whose call signature is::

        __call__(self, posA, posB,
                 patchA=None, patchB=None,
                 shrinkA=2., shrinkB=2.)

    and it returns a :class:`Path` instance. *posA* and *posB* are
    tuples of x,y coordinates of the two points to be
    connected. *patchA* (or *patchB*) is given, the returned path is
    clipped so that it start (or end) from the boundary of the
    patch. The path is further shrunk by *shrinkA* (or *shrinkB*)
    which is given in points.

    """
    _style_list = ...
    class _Base(object):
        """
        A base class for connectionstyle classes. The subclass needs
        to implement a *connect* method whose call signature is::

          connect(posA, posB)

        where posA and posB are tuples of x, y coordinates to be
        connected.  The method needs to return a path connecting two
        points. This base class defines a __call__ method, and a few
        helper methods.
        """
        class SimpleEvent:
            def __init__(self, xy):
                ...
            
        
        
        def _clip(self, path, patchA, patchB):
            """
            Clip the path to the boundary of the patchA and patchB.
            The starting point of the path needed to be inside of the
            patchA and the end point inside the patch B. The *contains*
            methods of each patch object is utilized to test if the point
            is inside the path.
            """
            ...
        
        def _shrink(self, path, shrinkA, shrinkB):
            """
            Shrink the path by fixed size (in points) with shrinkA and shrinkB
            """
            ...
        
        def __call__(self, posA, posB, shrinkA=..., shrinkB=..., patchA: Optional[Any] = ..., patchB: Optional[Any] = ...):
            """
            Calls the *connect* method to create a path between *posA*
             and *posB*. The path is clipped and shrunken.
            """
            ...
        
        def __reduce__(self):
            ...
        
    
    
    class Arc3(_Base):
        """
        Creates a simple quadratic bezier curve between two
        points. The curve is created so that the middle control point
        (C1) is located at the same distance from the start (C0) and
        end points(C2) and the distance of the C1 to the line
        connecting C0-C2 is *rad* times the distance of C0-C2.
        """
        def __init__(self, rad=...):
            """
            *rad*
              curvature of the curve.
            """
            self.rad = ...
        
        def connect(self, posA, posB):
            ...
        
    
    
    class Angle3(_Base):
        """
        Creates a simple quadratic bezier curve between two
        points. The middle control points is placed at the
        intersecting point of two lines which crosses the start (or
        end) point and has a angle of angleA (or angleB).
        """
        def __init__(self, angleA=..., angleB=...):
            """
            *angleA*
              starting angle of the path

            *angleB*
              ending angle of the path
            """
            self.angleA = ...
            self.angleB = ...
        
        def connect(self, posA, posB):
            ...
        
    
    
    class Angle(_Base):
        """
        Creates a picewise continuous quadratic bezier path between
        two points. The path has a one passing-through point placed at
        the intersecting point of two lines which crosses the start
        (or end) point and has a angle of angleA (or angleB).  The
        connecting edges are rounded with *rad*.
        """
        def __init__(self, angleA=..., angleB=..., rad=...):
            """
            *angleA*
              starting angle of the path

            *angleB*
              ending angle of the path

            *rad*
              rounding radius of the edge
            """
            self.angleA = ...
            self.angleB = ...
            self.rad = ...
        
        def connect(self, posA, posB):
            ...
        
    
    
    class Arc(_Base):
        """
        Creates a picewise continuous quadratic bezier path between
        two points. The path can have two passing-through points, a
        point placed at the distance of armA and angle of angleA from
        point A, another point with respect to point B. The edges are
        rounded with *rad*.
        """
        def __init__(self, angleA=..., angleB=..., armA: Optional[Any] = ..., armB: Optional[Any] = ..., rad=...):
            """
            *angleA* :
              starting angle of the path

            *angleB* :
              ending angle of the path

            *armA* :
              length of the starting arm

            *armB* :
              length of the ending arm

            *rad* :
              rounding radius of the edges
            """
            self.angleA = ...
            self.angleB = ...
            self.armA = ...
            self.armB = ...
            self.rad = ...
        
        def connect(self, posA, posB):
            ...
        
    
    
    class Bar(_Base):
        """
        A line with *angle* between A and B with *armA* and
        *armB*. One of the arms is extended so that they are connected in
        a right angle. The length of armA is determined by (*armA*
        + *fraction* x AB distance). Same for armB.
        """
        def __init__(self, armA=..., armB=..., fraction=..., angle: Optional[Any] = ...):
            """
            Parameters
            ----------
            armA : float
                minimum length of armA

            armB : float
                minimum length of armB

            fraction : float
                a fraction of the distance between two points that
                will be added to armA and armB.

            angle : float or None
                angle of the connecting line (if None, parallel
                to A and B)
            """
            self.armA = ...
            self.armB = ...
            self.fraction = ...
            self.angle = ...
        
        def connect(self, posA, posB):
            ...
        
    
    
    if __doc__:
        __doc__ = ...


def _point_along_a_line(x0, y0, x1, y1, d):
    """
    find a point along a line connecting (x0, y0) -- (x1, y1) whose
    distance from (x0, y0) is d.
    """
    ...

class ArrowStyle(_Style):
    """
    :class:`ArrowStyle` is a container class which defines several
    arrowstyle classes, which is used to create an arrow path along a
    given path. These are mainly used with :class:`FancyArrowPatch`.

    A arrowstyle object can be either created as::

           ArrowStyle.Fancy(head_length=.4, head_width=.4, tail_width=.4)

    or::

           ArrowStyle("Fancy", head_length=.4, head_width=.4, tail_width=.4)

    or::

           ArrowStyle("Fancy, head_length=.4, head_width=.4, tail_width=.4")

    The following classes are defined

    %(AvailableArrowstyles)s


    An instance of any arrow style class is a callable object,
    whose call signature is::

        __call__(self, path, mutation_size, linewidth, aspect_ratio=1.)

    and it returns a tuple of a :class:`Path` instance and a boolean
    value. *path* is a :class:`Path` instance along which the arrow
    will be drawn. *mutation_size* and *aspect_ratio* have the same
    meaning as in :class:`BoxStyle`. *linewidth* is a line width to be
    stroked. This is meant to be used to correct the location of the
    head so that it does not overshoot the destination point, but not all
    classes support it.
    """
    _style_list = ...
    class _Base(object):
        """
        Arrow Transmuter Base class

        ArrowTransmuterBase and its derivatives are used to make a fancy
        arrow around a given path. The __call__ method returns a path
        (which will be used to create a PathPatch instance) and a boolean
        value indicating the path is open therefore is not fillable.  This
        class is not an artist and actual drawing of the fancy arrow is
        done by the FancyArrowPatch class.

        """
        @staticmethod
        def ensure_quadratic_bezier(path):
            """ Some ArrowStyle class only wokrs with a simple
            quaratic bezier curve (created with Arc3Connetion or
            Angle3Connector). This static method is to check if the
            provided path is a simple quadratic bezier curve and returns
            its control points if true.
            """
            ...
        
        def transmute(self, path, mutation_size, linewidth):
            """
            The transmute method is the very core of the ArrowStyle
            class and must be overridden in the subclasses. It receives
            the path object along which the arrow will be drawn, and
            the mutation_size, with which the arrow head etc.
            will be scaled. The linewidth may be used to adjust
            the path so that it does not pass beyond the given
            points. It returns a tuple of a Path instance and a
            boolean. The boolean value indicate whether the path can
            be filled or not. The return value can also be a list of paths
            and list of booleans of a same length.
            """
            ...
        
        def __call__(self, path, mutation_size, linewidth, aspect_ratio=...):
            """
            The __call__ method is a thin wrapper around the transmute method
            and take care of the aspect ratio.
            """
            ...
        
        def __reduce__(self):
            ...
        
    
    
    class _Curve(_Base):
        """
        A simple arrow which will work with any path instance. The
        returned path is simply concatenation of the original path + at
        most two paths representing the arrow head at the begin point and the
        at the end point. The arrow heads can be either open or closed.
        """
        def __init__(self, beginarrow: Optional[Any] = ..., endarrow: Optional[Any] = ..., fillbegin: bool = ..., fillend: bool = ..., head_length=..., head_width=...):
            """
            The arrows are drawn if *beginarrow* and/or *endarrow* are
            true. *head_length* and *head_width* determines the size
            of the arrow relative to the *mutation scale*.  The
            arrowhead at the begin (or end) is closed if fillbegin (or
            fillend) is True.
            """
            ...
        
        def _get_arrow_wedge(self, x0, y0, x1, y1, head_dist, cos_t, sin_t, linewidth):
            """
            Return the paths for arrow heads. Since arrow lines are
            drawn with capstyle=projected, The arrow goes beyond the
            desired point. This method also returns the amount of the path
            to be shrunken so that it does not overshoot.
            """
            ...
        
        def transmute(self, path, mutation_size, linewidth):
            ...
        
    
    
    class Curve(_Curve):
        """
        A simple curve without any arrow head.
        """
        def __init__(self):
            ...
        
    
    
    class CurveA(_Curve):
        """
        An arrow with a head at its begin point.
        """
        def __init__(self, head_length=..., head_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.4
                Length of the arrow head

            head_width : float, optional, default : 0.2
                Width of the arrow head
            """
            ...
        
    
    
    class CurveB(_Curve):
        """
        An arrow with a head at its end point.
        """
        def __init__(self, head_length=..., head_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.4
                Length of the arrow head

            head_width : float, optional, default : 0.2
                Width of the arrow head
            """
            ...
        
    
    
    class CurveAB(_Curve):
        """
        An arrow with heads both at the begin and the end point.
        """
        def __init__(self, head_length=..., head_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.4
                Length of the arrow head

            head_width : float, optional, default : 0.2
                Width of the arrow head
            """
            ...
        
    
    
    class CurveFilledA(_Curve):
        """
        An arrow with filled triangle head at the begin.
        """
        def __init__(self, head_length=..., head_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.4
                Length of the arrow head

            head_width : float, optional, default : 0.2
                Width of the arrow head
            """
            ...
        
    
    
    class CurveFilledB(_Curve):
        """
        An arrow with filled triangle head at the end.
        """
        def __init__(self, head_length=..., head_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.4
                Length of the arrow head

            head_width : float, optional, default : 0.2
                Width of the arrow head
            """
            ...
        
    
    
    class CurveFilledAB(_Curve):
        """
        An arrow with filled triangle heads at both ends.
        """
        def __init__(self, head_length=..., head_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.4
                Length of the arrow head

            head_width : float, optional, default : 0.2
                Width of the arrow head
            """
            ...
        
    
    
    class _Bracket(_Base):
        def __init__(self, bracketA: Optional[Any] = ..., bracketB: Optional[Any] = ..., widthA=..., widthB=..., lengthA=..., lengthB=..., angleA: Optional[Any] = ..., angleB: Optional[Any] = ..., scaleA: Optional[Any] = ..., scaleB: Optional[Any] = ...):
            ...
        
        def _get_bracket(self, x0, y0, cos_t, sin_t, width, length):
            ...
        
        def transmute(self, path, mutation_size, linewidth):
            ...
        
    
    
    class BracketAB(_Bracket):
        """
        An arrow with a bracket(]) at both ends.
        """
        def __init__(self, widthA=..., lengthA=..., angleA: Optional[Any] = ..., widthB=..., lengthB=..., angleB: Optional[Any] = ...):
            """
            Parameters
            ----------
            widthA : float, optional, default : 1.0
                Width of the bracket

            lengthA : float, optional, default : 0.2
                Length of the bracket

            angleA : float, optional, default : None
                Angle between the bracket and the line

            widthB : float, optional, default : 1.0
                Width of the bracket

            lengthB : float, optional, default : 0.2
                Length of the bracket

            angleB : float, optional, default : None
                Angle between the bracket and the line
            """
            ...
        
    
    
    class BracketA(_Bracket):
        """
        An arrow with a bracket(])  at its end.
        """
        def __init__(self, widthA=..., lengthA=..., angleA: Optional[Any] = ...):
            """
            Parameters
            ----------
            widthA : float, optional, default : 1.0
                Width of the bracket

            lengthA : float, optional, default : 0.2
                Length of the bracket

            angleA : float, optional, default : None
                Angle between the bracket and the line
            """
            ...
        
    
    
    class BracketB(_Bracket):
        """
        An arrow with a bracket([)  at its end.
        """
        def __init__(self, widthB=..., lengthB=..., angleB: Optional[Any] = ...):
            """
            Parameters
            ----------
            widthB : float, optional, default : 1.0
                Width of the bracket

            lengthB : float, optional, default : 0.2
                Length of the bracket

            angleB : float, optional, default : None
                Angle between the bracket and the line
            """
            ...
        
    
    
    class BarAB(_Bracket):
        """
        An arrow with a bar(|) at both ends.
        """
        def __init__(self, widthA=..., angleA: Optional[Any] = ..., widthB=..., angleB: Optional[Any] = ...):
            """
            Parameters
            ----------
            widthA : float, optional, default : 1.0
                Width of the bracket

            angleA : float, optional, default : None
                Angle between the bracket and the line

            widthB : float, optional, default : 1.0
                Width of the bracket

            angleB : float, optional, default : None
                Angle between the bracket and the line
            """
            ...
        
    
    
    class Simple(_Base):
        """
        A simple arrow. Only works with a quadratic bezier curve.
        """
        def __init__(self, head_length=..., head_width=..., tail_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.5
                Length of the arrow head

            head_width : float, optional, default : 0.5
                Width of the arrow head

            tail_width : float, optional, default : 0.2
                Width of the arrow tail
            """
            ...
        
        def transmute(self, path, mutation_size, linewidth):
            ...
        
    
    
    class Fancy(_Base):
        """
        A fancy arrow. Only works with a quadratic bezier curve.
        """
        def __init__(self, head_length=..., head_width=..., tail_width=...):
            """
            Parameters
            ----------
            head_length : float, optional, default : 0.4
                Length of the arrow head

            head_width : float, optional, default : 0.4
                Width of the arrow head

            tail_width : float, optional, default : 0.4
                Width of the arrow tail
            """
            ...
        
        def transmute(self, path, mutation_size, linewidth):
            ...
        
    
    
    class Wedge(_Base):
        """
        Wedge(?) shape. Only works with a quadratic bezier curve.  The
        begin point has a width of the tail_width and the end point has a
        width of 0. At the middle, the width is shrink_factor*tail_width.
        """
        def __init__(self, tail_width=..., shrink_factor=...):
            """
            Parameters
            ----------
            tail_width : float, optional, default : 0.3
                Width of the tail

            shrink_factor : float, optional, default : 0.5
                Fraction of the arrow width at the middle point
            """
            self.tail_width = ...
            self.shrink_factor = ...
        
        def transmute(self, path, mutation_size, linewidth):
            ...
        
    
    
    if __doc__:
        __doc__ = ...


class FancyArrowPatch(Patch):
    """
    A fancy arrow patch. It draws an arrow using the :class:`ArrowStyle`.

    The head and tail positions are fixed at the specified start and end points
    of the arrow, but the size and shape (in display coordinates) of the arrow
    does not change when the axis is moved or zoomed.
    """
    _edge_default = ...
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, posA: Optional[Any] = ..., posB: Optional[Any] = ..., path: Optional[Any] = ..., arrowstyle=..., arrow_transmuter: Optional[Any] = ..., connectionstyle=..., connector: Optional[Any] = ..., patchA: Optional[Any] = ..., patchB: Optional[Any] = ..., shrinkA=..., shrinkB=..., mutation_scale=..., mutation_aspect: Optional[Any] = ..., dpi_cor=..., **kwargs):
        """
        If *posA* and *posB* are given, a path connecting two points is
        created according to *connectionstyle*. The path will be
        clipped with *patchA* and *patchB* and further shrunken by
        *shrinkA* and *shrinkB*. An arrow is drawn along this
        resulting path using the *arrowstyle* parameter.

        Alternatively if *path* is provided, an arrow is drawn along this path
        and *patchA*, *patchB*, *shrinkA*, and *shrinkB* are ignored.

        Parameters
        ----------

        posA, posB : None, tuple, optional (default: None)
            (x,y) coordinates of arrow tail and arrow head respectively.

        path : None, Path (default: None)
            :class:`matplotlib.path.Path` instance. If provided, an arrow is
            drawn along this path and *patchA*, *patchB*, *shrinkA*, and
            *shrinkB* are ignored.

        arrowstyle : str or ArrowStyle, optional (default: 'simple')
            Describes how the fancy arrow will be
            drawn. It can be string of the available arrowstyle names,
            with optional comma-separated attributes, or an
            :class:`ArrowStyle` instance. The optional attributes are meant to
            be scaled with the *mutation_scale*. The following arrow styles are
            available:

            %(AvailableArrowstyles)s

        arrow_transmuter :
            Ignored

        connectionstyle : str, ConnectionStyle, or None, optional
        (default: 'arc3')
            Describes how *posA* and *posB* are connected. It can be an
            instance of the :class:`ConnectionStyle` class or a string of the
            connectionstyle name, with optional comma-separated attributes. The
            following connection styles are available:

            %(AvailableConnectorstyles)s

        connector :
            Ignored

        patchA, patchB : None, Patch, optional (default: None)
            Head and tail patch respectively. :class:`matplotlib.patch.Patch`
            instance.

        shrinkA, shrinkB : scalar, optional (default: 2)
            Shrinking factor of the tail and head of the arrow respectively

        mutation_scale : scalar, optional (default: 1)
            Value with which attributes of *arrowstyle* (e.g., *head_length*)
            will be scaled.

        mutation_aspect : None, scalar, optional (default: None)
            The height of the rectangle will be squeezed by this value before
            the mutation and the mutated box will be stretched by the inverse
            of it.

        dpi_cor : scalar, optional (default: 1)
            dpi_cor is currently used for linewidth-related things and shrink
            factor. Mutation scale is affected by this.

        Notes
        -----
        Valid kwargs are:
        %(Patch)s
        """
        self.patchA = ...
        self.patchB = ...
        self.shrinkA = ...
        self.shrinkB = ...
    
    def set_dpi_cor(self, dpi_cor):
        """
        dpi_cor is currently used for linewidth-related things and
        shrink factor. Mutation scale is affected by this.

        Parameters
        ----------
        dpi_cor : scalar
        """
        self.stale = ...
    
    def get_dpi_cor(self):
        """
        dpi_cor is currently used for linewidth-related things and
        shrink factor. Mutation scale is affected by this.

        Returns
        -------
        dpi_cor : scalar
        """
        ...
    
    def set_positions(self, posA, posB):
        """
        Set the begin and end positions of the connecting path.

        Parameters
        ----------
        posA, posB : None, tuple
            (x,y) coordinates of arrow tail and arrow head respectively. If
            `None` use current value.
        """
        self.stale = ...
    
    def set_patchA(self, patchA):
        """
        Set the tail patch.

        Parameters
        ----------
        patchA : Patch
            :class:`matplotlib.patch.Patch` instance.
        """
        self.patchA = ...
        self.stale = ...
    
    def set_patchB(self, patchB):
        """
        Set the head patch.

        Parameters
        ----------
        patchB : Patch
            :class:`matplotlib.patch.Patch` instance.
        """
        self.patchB = ...
        self.stale = ...
    
    def set_connectionstyle(self, connectionstyle, **kw):
        """
        Set the connection style. Old attributes are forgotten.

        Parameters
        ----------
        connectionstyle : None, ConnectionStyle instance, or string
            Can be a string with connectionstyle name with
            optional comma-separated attributes, e.g.::

                set_connectionstyle("arc,angleA=0,armA=30,rad=10")

            Alternatively, the attributes can be provided as keywords, e.g.::

                set_connectionstyle("arc", angleA=0,armA=30,rad=10)

            Without any arguments (or with ``connectionstyle=None``), return
            available styles as a list of strings.
        """
        self.stale = ...
    
    def get_connectionstyle(self):
        """
        Return the :class:`ConnectionStyle` instance.
        """
        ...
    
    def set_arrowstyle(self, arrowstyle: Optional[Any] = ..., **kw):
        """
        Set the arrow style. Old attributes are forgotten. Without arguments
        (or with ``arrowstyle=None``) returns available box styles as a list of
        strings.

        Parameters
        ----------
        arrowstyle : None, ArrowStyle, str, optional (default: None)
            Can be a string with arrowstyle name with optional comma-separated
            attributes, e.g.::

                set_arrowstyle("Fancy,head_length=0.2")

            Alternatively attributes can be provided as keywords, e.g.::

                set_arrowstyle("fancy", head_length=0.2)

        """
        self.stale = ...
    
    def get_arrowstyle(self):
        """
        Return the arrowstyle object.
        """
        ...
    
    def set_mutation_scale(self, scale):
        """
        Set the mutation scale.

        Parameters
        ----------
        scale : scalar
        """
        self.stale = ...
    
    def get_mutation_scale(self):
        """
        Return the mutation scale.

        Returns
        -------
        scale : scalar
        """
        ...
    
    def set_mutation_aspect(self, aspect):
        """
        Set the aspect ratio of the bbox mutation.

        Parameters
        ----------
        aspect : scalar
        """
        self.stale = ...
    
    def get_mutation_aspect(self):
        """
        Return the aspect ratio of the bbox mutation.
        """
        ...
    
    def get_path(self):
        """
        Return the path of the arrow in the data coordinates. Use
        get_path_in_displaycoord() method to retrieve the arrow path
        in display coordinates.
        """
        ...
    
    def get_path_in_displaycoord(self):
        """
        Return the mutated path of the arrow in display coordinates.
        """
        ...
    
    def draw(self, renderer):
        self.stale = ...
    


class ConnectionPatch(FancyArrowPatch):
    """
    A :class:`~matplotlib.patches.ConnectionPatch` class is to make
    connecting lines between two points (possibly in different axes).
    """
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, xyA, xyB, coordsA, coordsB: Optional[Any] = ..., axesA: Optional[Any] = ..., axesB: Optional[Any] = ..., arrowstyle=..., arrow_transmuter: Optional[Any] = ..., connectionstyle=..., connector: Optional[Any] = ..., patchA: Optional[Any] = ..., patchB: Optional[Any] = ..., shrinkA=..., shrinkB=..., mutation_scale=..., mutation_aspect: Optional[Any] = ..., clip_on: bool = ..., dpi_cor=..., **kwargs):
        """
        Connect point *xyA* in *coordsA* with point *xyB* in *coordsB*


        Valid keys are


        ===============  ======================================================
        Key              Description
        ===============  ======================================================
        arrowstyle       the arrow style
        connectionstyle  the connection style
        relpos           default is (0.5, 0.5)
        patchA           default is bounding box of the text
        patchB           default is None
        shrinkA          default is 2 points
        shrinkB          default is 2 points
        mutation_scale   default is text size (in points)
        mutation_aspect  default is 1.
        ?                any key for :class:`matplotlib.patches.PathPatch`
        ===============  ======================================================


        *coordsA* and *coordsB* are strings that indicate the
        coordinates of *xyA* and *xyB*.

        =================   ===================================================
        Property            Description
        =================   ===================================================
        'figure points'     points from the lower left corner of the figure
        'figure pixels'     pixels from the lower left corner of the figure
        'figure fraction'   0,0 is lower left of figure and 1,1 is upper, right
        'axes points'       points from lower left corner of axes
        'axes pixels'       pixels from lower left corner of axes
        'axes fraction'     0,1 is lower left of axes and 1,1 is upper right
        'data'              use the coordinate system of the object being
                            annotated (default)
        'offset points'     Specify an offset (in points) from the *xy* value

        'polar'             you can specify *theta*, *r* for the annotation,
                            even in cartesian plots.  Note that if you
                            are using a polar axes, you do not need
                            to specify polar for the coordinate
                            system since that is the native "data" coordinate
                            system.
        =================   ===================================================

        """
        self.xy1 = ...
        self.xy2 = ...
        self.coords1 = ...
        self.coords2 = ...
        self.axesA = ...
        self.axesB = ...
    
    def _get_xy(self, x, y, s, axes: Optional[Any] = ...):
        """
        calculate the pixel position of given point
        """
        ...
    
    def set_annotation_clip(self, b):
        """
        set *annotation_clip* attribute.

          * True: the annotation will only be drawn when self.xy is inside the
                   axes.
          * False: the annotation will always be drawn regardless of its
                    position.
          * None: the self.xy will be checked only if *xycoords* is "data"
        """
        self.stale = ...
    
    def get_annotation_clip(self):
        """
        Return *annotation_clip* attribute.
        See :meth:`set_annotation_clip` for the meaning of return values.
        """
        ...
    
    def get_path_in_displaycoord(self):
        """
        Return the mutated path of the arrow in the display coord
        """
        ...
    
    def _check_xy(self, renderer):
        """
        check if the annotation need to
        be drawn.
        """
        ...
    
    def draw(self, renderer):
        """
        Draw.
        """
        ...
    


