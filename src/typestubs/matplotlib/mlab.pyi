"""
This type stub file was generated by pyright.
"""

import six
import matplotlib.cbook as cbook
import math
from matplotlib import docstring
from typing import Any, Optional

"""

Numerical python functions written for compatibility with MATLAB
commands with the same names.

MATLAB compatible functions
---------------------------

:func:`cohere`
    Coherence (normalized cross spectral density)

:func:`csd`
    Cross spectral density using Welch's average periodogram

:func:`detrend`
    Remove the mean or best fit line from an array

:func:`find`
    Return the indices where some condition is true;
    numpy.nonzero is similar but more general.

:func:`griddata`
    Interpolate irregularly distributed data to a
    regular grid.

:func:`prctile`
    Find the percentiles of a sequence

:func:`prepca`
    Principal Component Analysis

:func:`psd`
    Power spectral density using Welch's average periodogram

:func:`rk4`
    A 4th order runge kutta integrator for 1D or ND systems

:func:`specgram`
    Spectrogram (spectrum over segments of time)

Miscellaneous functions
-----------------------

Functions that don't exist in MATLAB, but are useful anyway:

:func:`cohere_pairs`
    Coherence over all pairs.  This is not a MATLAB function, but we
    compute coherence a lot in my lab, and we compute it for a lot of
    pairs.  This function is optimized to do this efficiently by
    caching the direct FFTs.

:func:`rk4`
    A 4th order Runge-Kutta ODE integrator in case you ever find
    yourself stranded without scipy (and the far superior
    scipy.integrate tools)

:func:`contiguous_regions`
    Return the indices of the regions spanned by some logical mask

:func:`cross_from_below`
    Return the indices where a 1D array crosses a threshold from below

:func:`cross_from_above`
    Return the indices where a 1D array crosses a threshold from above

:func:`complex_spectrum`
    Return the complex-valued frequency spectrum of a signal

:func:`magnitude_spectrum`
    Return the magnitude of the frequency spectrum of a signal

:func:`angle_spectrum`
    Return the angle (wrapped phase) of the frequency spectrum of a signal

:func:`phase_spectrum`
    Return the phase (unwrapped angle) of the frequency spectrum of a signal

:func:`detrend_mean`
    Remove the mean from a line.

:func:`demean`
    Remove the mean from a line. This function is the same as
    :func:`detrend_mean` except for the default *axis*.

:func:`detrend_linear`
    Remove the best fit line from a line.

:func:`detrend_none`
    Return the original line.

:func:`stride_windows`
    Get all windows in an array in a memory-efficient manner

:func:`stride_repeat`
    Repeat an array in a memory-efficient manner

:func:`apply_window`
    Apply a window along a given axis


record array helper functions
-----------------------------

A collection of helper methods for numpyrecord arrays

.. _htmlonly:

    See :ref:`misc-examples-index`

:func:`rec2txt`
    Pretty print a record array

:func:`rec2csv`
    Store record array in CSV file

:func:`csv2rec`
    Import record array from CSV file with type inspection

:func:`rec_append_fields`
    Adds  field(s)/array(s) to record array

:func:`rec_drop_fields`
    Drop fields from record array

:func:`rec_join`
    Join two record arrays on sequence of fields

:func:`recs_join`
    A simple join of multiple recarrays using a single column as a key

:func:`rec_groupby`
    Summarize data by groups (similar to SQL GROUP BY)

:func:`rec_summarize`
    Helper code to filter rec array fields into new fields

For the rec viewer functions(e rec2csv), there are a bunch of Format
objects you can pass into the functions that will do things like color
negative values red, set percent formatting and scaling, etc.

Example usage::

    r = csv2rec('somefile.csv', checkrows=0)

    formatd = dict(
        weight = FormatFloat(2),
        change = FormatPercent(2),
        cost   = FormatThousands(2),
        )


    rec2excel(r, 'test.xls', formatd=formatd)
    rec2csv(r, 'test.csv', formatd=formatd)
    scroll = rec2gtk(r, formatd=formatd)

    win = gtk.Window()
    win.set_size_request(600,800)
    win.add(scroll)
    win.show_all()
    gtk.main()


"""
if six.PY3:
    long = int
@cbook.deprecated("2.2", alternative='numpy.logspace or numpy.geomspace')
def logspace(xmin, xmax, N):
    '''
    Return N values logarithmically spaced between xmin and xmax.

    '''
    ...

def window_hanning(x):
    '''
    Return x times the hanning window of len(x).

    See Also
    --------
    :func:`window_none`
        :func:`window_none` is another window algorithm.
    '''
    ...

def window_none(x):
    '''
    No window function; simply return x.

    See Also
    --------
    :func:`window_hanning`
        :func:`window_hanning` is another window algorithm.
    '''
    ...

def apply_window(x, window, axis=..., return_window: Optional[Any] = ...):
    '''
    Apply the given window to the given 1D or 2D array along the given axis.

    Parameters
    ----------
    x : 1D or 2D array or sequence
        Array or sequence containing the data.

    window : function or array.
        Either a function to generate a window or an array with length
        *x*.shape[*axis*]

    axis : integer
        The axis over which to do the repetition.
        Must be 0 or 1.  The default is 0

    return_window : bool
        If true, also return the 1D values of the window that was applied
    '''
    ...

def detrend(x, key: Optional[Any] = ..., axis: Optional[Any] = ...):
    '''
    Return x with its trend removed.

    Parameters
    ----------
    x : array or sequence
        Array or sequence containing the data.

    key : [ 'default' | 'constant' | 'mean' | 'linear' | 'none'] or function
        Specifies the detrend algorithm to use. 'default' is 'mean', which is
        the same as :func:`detrend_mean`. 'constant' is the same. 'linear' is
        the same as :func:`detrend_linear`. 'none' is the same as
        :func:`detrend_none`. The default is 'mean'. See the corresponding
        functions for more details regarding the algorithms. Can also be a
        function that carries out the detrend operation.

    axis : integer
        The axis along which to do the detrending.

    See Also
    --------
    :func:`detrend_mean`
        :func:`detrend_mean` implements the 'mean' algorithm.

    :func:`detrend_linear`
        :func:`detrend_linear` implements the 'linear' algorithm.

    :func:`detrend_none`
        :func:`detrend_none` implements the 'none' algorithm.
    '''
    ...

def demean(x, axis=...):
    '''
    Return x minus its mean along the specified axis.

    Parameters
    ----------
    x : array or sequence
        Array or sequence containing the data
        Can have any dimensionality

    axis : integer
        The axis along which to take the mean.  See numpy.mean for a
        description of this argument.

    See Also
    --------
    :func:`delinear`

    :func:`denone`
        :func:`delinear` and :func:`denone` are other detrend algorithms.

    :func:`detrend_mean`
        This function is the same as :func:`detrend_mean` except for the
        default *axis*.
    '''
    ...

def detrend_mean(x, axis: Optional[Any] = ...):
    '''
    Return x minus the mean(x).

    Parameters
    ----------
    x : array or sequence
        Array or sequence containing the data
        Can have any dimensionality

    axis : integer
        The axis along which to take the mean.  See numpy.mean for a
        description of this argument.

    See Also
    --------
    :func:`demean`
        This function is the same as :func:`demean` except for the default
        *axis*.

    :func:`detrend_linear`

    :func:`detrend_none`
        :func:`detrend_linear` and :func:`detrend_none` are other detrend
        algorithms.

    :func:`detrend`
        :func:`detrend` is a wrapper around all the detrend algorithms.
    '''
    ...

def detrend_none(x, axis: Optional[Any] = ...):
    '''
    Return x: no detrending.

    Parameters
    ----------
    x : any object
        An object containing the data

    axis : integer
        This parameter is ignored.
        It is included for compatibility with detrend_mean

    See Also
    --------
    :func:`denone`
        This function is the same as :func:`denone` except for the default
        *axis*, which has no effect.

    :func:`detrend_mean`

    :func:`detrend_linear`
        :func:`detrend_mean` and :func:`detrend_linear` are other detrend
        algorithms.

    :func:`detrend`
        :func:`detrend` is a wrapper around all the detrend algorithms.
    '''
    ...

def detrend_linear(y):
    '''
    Return x minus best fit line; 'linear' detrending.

    Parameters
    ----------
    y : 0-D or 1-D array or sequence
        Array or sequence containing the data

    axis : integer
        The axis along which to take the mean.  See numpy.mean for a
        description of this argument.

    See Also
    --------
    :func:`delinear`
        This function is the same as :func:`delinear` except for the default
        *axis*.

    :func:`detrend_mean`

    :func:`detrend_none`
        :func:`detrend_mean` and :func:`detrend_none` are other detrend
        algorithms.

    :func:`detrend`
        :func:`detrend` is a wrapper around all the detrend algorithms.
    '''
    ...

def stride_windows(x, n, noverlap: Optional[Any] = ..., axis=...):
    '''
    Get all windows of x with length n as a single array,
    using strides to avoid data duplication.

    .. warning::

        It is not safe to write to the output array.  Multiple
        elements may point to the same piece of memory,
        so modifying one value may change others.

    Parameters
    ----------
    x : 1D array or sequence
        Array or sequence containing the data.

    n : integer
        The number of data points in each window.

    noverlap : integer
        The overlap between adjacent windows.
        Default is 0 (no overlap)

    axis : integer
        The axis along which the windows will run.

    References
    ----------
    `stackoverflow: Rolling window for 1D arrays in Numpy?
    <http://stackoverflow.com/a/6811241>`_
    `stackoverflow: Using strides for an efficient moving average filter
    <http://stackoverflow.com/a/4947453>`_
    '''
    ...

def stride_repeat(x, n, axis=...):
    '''
    Repeat the values in an array in a memory-efficient manner.  Array x is
    stacked vertically n times.

    .. warning::

        It is not safe to write to the output array.  Multiple
        elements may point to the same piece of memory, so
        modifying one value may change others.

    Parameters
    ----------
    x : 1D array or sequence
        Array or sequence containing the data.

    n : integer
        The number of time to repeat the array.

    axis : integer
        The axis along which the data will run.

    References
    ----------
    `stackoverflow: Repeat NumPy array without replicating data?
    <http://stackoverflow.com/a/5568169>`_
    '''
    ...

def _spectral_helper(x, y: Optional[Any] = ..., NFFT: Optional[Any] = ..., Fs: Optional[Any] = ..., detrend_func: Optional[Any] = ..., window: Optional[Any] = ..., noverlap: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale_by_freq: Optional[Any] = ..., mode: Optional[Any] = ...):
    '''
    This is a helper function that implements the commonality between the
    psd, csd, spectrogram and complex, magnitude, angle, and phase spectrums.
    It is *NOT* meant to be used outside of mlab and may change at any time.
    '''
    ...

def _single_spectrum_helper(x, mode, Fs: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ...):
    '''
    This is a helper function that implements the commonality between the
    complex, magnitude, angle, and phase spectrums.
    It is *NOT* meant to be used outside of mlab and may change at any time.
    '''
    ...

@docstring.dedent_interpd
def psd(x, NFFT: Optional[Any] = ..., Fs: Optional[Any] = ..., detrend: Optional[Any] = ..., window: Optional[Any] = ..., noverlap: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale_by_freq: Optional[Any] = ...):
    r"""
    Compute the power spectral density.

    Call signature::

        psd(x, NFFT=256, Fs=2, detrend=mlab.detrend_none,
            window=mlab.window_hanning, noverlap=0, pad_to=None,
            sides='default', scale_by_freq=None)

    The power spectral density :math:`P_{xx}` by Welch's average
    periodogram method.  The vector *x* is divided into *NFFT* length
    segments.  Each segment is detrended by function *detrend* and
    windowed by function *window*.  *noverlap* gives the length of
    the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
    of each segment :math:`i` are averaged to compute :math:`P_{xx}`.

    If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.

    Parameters
    ----------
    x : 1-D array or sequence
        Array or sequence containing the data

    %(Spectral)s

    %(PSD)s

    noverlap : integer
        The number of points of overlap between segments.
        The default value is 0 (no overlap).

    Returns
    -------
    Pxx : 1-D array
        The values for the power spectrum `P_{xx}` (real valued)

    freqs : 1-D array
        The frequencies corresponding to the elements in *Pxx*

    References
    ----------
    Bendat & Piersol -- Random Data: Analysis and Measurement Procedures, John
    Wiley & Sons (1986)

    See Also
    --------
    :func:`specgram`
        :func:`specgram` differs in the default overlap; in not returning the
        mean of the segment periodograms; and in returning the times of the
        segments.

    :func:`magnitude_spectrum`
        :func:`magnitude_spectrum` returns the magnitude spectrum.

    :func:`csd`
        :func:`csd` returns the spectral density between two signals.
    """
    ...

@docstring.dedent_interpd
def csd(x, y, NFFT: Optional[Any] = ..., Fs: Optional[Any] = ..., detrend: Optional[Any] = ..., window: Optional[Any] = ..., noverlap: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale_by_freq: Optional[Any] = ...):
    """
    Compute the cross-spectral density.

    Call signature::

        csd(x, y, NFFT=256, Fs=2, detrend=mlab.detrend_none,
            window=mlab.window_hanning, noverlap=0, pad_to=None,
            sides='default', scale_by_freq=None)

    The cross spectral density :math:`P_{xy}` by Welch's average
    periodogram method.  The vectors *x* and *y* are divided into
    *NFFT* length segments.  Each segment is detrended by function
    *detrend* and windowed by function *window*.  *noverlap* gives
    the length of the overlap between segments.  The product of
    the direct FFTs of *x* and *y* are averaged over each segment
    to compute :math:`P_{xy}`, with a scaling to correct for power
    loss due to windowing.

    If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
    padded to *NFFT*.

    Parameters
    ----------
    x, y : 1-D arrays or sequences
        Arrays or sequences containing the data

    %(Spectral)s

    %(PSD)s

    noverlap : integer
        The number of points of overlap between segments.
        The default value is 0 (no overlap).

    Returns
    -------
    Pxy : 1-D array
        The values for the cross spectrum `P_{xy}` before scaling (real valued)

    freqs : 1-D array
        The frequencies corresponding to the elements in *Pxy*

    References
    ----------
    Bendat & Piersol -- Random Data: Analysis and Measurement Procedures, John
    Wiley & Sons (1986)

    See Also
    --------
    :func:`psd`
        :func:`psd` is the equivalent to setting y=x.
    """
    ...

@docstring.dedent_interpd
def complex_spectrum(x, Fs: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ...):
    """
    Compute the complex-valued frequency spectrum of *x*.  Data is padded to a
    length of *pad_to* and the windowing function *window* is applied to the
    signal.

    Parameters
    ----------
    x : 1-D array or sequence
        Array or sequence containing the data

    %(Spectral)s

    %(Single_Spectrum)s

    Returns
    -------
    spectrum : 1-D array
        The values for the complex spectrum (complex valued)

    freqs : 1-D array
        The frequencies corresponding to the elements in *spectrum*

    See Also
    --------
    :func:`magnitude_spectrum`
        :func:`magnitude_spectrum` returns the absolute value of this function.

    :func:`angle_spectrum`
        :func:`angle_spectrum` returns the angle of this function.

    :func:`phase_spectrum`
        :func:`phase_spectrum` returns the phase (unwrapped angle) of this
        function.

    :func:`specgram`
        :func:`specgram` can return the complex spectrum of segments within the
        signal.
    """
    ...

@docstring.dedent_interpd
def magnitude_spectrum(x, Fs: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ...):
    """
    Compute the magnitude (absolute value) of the frequency spectrum of
    *x*.  Data is padded to a length of *pad_to* and the windowing function
    *window* is applied to the signal.

    Parameters
    ----------
    x : 1-D array or sequence
        Array or sequence containing the data

    %(Spectral)s

    %(Single_Spectrum)s

    Returns
    -------
    spectrum : 1-D array
        The values for the magnitude spectrum (real valued)

    freqs : 1-D array
        The frequencies corresponding to the elements in *spectrum*

    See Also
    --------
    :func:`psd`
        :func:`psd` returns the power spectral density.

    :func:`complex_spectrum`
        This function returns the absolute value of :func:`complex_spectrum`.

    :func:`angle_spectrum`
        :func:`angle_spectrum` returns the angles of the corresponding
        frequencies.

    :func:`phase_spectrum`
        :func:`phase_spectrum` returns the phase (unwrapped angle) of the
        corresponding frequencies.

    :func:`specgram`
        :func:`specgram` can return the magnitude spectrum of segments within
        the signal.
    """
    ...

@docstring.dedent_interpd
def angle_spectrum(x, Fs: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ...):
    """
    Compute the angle of the frequency spectrum (wrapped phase spectrum) of
    *x*.  Data is padded to a length of *pad_to* and the windowing function
    *window* is applied to the signal.

    Parameters
    ----------
    x : 1-D array or sequence
        Array or sequence containing the data

    %(Spectral)s

    %(Single_Spectrum)s

    Returns
    -------
    spectrum : 1-D array
        The values for the angle spectrum in radians (real valued)

    freqs : 1-D array
        The frequencies corresponding to the elements in *spectrum*

    See Also
    --------
    :func:`complex_spectrum`
        This function returns the angle value of :func:`complex_spectrum`.

    :func:`magnitude_spectrum`
        :func:`angle_spectrum` returns the magnitudes of the corresponding
        frequencies.

    :func:`phase_spectrum`
        :func:`phase_spectrum` returns the unwrapped version of this function.

    :func:`specgram`
        :func:`specgram` can return the angle spectrum of segments within the
        signal.
    """
    ...

@docstring.dedent_interpd
def phase_spectrum(x, Fs: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ...):
    """
    Compute the phase of the frequency spectrum (unwrapped angle spectrum) of
    *x*.  Data is padded to a length of *pad_to* and the windowing function
    *window* is applied to the signal.

    Parameters
    ----------
    x : 1-D array or sequence
        Array or sequence containing the data

    %(Spectral)s

    %(Single_Spectrum)s

    Returns
    -------
    spectrum : 1-D array
        The values for the phase spectrum in radians (real valued)

    freqs : 1-D array
        The frequencies corresponding to the elements in *spectrum*

    See Also
    --------
    :func:`complex_spectrum`
        This function returns the angle value of :func:`complex_spectrum`.

    :func:`magnitude_spectrum`
        :func:`magnitude_spectrum` returns the magnitudes of the corresponding
        frequencies.

    :func:`angle_spectrum`
        :func:`angle_spectrum` returns the wrapped version of this function.

    :func:`specgram`
        :func:`specgram` can return the phase spectrum of segments within the
        signal.
    """
    ...

@docstring.dedent_interpd
def specgram(x, NFFT: Optional[Any] = ..., Fs: Optional[Any] = ..., detrend: Optional[Any] = ..., window: Optional[Any] = ..., noverlap: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale_by_freq: Optional[Any] = ..., mode: Optional[Any] = ...):
    """
    Compute a spectrogram.

    Compute and plot a spectrogram of data in x.  Data are split into
    NFFT length segments and the spectrum of each section is
    computed.  The windowing function window is applied to each
    segment, and the amount of overlap of each segment is
    specified with noverlap.

    Parameters
    ----------
    x : array_like
        1-D array or sequence.

    %(Spectral)s

    %(PSD)s

    noverlap : int, optional
        The number of points of overlap between blocks.  The default
        value is 128.
    mode : str, optional
        What sort of spectrum to use, default is 'psd'.
            'psd'
                Returns the power spectral density.

            'complex'
                Returns the complex-valued frequency spectrum.

            'magnitude'
                Returns the magnitude spectrum.

            'angle'
                Returns the phase spectrum without unwrapping.

            'phase'
                Returns the phase spectrum with unwrapping.

    Returns
    -------
    spectrum : array_like
        2-D array, columns are the periodograms of successive segments.

    freqs : array_like
        1-D array, frequencies corresponding to the rows in *spectrum*.

    t : array_like
        1-D array, the times corresponding to midpoints of segments
        (i.e the columns in *spectrum*).

    See Also
    --------
    psd : differs in the overlap and in the return values.
    complex_spectrum : similar, but with complex valued frequencies.
    magnitude_spectrum : similar single segment when mode is 'magnitude'.
    angle_spectrum : similar to single segment when mode is 'angle'.
    phase_spectrum : similar to single segment when mode is 'phase'.

    Notes
    -----
    detrend and scale_by_freq only apply when *mode* is set to 'psd'.

    """
    ...

_coh_error = """Coherence is calculated by averaging over *NFFT*
length segments.  Your signal is too short for your choice of *NFFT*.
"""
@docstring.dedent_interpd
def cohere(x, y, NFFT=..., Fs=..., detrend=..., window=..., noverlap=..., pad_to: Optional[Any] = ..., sides=..., scale_by_freq: Optional[Any] = ...):
    """
    The coherence between *x* and *y*.  Coherence is the normalized
    cross spectral density:

    .. math::

        C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}

    Parameters
    ----------
    x, y
        Array or sequence containing the data

    %(Spectral)s

    %(PSD)s

    noverlap : integer
        The number of points of overlap between blocks.  The default value
        is 0 (no overlap).

    Returns
    -------
    The return value is the tuple (*Cxy*, *f*), where *f* are the
    frequencies of the coherence vector. For cohere, scaling the
    individual densities by the sampling frequency has no effect,
    since the factors cancel out.

    See Also
    --------
    :func:`psd`, :func:`csd` :
        For information about the methods used to compute :math:`P_{xy}`,
        :math:`P_{xx}` and :math:`P_{yy}`.
    """
    ...

@cbook.deprecated('2.2')
def donothing_callback(*args):
    ...

@cbook.deprecated('2.2', 'scipy.signal.coherence')
def cohere_pairs(X, ij, NFFT=..., Fs=..., detrend=..., window=..., noverlap=..., preferSpeedOverMemory: bool = ..., progressCallback=..., returnPxx: bool = ...):
    """
    Compute the coherence and phase for all pairs *ij*, in *X*.

    *X* is a *numSamples* * *numCols* array

    *ij* is a list of tuples.  Each tuple is a pair of indexes into
    the columns of X for which you want to compute coherence.  For
    example, if *X* has 64 columns, and you want to compute all
    nonredundant pairs, define *ij* as::

      ij = []
      for i in range(64):
          for j in range(i+1,64):
              ij.append( (i,j) )

    *preferSpeedOverMemory* is an optional bool. Defaults to true. If
    False, limits the caching by only making one, rather than two,
    complex cache arrays. This is useful if memory becomes critical.
    Even when *preferSpeedOverMemory* is False, :func:`cohere_pairs`
    will still give significant performance gains over calling
    :func:`cohere` for each pair, and will use subtantially less
    memory than if *preferSpeedOverMemory* is True.  In my tests with
    a 43000,64 array over all nonredundant pairs,
    *preferSpeedOverMemory* = True delivered a 33% performance boost
    on a 1.7GHZ Athlon with 512MB RAM compared with
    *preferSpeedOverMemory* = False.  But both solutions were more
    than 10x faster than naively crunching all possible pairs through
    :func:`cohere`.

    Returns
    -------
    Cxy : dictionary of (*i*, *j*) tuples -> coherence vector for
        that pair.  i.e., ``Cxy[(i,j) = cohere(X[:,i], X[:,j])``.
        Number of dictionary keys is ``len(ij)``.

    Phase : dictionary of phases of the cross spectral density at
        each frequency for each pair.  Keys are (*i*, *j*).

    freqs : vector of frequencies, equal in length to either the
         coherence or phase vectors for any (*i*, *j*) key.

    e.g., to make a coherence Bode plot::

          subplot(211)
          plot( freqs, Cxy[(12,19)])
          subplot(212)
          plot( freqs, Phase[(12,19)])

    For a large number of pairs, :func:`cohere_pairs` can be much more
    efficient than just calling :func:`cohere` for each pair, because
    it caches most of the intensive computations.  If :math:`N` is the
    number of pairs, this function is :math:`O(N)` for most of the
    heavy lifting, whereas calling cohere for each pair is
    :math:`O(N^2)`.  However, because of the caching, it is also more
    memory intensive, making 2 additional complex arrays with
    approximately the same number of elements as *X*.

    See :file:`test/cohere_pairs_test.py` in the src tree for an
    example script that shows that this :func:`cohere_pairs` and
    :func:`cohere` give the same results for a given pair.

    See Also
    --------
    :func:`psd`
        For information about the methods used to compute :math:`P_{xy}`,
        :math:`P_{xx}` and :math:`P_{yy}`.
    """
    ...

@cbook.deprecated('2.2', 'scipy.stats.entropy')
def entropy(y, bins):
    r"""
    Return the entropy of the data in *y* in units of nat.

    .. math::

      -\sum p_i \ln(p_i)

    where :math:`p_i` is the probability of observing *y* in the
    :math:`i^{th}` bin of *bins*.  *bins* can be a number of bins or a
    range of bins; see :func:`numpy.histogram`.

    Compare *S* with analytic calculation for a Gaussian::

      x = mu + sigma * randn(200000)
      Sanalytic = 0.5 * ( 1.0 + log(2*pi*sigma**2.0) )
    """
    ...

@cbook.deprecated('2.2', 'scipy.stats.norm.pdf')
def normpdf(x, *args):
    "Return the normal pdf evaluated at *x*; args provides *mu*, *sigma*"
    ...

@cbook.deprecated('2.2')
def find(condition):
    "Return the indices where ravel(condition) is true"
    ...

@cbook.deprecated('2.2')
def longest_contiguous_ones(x):
    """
    Return the indices of the longest stretch of contiguous ones in *x*,
    assuming *x* is a vector of zeros and ones.  If there are two
    equally long stretches, pick the first.
    """
    ...

@cbook.deprecated('2.2')
def longest_ones(x):
    '''alias for longest_contiguous_ones'''
    ...

@cbook.deprecated('2.2')
class PCA(object):
    def __init__(self, a, standardize: bool = ...):
        """
        compute the SVD of a and store data for PCA.  Use project to
        project the data onto a reduced set of dimensions

        Parameters
        ----------
        a : np.ndarray
            A numobservations x numdims array
        standardize : bool
            True if input data are to be standardized. If False, only centering
            will be carried out.

        Attributes
        ----------
        a
            A centered unit sigma version of input ``a``.

        numrows, numcols
            The dimensions of ``a``.

        mu
            A numdims array of means of ``a``. This is the vector that points
            to the origin of PCA space.

        sigma
            A numdims array of standard deviation of ``a``.

        fracs
            The proportion of variance of each of the principal components.

        s
            The actual eigenvalues of the decomposition.

        Wt
            The weight vector for projecting a numdims point or array into
            PCA space.

        Y
            A projected into PCA space.

        Notes
        -----
        The factor loadings are in the ``Wt`` factor, i.e., the factor loadings
        for the first principal component are given by ``Wt[0]``. This row is
        also the first eigenvector.

        """
        self.mu = ...
        self.sigma = ...
        self.standardize = ...
        self.a = ...
        self.Wt = ...
        self.Y = ...
        self.s = ...
        self.fracs = ...
    
    def project(self, x, minfrac=...):
        '''
        project x onto the principle axes, dropping any axes where fraction
        of variance<minfrac
        '''
        ...
    
    def center(self, x):
        '''
        center and optionally standardize the data using the mean and sigma
        from training set a
        '''
        ...
    
    @staticmethod
    def _get_colinear():
        ...
    


@cbook.deprecated('2.2', 'numpy.percentile')
def prctile(x, p=...):
    """
    Return the percentiles of *x*.  *p* can either be a sequence of
    percentile values or a scalar.  If *p* is a sequence, the ith
    element of the return sequence is the *p*(i)-th percentile of *x*.
    If *p* is a scalar, the largest value of *x* less than or equal to
    the *p* percentage point in the sequence is returned.
    """
    ...

@cbook.deprecated('2.2')
def prctile_rank(x, p):
    """
    Return the rank for each element in *x*, return the rank
    0..len(*p*).  e.g., if *p* = (25, 50, 75), the return value will be a
    len(*x*) array with values in [0,1,2,3] where 0 indicates the
    value is less than the 25th percentile, 1 indicates the value is
    >= the 25th and < 50th percentile, ... and 3 indicates the value
    is above the 75th percentile cutoff.

    *p* is either an array of percentiles in [0..100] or a scalar which
    indicates how many quantiles of data you want ranked.
    """
    ...

@cbook.deprecated('2.2')
def center_matrix(M, dim=...):
    """
    Return the matrix *M* with each row having zero mean and unit std.

    If *dim* = 1 operate on columns instead of rows.  (*dim* is
    opposite to the numpy axis kwarg.)
    """
    ...

@cbook.deprecated('2.2', 'scipy.integrate.ode')
def rk4(derivs, y0, t):
    """
    Integrate 1D or ND system of ODEs using 4-th order Runge-Kutta.
    This is a toy implementation which may be useful if you find
    yourself stranded on a system w/o scipy.  Otherwise use
    :func:`scipy.integrate`.

    Parameters
    ----------
    y0
        initial state vector

    t
        sample times

    derivs
        returns the derivative of the system and has the
        signature ``dy = derivs(yi, ti)``

    Examples
    --------

    A 2D system::

        def derivs6(x,t):
            d1 =  x[0] + 2*x[1]
            d2 =  -3*x[0] + 4*x[1]
            return (d1, d2)
        dt = 0.0005
        t = arange(0.0, 2.0, dt)
        y0 = (1,2)
        yout = rk4(derivs6, y0, t)

    A 1D system::

        alpha = 2
        def derivs(x,t):
            return -alpha*x + exp(-t)

        y0 = 1
        yout = rk4(derivs, y0, t)

    If you have access to scipy, you should probably be using the
    scipy.integrate tools rather than this function.
    """
    ...

@cbook.deprecated('2.2')
def bivariate_normal(X, Y, sigmax=..., sigmay=..., mux=..., muy=..., sigmaxy=...):
    """
    Bivariate Gaussian distribution for equal shape *X*, *Y*.

    See `bivariate normal
    <http://mathworld.wolfram.com/BivariateNormalDistribution.html>`_
    at mathworld.
    """
    ...

@cbook.deprecated('2.2')
def get_xyz_where(Z, Cond):
    """
    *Z* and *Cond* are *M* x *N* matrices.  *Z* are data and *Cond* is
    a boolean matrix where some condition is satisfied.  Return value
    is (*x*, *y*, *z*) where *x* and *y* are the indices into *Z* and
    *z* are the values of *Z* at those indices.  *x*, *y*, and *z* are
    1D arrays.
    """
    ...

@cbook.deprecated('2.2')
def get_sparse_matrix(M, N, frac=...):
    """
    Return a *M* x *N* sparse matrix with *frac* elements randomly
    filled.
    """
    ...

@cbook.deprecated('2.2', 'numpy.hypot')
def dist(x, y):
    """
    Return the distance between two points.
    """
    ...

@cbook.deprecated('2.2')
def dist_point_to_segment(p, s0, s1):
    """
    Get the distance of a point to a segment.

      *p*, *s0*, *s1* are *xy* sequences

    This algorithm from
    http://geomalgorithms.com/a02-_lines.html
    """
    ...

@cbook.deprecated('2.2')
def segments_intersect(s1, s2):
    """
    Return *True* if *s1* and *s2* intersect.
    *s1* and *s2* are defined as::

      s1: (x1, y1), (x2, y2)
      s2: (x3, y3), (x4, y4)
    """
    ...

@cbook.deprecated('2.2')
def fftsurr(x, detrend=..., window=...):
    """
    Compute an FFT phase randomized surrogate of *x*.
    """
    ...

@cbook.deprecated('2.2')
def movavg(x, n):
    """
    Compute the len(*n*) moving average of *x*.
    """
    ...

exp_safe_MIN = math.log(2.2250738585072014e-308)
exp_safe_MAX = 1.7976931348623157e+308
@cbook.deprecated("2.2", 'numpy.exp')
def exp_safe(x):
    """
    Compute exponentials which safely underflow to zero.

    Slow, but convenient to use. Note that numpy provides proper
    floating point exception handling with access to the underlying
    hardware.
    """
    ...

@cbook.deprecated("2.2", alternative='numpy.array(list(map(...)))')
def amap(fn, *args):
    """
    amap(function, sequence[, sequence, ...]) -> array.

    Works like :func:`map`, but it returns an array.  This is just a
    convenient shorthand for ``numpy.array(map(...))``.
    """
    ...

@cbook.deprecated("2.2")
def rms_flat(a):
    """
    Return the root mean square of all the elements of *a*, flattened out.
    """
    ...

@cbook.deprecated("2.2", alternative='numpy.linalg.norm(a, ord=1)')
def l1norm(a):
    """
    Return the *l1* norm of *a*, flattened out.

    Implemented as a separate function (not a call to :func:`norm` for speed).
    """
    ...

@cbook.deprecated("2.2", alternative='numpy.linalg.norm(a, ord=2)')
def l2norm(a):
    """
    Return the *l2* norm of *a*, flattened out.

    Implemented as a separate function (not a call to :func:`norm` for speed).
    """
    ...

@cbook.deprecated("2.2", alternative='numpy.linalg.norm(a.flat, ord=p)')
def norm_flat(a, p=...):
    """
    norm(a,p=2) -> l-p norm of a.flat

    Return the l-p norm of *a*, considered as a flat array.  This is NOT a true
    matrix norm, since arrays of arbitrary rank are always flattened.

    *p* can be a number or the string 'Infinity' to get the L-infinity norm.
    """
    ...

@cbook.deprecated("2.2", 'numpy.arange')
def frange(xini, xfin: Optional[Any] = ..., delta: Optional[Any] = ..., **kw):
    """
    frange([start,] stop[, step, keywords]) -> array of floats

    Return a numpy ndarray containing a progression of floats. Similar to
    :func:`numpy.arange`, but defaults to a closed interval.

    ``frange(x0, x1)`` returns ``[x0, x0+1, x0+2, ..., x1]``; *start*
    defaults to 0, and the endpoint *is included*. This behavior is
    different from that of :func:`range` and
    :func:`numpy.arange`. This is deliberate, since :func:`frange`
    will probably be more useful for generating lists of points for
    function evaluation, and endpoints are often desired in this
    use. The usual behavior of :func:`range` can be obtained by
    setting the keyword *closed* = 0, in this case, :func:`frange`
    basically becomes :func:numpy.arange`.

    When *step* is given, it specifies the increment (or
    decrement). All arguments can be floating point numbers.

    ``frange(x0,x1,d)`` returns ``[x0,x0+d,x0+2d,...,xfin]`` where
    *xfin* <= *x1*.

    :func:`frange` can also be called with the keyword *npts*. This
    sets the number of points the list should contain (and overrides
    the value *step* might have been given). :func:`numpy.arange`
    doesn't offer this option.

    Examples::

      >>> frange(3)
      array([ 0.,  1.,  2.,  3.])
      >>> frange(3,closed=0)
      array([ 0.,  1.,  2.])
      >>> frange(1,6,2)
      array([1, 3, 5])   or 1,3,5,7, depending on floating point vagueries
      >>> frange(1,6.5,npts=5)
      array([ 1.   ,  2.375,  3.75 ,  5.125,  6.5  ])
    """
    ...

@cbook.deprecated("2.2", 'numpy.identity')
def identity(n, rank=..., dtype=..., typecode: Optional[Any] = ...):
    """
    Returns the identity matrix of shape (*n*, *n*, ..., *n*) (rank *r*).

    For ranks higher than 2, this object is simply a multi-index Kronecker
    delta::

                            /  1  if i0=i1=...=iR,
        id[i0,i1,...,iR] = -|
                            \\  0  otherwise.

    Optionally a *dtype* (or typecode) may be given (it defaults to 'l').

    Since rank defaults to 2, this function behaves in the default case (when
    only *n* is given) like ``numpy.identity(n)`` -- but surprisingly, it is
    much faster.
    """
    ...

@cbook.deprecated("2.2")
def base_repr(number, base=..., padding=...):
    """
    Return the representation of a *number* in any given *base*.
    """
    ...

@cbook.deprecated("2.2")
def binary_repr(number, max_length=...):
    """
    Return the binary representation of the input *number* as a
    string.

    This is more efficient than using :func:`base_repr` with base 2.

    Increase the value of max_length for very large numbers. Note that
    on 32-bit machines, 2**1023 is the largest integer power of 2
    which can be converted to a Python float.
    """
    ...

@cbook.deprecated("2.2", 'numpy.log2')
def log2(x, ln2=...):
    """
    Return the log(*x*) in base 2.

    This is a _slow_ function but which is guaranteed to return the correct
    integer value if the input is an integer exact power of 2.
    """
    ...

@cbook.deprecated("2.2")
def ispower2(n):
    """
    Returns the log base 2 of *n* if *n* is a power of 2, zero otherwise.

    Note the potential ambiguity if *n* == 1: 2**0 == 1, interpret accordingly.
    """
    ...

@cbook.deprecated("2.2")
def isvector(X):
    """
    Like the MATLAB function with the same name, returns *True*
    if the supplied numpy array or matrix *X* looks like a vector,
    meaning it has a one non-singleton axis (i.e., it can have
    multiple axes, but all must have length 1, except for one of
    them).

    If you just want to see if the array has 1 axis, use X.ndim == 1.
    """
    ...

@cbook.deprecated("2.2", 'numpy.isnan')
def safe_isnan(x):
    ':func:`numpy.isnan` for arbitrary types'
    ...

@cbook.deprecated("2.2", 'numpy.isinf')
def safe_isinf(x):
    ':func:`numpy.isinf` for arbitrary types'
    ...

@cbook.deprecated("2.2")
def rec_append_fields(rec, names, arrs, dtypes: Optional[Any] = ...):
    """
    Return a new record array with field names populated with data
    from arrays in *arrs*.  If appending a single field, then *names*,
    *arrs* and *dtypes* do not have to be lists. They can just be the
    values themselves.
    """
    ...

@cbook.deprecated("2.2")
def rec_drop_fields(rec, names):
    """
    Return a new numpy record array with fields in *names* dropped.
    """
    ...

@cbook.deprecated("2.2")
def rec_keep_fields(rec, names):
    """
    Return a new numpy record array with only fields listed in names
    """
    ...

@cbook.deprecated("2.2")
def rec_groupby(r, groupby, stats):
    """
    *r* is a numpy record array

    *groupby* is a sequence of record array attribute names that
    together form the grouping key.  e.g., ('date', 'productcode')

    *stats* is a sequence of (*attr*, *func*, *outname*) tuples which
    will call ``x = func(attr)`` and assign *x* to the record array
    output with attribute *outname*.  For example::

      stats = ( ('sales', len, 'numsales'), ('sales', np.mean, 'avgsale') )

    Return record array has *dtype* names for each attribute name in
    the *groupby* argument, with the associated group values, and
    for each outname name in the *stats* argument, with the associated
    stat summary output.
    """
    ...

@cbook.deprecated("2.2")
def rec_summarize(r, summaryfuncs):
    """
    *r* is a numpy record array

    *summaryfuncs* is a list of (*attr*, *func*, *outname*) tuples
    which will apply *func* to the array *r*[attr] and assign the
    output to a new attribute name *outname*.  The returned record
    array is identical to *r*, with extra arrays for each element in
    *summaryfuncs*.

    """
    ...

@cbook.deprecated("2.2")
def rec_join(key, r1, r2, jointype=..., defaults: Optional[Any] = ..., r1postfix=..., r2postfix=...):
    """
    Join record arrays *r1* and *r2* on *key*; *key* is a tuple of
    field names -- if *key* is a string it is assumed to be a single
    attribute name. If *r1* and *r2* have equal values on all the keys
    in the *key* tuple, then their fields will be merged into a new
    record array containing the intersection of the fields of *r1* and
    *r2*.

    *r1* (also *r2*) must not have any duplicate keys.

    The *jointype* keyword can be 'inner', 'outer', 'leftouter'.  To
    do a rightouter join just reverse *r1* and *r2*.

    The *defaults* keyword is a dictionary filled with
    ``{column_name:default_value}`` pairs.

    The keywords *r1postfix* and *r2postfix* are postfixed to column names
    (other than keys) that are both in *r1* and *r2*.
    """
    ...

@cbook.deprecated("2.2")
def recs_join(key, name, recs, jointype=..., missing=..., postfixes: Optional[Any] = ...):
    """
    Join a sequence of record arrays on single column key.

    This function only joins a single column of the multiple record arrays

    *key*
      is the column name that acts as a key

    *name*
      is the name of the column that we want to join

    *recs*
      is a list of record arrays to join

    *jointype*
      is a string 'inner' or 'outer'

    *missing*
      is what any missing field is replaced by

    *postfixes*
      if not None, a len recs sequence of postfixes

    returns a record array with columns [rowkey, name0, name1, ... namen-1].
    or if postfixes [PF0, PF1, ..., PFN-1] are supplied,
    [rowkey, namePF0, namePF1, ... namePFN-1].

    Example::

      r = recs_join("date", "close", recs=[r0, r1], missing=0.)

    """
    ...

@cbook.deprecated("2.2")
def csv2rec(fname, comments=..., skiprows=..., checkrows=..., delimiter=..., converterd: Optional[Any] = ..., names: Optional[Any] = ..., missing=..., missingd: Optional[Any] = ..., use_mrecords: bool = ..., dayfirst: bool = ..., yearfirst: bool = ...):
    """
    Load data from comma/space/tab delimited file in *fname* into a
    numpy record array and return the record array.

    If *names* is *None*, a header row is required to automatically
    assign the recarray names.  The headers will be lower cased,
    spaces will be converted to underscores, and illegal attribute
    name characters removed.  If *names* is not *None*, it is a
    sequence of names to use for the column names.  In this case, it
    is assumed there is no header row.


    - *fname*: can be a filename or a file handle.  Support for gzipped
      files is automatic, if the filename ends in '.gz'

    - *comments*: the character used to indicate the start of a comment
      in the file, or *None* to switch off the removal of comments

    - *skiprows*: is the number of rows from the top to skip

    - *checkrows*: is the number of rows to check to validate the column
      data type.  When set to zero all rows are validated.

    - *converterd*: if not *None*, is a dictionary mapping column number or
      munged column name to a converter function.

    - *names*: if not None, is a list of header names.  In this case, no
      header will be read from the file

    - *missingd* is a dictionary mapping munged column names to field values
      which signify that the field does not contain actual data and should
      be masked, e.g., '0000-00-00' or 'unused'

    - *missing*: a string whose value signals a missing field regardless of
      the column it appears in

    - *use_mrecords*: if True, return an mrecords.fromrecords record array if
      any of the data are missing

    - *dayfirst*: default is False so that MM-DD-YY has precedence over
      DD-MM-YY.  See
      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47
      for further information.

    - *yearfirst*: default is False so that MM-DD-YY has precedence over
      YY-MM-DD. See
      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47
      for further information.

      If no rows are found, *None* is returned
    """
    class FH:
        """
        For space-delimited files, we want different behavior than
        comma or tab.  Generally, we want multiple spaces to be
        treated as a single separator, whereas with comma and tab we
        want multiple commas to return multiple (empty) fields.  The
        join/strip trick below effects this.
        """
        ...
    
    

@cbook.deprecated("2.2")
class FormatObj(object):
    def tostr(self, x):
        ...
    
    def toval(self, x):
        ...
    
    def fromstr(self, s):
        ...
    
    def __hash__(self):
        """
        override the hash function of any of the formatters, so that we don't
        create duplicate excel format styles
        """
        ...
    


@cbook.deprecated("2.2")
class FormatString(FormatObj):
    def tostr(self, x):
        ...
    


@cbook.deprecated("2.2")
class FormatFormatStr(FormatObj):
    def __init__(self, fmt):
        self.fmt = ...
    
    def tostr(self, x):
        ...
    


@cbook.deprecated("2.2")
class FormatFloat(FormatFormatStr):
    def __init__(self, precision=..., scale=...):
        self.precision = ...
        self.scale = ...
    
    def __hash__(self):
        ...
    
    def toval(self, x):
        ...
    
    def fromstr(self, s):
        ...
    


@cbook.deprecated("2.2")
class FormatInt(FormatObj):
    def tostr(self, x):
        ...
    
    def toval(self, x):
        ...
    
    def fromstr(self, s):
        ...
    


@cbook.deprecated("2.2")
class FormatBool(FormatObj):
    def toval(self, x):
        ...
    
    def fromstr(self, s):
        ...
    


@cbook.deprecated("2.2")
class FormatPercent(FormatFloat):
    def __init__(self, precision=...):
        ...
    


@cbook.deprecated("2.2")
class FormatThousands(FormatFloat):
    def __init__(self, precision=...):
        ...
    


@cbook.deprecated("2.2")
class FormatMillions(FormatFloat):
    def __init__(self, precision=...):
        ...
    


@cbook.deprecated("2.2", alternative='date.strftime')
class FormatDate(FormatObj):
    def __init__(self, fmt):
        self.fmt = ...
    
    def __hash__(self):
        ...
    
    def toval(self, x):
        ...
    
    def fromstr(self, x):
        ...
    


@cbook.deprecated("2.2", alternative='datetime.strftime')
class FormatDatetime(FormatDate):
    def __init__(self, fmt=...):
        ...
    
    def fromstr(self, x):
        ...
    


@cbook.deprecated("2.2")
def get_formatd(r, formatd: Optional[Any] = ...):
    'build a formatd guaranteed to have a key for every dtype name'
    ...

@cbook.deprecated("2.2")
def csvformat_factory(format):
    ...

@cbook.deprecated("2.2", alternative='numpy.recarray.tofile')
def rec2txt(r, header: Optional[Any] = ..., padding=..., precision=..., fields: Optional[Any] = ...):
    """
    Returns a textual representation of a record array.

    Parameters
    ----------
    r: numpy recarray

    header: list
        column headers

    padding:
        space between each column

    precision: number of decimal places to use for floats.
        Set to an integer to apply to all floats.  Set to a
        list of integers to apply precision individually.
        Precision for non-floats is simply ignored.

    fields : list
        If not None, a list of field names to print.  fields
        can be a list of strings like ['field1', 'field2'] or a single
        comma separated string like 'field1,field2'

    Examples
    --------

    For ``precision=[0,2,3]``, the output is ::

      ID    Price   Return
      ABC   12.54    0.234
      XYZ    6.32   -0.076
    """
    ...

@cbook.deprecated("2.2", alternative='numpy.recarray.tofile')
def rec2csv(r, fname, delimiter=..., formatd: Optional[Any] = ..., missing=..., missingd: Optional[Any] = ..., withheader: bool = ...):
    """
    Save the data from numpy recarray *r* into a
    comma-/space-/tab-delimited file.  The record array dtype names
    will be used for column headers.

    *fname*: can be a filename or a file handle.  Support for gzipped
      files is automatic, if the filename ends in '.gz'

    *withheader*: if withheader is False, do not write the attribute
      names in the first row

    for formatd type FormatFloat, we override the precision to store
    full precision floats in the CSV file

    See Also
    --------
    :func:`csv2rec`
        For information about *missing* and *missingd*, which can be used to
        fill in masked values into your CSV file.
    """
    ...

@cbook.deprecated('2.2', alternative='scipy.interpolate.griddata')
def griddata(x, y, z, xi, yi, interp=...):
    """
    Interpolates from a nonuniformly spaced grid to some other grid.

    Fits a surface of the form z = f(`x`, `y`) to the data in the
    (usually) nonuniformly spaced vectors (`x`, `y`, `z`), then
    interpolates this surface at the points specified by
    (`xi`, `yi`) to produce `zi`.

    Parameters
    ----------
    x, y, z : 1d array_like
        Coordinates of grid points to interpolate from.
    xi, yi : 1d or 2d array_like
        Coordinates of grid points to interpolate to.
    interp : string key from {'nn', 'linear'}
        Interpolation algorithm, either 'nn' for natural neighbor, or
        'linear' for linear interpolation.

    Returns
    -------
    2d float array
        Array of values interpolated at (`xi`, `yi`) points.  Array
        will be masked is any of (`xi`, `yi`) are outside the convex
        hull of (`x`, `y`).

    Notes
    -----
    If `interp` is 'nn' (the default), uses natural neighbor
    interpolation based on Delaunay triangulation.  This option is
    only available if the mpl_toolkits.natgrid module is installed.
    This can be downloaded from https://github.com/matplotlib/natgrid.
    The (`xi`, `yi`) grid must be regular and monotonically increasing
    in this case.

    If `interp` is 'linear', linear interpolation is used via
    matplotlib.tri.LinearTriInterpolator.

    Instead of using `griddata`, more flexible functionality and other
    interpolation options are available using a
    matplotlib.tri.Triangulation and a matplotlib.tri.TriInterpolator.
    """
    ...

@cbook.deprecated("2.2", alternative="numpy.interp")
def less_simple_linear_interpolation(x, y, xi, extrap: bool = ...):
    """
    This function provides simple (but somewhat less so than
    :func:`cbook.simple_linear_interpolation`) linear interpolation.
    :func:`simple_linear_interpolation` will give a list of point
    between a start and an end, while this does true linear
    interpolation at an arbitrary set of points.

    This is very inefficient linear interpolation meant to be used
    only for a small number of points in relatively non-intensive use
    cases.  For real linear interpolation, use scipy.
    """
    ...

@cbook.deprecated("2.2")
def slopes(x, y):
    """
    :func:`slopes` calculates the slope *y*'(*x*)

    The slope is estimated using the slope obtained from that of a
    parabola through any three consecutive points.

    This method should be superior to that described in the appendix
    of A CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russel
    W. Stineman (Creative Computing July 1980) in at least one aspect:

      Circles for interpolation demand a known aspect ratio between
      *x*- and *y*-values.  For many functions, however, the abscissa
      are given in different dimensions, so an aspect ratio is
      completely arbitrary.

    The parabola method gives very similar results to the circle
    method for most regular cases but behaves much better in special
    cases.

    Norbert Nemec, Institute of Theoretical Physics, University or
    Regensburg, April 2006 Norbert.Nemec at physik.uni-regensburg.de

    (inspired by a original implementation by Halldor Bjornsson,
    Icelandic Meteorological Office, March 2006 halldor at vedur.is)
    """
    ...

@cbook.deprecated("2.2")
def stineman_interp(xi, x, y, yp: Optional[Any] = ...):
    """
    Given data vectors *x* and *y*, the slope vector *yp* and a new
    abscissa vector *xi*, the function :func:`stineman_interp` uses
    Stineman interpolation to calculate a vector *yi* corresponding to
    *xi*.

    Here's an example that generates a coarse sine curve, then
    interpolates over a finer abscissa::

      x = linspace(0,2*pi,20);  y = sin(x); yp = cos(x)
      xi = linspace(0,2*pi,40);
      yi = stineman_interp(xi,x,y,yp);
      plot(x,y,'o',xi,yi)

    The interpolation method is described in the article A
    CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russell
    W. Stineman. The article appeared in the July 1980 issue of
    Creative Computing with a note from the editor stating that while
    they were:

      not an academic journal but once in a while something serious
      and original comes in adding that this was
      "apparently a real solution" to a well known problem.

    For *yp* = *None*, the routine automatically determines the slopes
    using the :func:`slopes` routine.

    *x* is assumed to be sorted in increasing order.

    For values ``xi[j] < x[0]`` or ``xi[j] > x[-1]``, the routine
    tries an extrapolation.  The relevance of the data obtained from
    this, of course, is questionable...

    Original implementation by Halldor Bjornsson, Icelandic
    Meteorolocial Office, March 2006 halldor at vedur.is

    Completely reworked and optimized for Python by Norbert Nemec,
    Institute of Theoretical Physics, University or Regensburg, April
    2006 Norbert.Nemec at physik.uni-regensburg.de
    """
    ...

class GaussianKDE(object):
    """
    Representation of a kernel-density estimate using Gaussian kernels.

    Parameters
    ----------
    dataset : array_like
        Datapoints to estimate from. In case of univariate data this is a 1-D
        array, otherwise a 2-D array with shape (# of dims, # of data).

    bw_method : str, scalar or callable, optional
        The method used to calculate the estimator bandwidth.  This can be
        'scott', 'silverman', a scalar constant or a callable.  If a
        scalar, this will be used directly as `kde.factor`.  If a
        callable, it should take a `GaussianKDE` instance as only
        parameter and return a scalar. If None (default), 'scott' is used.

    Attributes
    ----------
    dataset : ndarray
        The dataset with which `gaussian_kde` was initialized.

    dim : int
        Number of dimensions.

    num_dp : int
        Number of datapoints.

    factor : float
        The bandwidth factor, obtained from `kde.covariance_factor`, with which
        the covariance matrix is multiplied.

    covariance : ndarray
        The covariance matrix of `dataset`, scaled by the calculated bandwidth
        (`kde.factor`).

    inv_cov : ndarray
        The inverse of `covariance`.

    Methods
    -------
    kde.evaluate(points) : ndarray
        Evaluate the estimated pdf on a provided set of points.

    kde(points) : ndarray
        Same as kde.evaluate(points)

    """
    def __init__(self, dataset, bw_method: Optional[Any] = ...):
        self.dataset = ...
        self.factor = ...
        self.covariance = ...
        self.inv_cov = ...
        self.norm_factor = ...
    
    def scotts_factor(self):
        ...
    
    def silverman_factor(self):
        ...
    
    covariance_factor = ...
    def evaluate(self, points):
        """Evaluate the estimated pdf on a set of points.

        Parameters
        ----------
        points : (# of dimensions, # of points)-array
            Alternatively, a (# of dimensions,) vector can be passed in and
            treated as a single point.

        Returns
        -------
        values : (# of points,)-array
            The values at each point.

        Raises
        ------
        ValueError : if the dimensionality of the input points is different
                     than the dimensionality of the KDE.

        """
        ...
    
    __call__ = ...


@cbook.deprecated("2.2")
def inside_poly(points, verts):
    """
    *points* is a sequence of *x*, *y* points.
    *verts* is a sequence of *x*, *y* vertices of a polygon.

    Return value is a sequence of indices into points for the points
    that are inside the polygon.
    """
    ...

@cbook.deprecated("2.2")
def poly_below(xmin, xs, ys):
    """
    Given a sequence of *xs* and *ys*, return the vertices of a
    polygon that has a horizontal base at *xmin* and an upper bound at
    the *ys*.  *xmin* is a scalar.

    Intended for use with :meth:`matplotlib.axes.Axes.fill`, e.g.,::

      xv, yv = poly_below(0, x, y)
      ax.fill(xv, yv)
    """
    ...

@cbook.deprecated("2.2")
def poly_between(x, ylower, yupper):
    """
    Given a sequence of *x*, *ylower* and *yupper*, return the polygon
    that fills the regions between them.  *ylower* or *yupper* can be
    scalar or iterable.  If they are iterable, they must be equal in
    length to *x*.

    Return value is *x*, *y* arrays for use with
    :meth:`matplotlib.axes.Axes.fill`.
    """
    ...

@cbook.deprecated('2.2')
def is_closed_polygon(X):
    """
    Tests whether first and last object in a sequence are the same.  These are
    presumably coordinates on a polygonal curve, in which case this function
    tests if that curve is closed.
    """
    ...

@cbook.deprecated("2.2", message='Moved to matplotlib.cbook')
def contiguous_regions(mask):
    """
    return a list of (ind0, ind1) such that mask[ind0:ind1].all() is
    True and we cover all such regions
    """
    ...

@cbook.deprecated("2.2")
def cross_from_below(x, threshold):
    """
    return the indices into *x* where *x* crosses some threshold from
    below, e.g., the i's where::

      x[i-1]<threshold and x[i]>=threshold

    Example code::

        import matplotlib.pyplot as plt

        t = np.arange(0.0, 2.0, 0.1)
        s = np.sin(2*np.pi*t)

        fig, ax = plt.subplots()
        ax.plot(t, s, '-o')
        ax.axhline(0.5)
        ax.axhline(-0.5)

        ind = cross_from_below(s, 0.5)
        ax.vlines(t[ind], -1, 1)

        ind = cross_from_above(s, -0.5)
        ax.vlines(t[ind], -1, 1)

        plt.show()

    See Also
    --------
    :func:`cross_from_above` and :func:`contiguous_regions`

    """
    ...

@cbook.deprecated("2.2")
def cross_from_above(x, threshold):
    """
    return the indices into *x* where *x* crosses some threshold from
    below, e.g., the i's where::

      x[i-1]>threshold and x[i]<=threshold

    See Also
    --------
    :func:`cross_from_below` and :func:`contiguous_regions`

    """
    ...

@cbook.deprecated('2.2')
def vector_lengths(X, P=..., axis: Optional[Any] = ...):
    """
    Finds the length of a set of vectors in *n* dimensions.  This is
    like the :func:`numpy.norm` function for vectors, but has the ability to
    work over a particular axis of the supplied array or matrix.

    Computes ``(sum((x_i)^P))^(1/P)`` for each ``{x_i}`` being the
    elements of *X* along the given axis.  If *axis* is *None*,
    compute over all elements of *X*.
    """
    ...

@cbook.deprecated('2.2')
def distances_along_curve(X):
    """
    Computes the distance between a set of successive points in *N* dimensions.

    Where *X* is an *M* x *N* array or matrix.  The distances between
    successive rows is computed.  Distance is the standard Euclidean
    distance.
    """
    ...

@cbook.deprecated('2.2')
def path_length(X):
    """
    Computes the distance travelled along a polygonal curve in *N* dimensions.

    Where *X* is an *M* x *N* array or matrix.  Returns an array of
    length *M* consisting of the distance along the curve at each point
    (i.e., the rows of *X*).
    """
    ...

@cbook.deprecated('2.2')
def quad2cubic(q0x, q0y, q1x, q1y, q2x, q2y):
    """
    Converts a quadratic Bezier curve to a cubic approximation.

    The inputs are the *x* and *y* coordinates of the three control
    points of a quadratic curve, and the output is a tuple of *x* and
    *y* coordinates of the four control points of the cubic curve.
    """
    ...

@cbook.deprecated("2.2")
def offset_line(y, yerr):
    """
    Offsets an array *y* by +/- an error and returns a tuple
    (y - err, y + err).

    The error term can be:

    * A scalar. In this case, the returned tuple is obvious.
    * A vector of the same length as *y*. The quantities y +/- err are computed
      component-wise.
    * A tuple of length 2. In this case, yerr[0] is the error below *y* and
      yerr[1] is error above *y*. For example::

        from pylab import *
        x = linspace(0, 2*pi, num=100, endpoint=True)
        y = sin(x)
        y_minus, y_plus = mlab.offset_line(y, 0.1)
        plot(x, y)
        fill_between(x, ym, y2=yp)
        show()

    """
    ...

