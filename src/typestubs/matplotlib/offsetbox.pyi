"""
This type stub file was generated by pyright.
"""

import matplotlib.artist as martist
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import docstring
from matplotlib.text import _AnnotationBase
from typing import Any, Optional

"""
The OffsetBox is a simple container artist. The child artist are meant
to be drawn at a relative position to its parent.  The [VH]Packer,
DrawingArea and TextArea are derived from the OffsetBox.

The [VH]Packer automatically adjust the relative postisions of their
children, which should be instances of the OffsetBox. This is used to
align similar artists together, e.g., in legend.

The DrawingArea can contain any Artist as a child. The
DrawingArea has a fixed width and height. The position of children
relative to the parent is fixed.  The TextArea is contains a single
Text instance. The width and height of the TextArea instance is the
width and height of the its child text.
"""
DEBUG = False
def bbox_artist(*args, **kwargs):
    ...

def _get_packed_offsets(wd_list, total, sep, mode=...):
    """
    Geiven a list of (width, xdescent) of each boxes, calculate the
    total width and the x-offset positions of each items according to
    *mode*. xdescent is analogous to the usual descent, but along the
    x-direction. xdescent values are currently ignored.

    *wd_list* : list of (width, xdescent) of boxes to be packed.
    *sep* : spacing between boxes
    *total* : Intended total length. None if not used.
    *mode* : packing mode. 'fixed', 'expand', or 'equal'.
    """
    ...

def _get_aligned_offsets(hd_list, height, align=...):
    """
    Given a list of (height, descent) of each boxes, align the boxes
    with *align* and calculate the y-offsets of each boxes.
    total width and the offset positions of each items according to
    *mode*. xdescent is analogous to the usual descent, but along the
    x-direction. xdescent values are currently ignored.

    *hd_list* : list of (width, xdescent) of boxes to be aligned.
    *sep* : spacing between boxes
    *height* : Intended total length. None if not used.
    *align* : align mode. 'baseline', 'top', 'bottom', or 'center'.
    """
    ...

class OffsetBox(martist.Artist):
    """
    The OffsetBox is a simple container artist. The child artist are meant
    to be drawn at a relative position to its parent.
    """
    def __init__(self, *args, **kwargs):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        self.__dict__ = ...
        self.stale = ...
    
    def set_figure(self, fig):
        """
        Set the figure

        accepts a class:`~matplotlib.figure.Figure` instance
        """
        ...
    
    @martist.Artist.axes.setter
    def axes(self, ax):
        ...
    
    def contains(self, mouseevent):
        ...
    
    def set_offset(self, xy):
        """
        Set the offset

        accepts x, y, tuple, or a callable object.
        """
        self.stale = ...
    
    def get_offset(self, width, height, xdescent, ydescent, renderer):
        """
        Get the offset

        accepts extent of the box
        """
        ...
    
    def set_width(self, width):
        """
        Set the width

        accepts float
        """
        self.width = ...
        self.stale = ...
    
    def set_height(self, height):
        """
        Set the height

        accepts float
        """
        self.height = ...
        self.stale = ...
    
    def get_visible_children(self):
        """
        Return a list of visible artists it contains.
        """
        ...
    
    def get_children(self):
        """
        Return a list of artists it contains.
        """
        ...
    
    def get_extent_offsets(self, renderer):
        ...
    
    def get_extent(self, renderer):
        """
        Return with, height, xdescent, ydescent of box
        """
        ...
    
    def get_window_extent(self, renderer):
        '''
        get the bounding box in display space.
        '''
        ...
    
    def draw(self, renderer):
        """
        Update the location of children if necessary and draw them
        to the given *renderer*.
        """
        self.stale = ...
    


class PackerBase(OffsetBox):
    def __init__(self, pad: Optional[Any] = ..., sep: Optional[Any] = ..., width: Optional[Any] = ..., height: Optional[Any] = ..., align: Optional[Any] = ..., mode: Optional[Any] = ..., children: Optional[Any] = ...):
        """
        Parameters
        ----------
        pad : float, optional
            Boundary pad.

        sep : float, optional
            Spacing between items.

        width : float, optional

        height : float, optional
           Width and height of the container box, calculated if
           `None`.

        align : str, optional
            Alignment of boxes. Can be one of ``top``, ``bottom``,
            ``left``, ``right``, ``center`` and ``baseline``

        mode : str, optional
            Packing mode.

        Notes
        -----
        *pad* and *sep* need to given in points and will be scale with
        the renderer dpi, while *width* and *height* need to be in
        pixels.
        """
        self.height = ...
        self.width = ...
        self.sep = ...
        self.pad = ...
        self.mode = ...
        self.align = ...
    


class VPacker(PackerBase):
    """
    The VPacker has its children packed vertically. It automatically
    adjust the relative positions of children in the drawing time.
    """
    def __init__(self, pad: Optional[Any] = ..., sep: Optional[Any] = ..., width: Optional[Any] = ..., height: Optional[Any] = ..., align=..., mode=..., children: Optional[Any] = ...):
        """
        Parameters
        ----------
        pad : float, optional
            Boundary pad.

        sep : float, optional
            Spacing between items.

        width : float, optional

        height : float, optional

            width and height of the container box, calculated if
            `None`.

        align : str, optional
            Alignment of boxes.

        mode : str, optional
            Packing mode.

        Notes
        -----
        *pad* and *sep* need to given in points and will be scale with
        the renderer dpi, while *width* and *height* need to be in
        pixels.
        """
        ...
    
    def get_extent_offsets(self, renderer):
        """
        update offset of childrens and return the extents of the box
        """
        ...
    


class HPacker(PackerBase):
    """
    The HPacker has its children packed horizontally. It automatically
    adjusts the relative positions of children at draw time.
    """
    def __init__(self, pad: Optional[Any] = ..., sep: Optional[Any] = ..., width: Optional[Any] = ..., height: Optional[Any] = ..., align=..., mode=..., children: Optional[Any] = ...):
        """
        Parameters
        ----------
        pad : float, optional
            Boundary pad.

        sep : float, optional
            Spacing between items.

        width : float, optional

        height : float, optional
           Width and height of the container box, calculated if
           `None`.

        align : str
           Alignment of boxes.

        mode : str
           Packing mode.

        Notes
        -----
        *pad* and *sep* need to given in points and will be scale with
        the renderer dpi, while *width* and *height* need to be in
        pixels.
        """
        ...
    
    def get_extent_offsets(self, renderer):
        """
        update offset of children and return the extents of the box
        """
        ...
    


class PaddedBox(OffsetBox):
    def __init__(self, child, pad: Optional[Any] = ..., draw_frame: bool = ..., patch_attrs: Optional[Any] = ...):
        """
        *pad* : boundary pad

        .. note::
          *pad* need to given in points and will be
          scale with the renderer dpi, while *width* and *height*
          need to be in pixels.
        """
        self.pad = ...
        self.patch = ...
    
    def get_extent_offsets(self, renderer):
        """
        update offset of childrens and return the extents of the box
        """
        ...
    
    def draw(self, renderer):
        """
        Update the location of children if necessary and draw them
        to the given *renderer*.
        """
        self.stale = ...
    
    def update_frame(self, bbox, fontsize: Optional[Any] = ...):
        self.stale = ...
    
    def draw_frame(self, renderer):
        ...
    


class DrawingArea(OffsetBox):
    """
    The DrawingArea can contain any Artist as a child. The DrawingArea
    has a fixed width and height. The position of children relative to
    the parent is fixed. The children can be clipped at the
    boundaries of the parent.
    """
    def __init__(self, width, height, xdescent=..., ydescent=..., clip: bool = ...):
        """
        *width*, *height* : width and height of the container box.
        *xdescent*, *ydescent* : descent of the box in x- and y-direction.
        *clip* : Whether to clip the children
        """
        self.width = ...
        self.height = ...
        self.xdescent = ...
        self.ydescent = ...
        self.offset_transform = ...
        self.dpi_transform = ...
    
    @property
    def clip_children(self):
        """
        If the children of this DrawingArea should be clipped
        by DrawingArea bounding box.
        """
        ...
    
    @clip_children.setter
    def clip_children(self, val):
        self.stale = ...
    
    def get_transform(self):
        """
        Return the :class:`~matplotlib.transforms.Transform` applied
        to the children
        """
        ...
    
    def set_transform(self, t):
        """
        set_transform is ignored.
        """
        ...
    
    def set_offset(self, xy):
        """
        set offset of the container.

        Accept : tuple of x,y coordinate in display units.
        """
        self.stale = ...
    
    def get_offset(self):
        """
        return offset of the container.
        """
        ...
    
    def get_window_extent(self, renderer):
        '''
        get the bounding box in display space.
        '''
        ...
    
    def get_extent(self, renderer):
        """
        Return with, height, xdescent, ydescent of box
        """
        ...
    
    def add_artist(self, a):
        'Add any :class:`~matplotlib.artist.Artist` to the container box'
        ...
    
    def draw(self, renderer):
        """
        Draw the children
        """
        self.stale = ...
    


class TextArea(OffsetBox):
    """
    The TextArea is contains a single Text instance. The text is
    placed at (0,0) with baseline+left alignment. The width and height
    of the TextArea instance is the width and height of the its child
    text.
    """
    def __init__(self, s, textprops: Optional[Any] = ..., multilinebaseline: Optional[Any] = ..., minimumdescent: bool = ...):
        """
        Parameters
        ----------
        s : str
            a string to be displayed.

        textprops : `~matplotlib.font_manager.FontProperties`, optional

        multilinebaseline : bool, optional
            If `True`, baseline for multiline text is adjusted so that
            it is (approximatedly) center-aligned with singleline
            text.

        minimumdescent : bool, optional
            If `True`, the box has a minimum descent of "p".
        """
        self.offset_transform = ...
    
    def set_text(self, s):
        "Set the text of this area as a string."
        self.stale = ...
    
    def get_text(self):
        "Returns the string representation of this area's text"
        ...
    
    def set_multilinebaseline(self, t):
        """
        Set multilinebaseline .

        If True, baseline for multiline text is
        adjusted so that it is (approximatedly) center-aligned with
        singleline text.
        """
        self.stale = ...
    
    def get_multilinebaseline(self):
        """
        get multilinebaseline .
        """
        ...
    
    def set_minimumdescent(self, t):
        """
        Set minimumdescent .

        If True, extent of the single line text is adjusted so that
        it has minimum descent of "p"
        """
        self.stale = ...
    
    def get_minimumdescent(self):
        """
        get minimumdescent.
        """
        ...
    
    def set_transform(self, t):
        """
        set_transform is ignored.
        """
        ...
    
    def set_offset(self, xy):
        """
        set offset of the container.

        Accept : tuple of x,y coordinates in display units.
        """
        self.stale = ...
    
    def get_offset(self):
        """
        return offset of the container.
        """
        ...
    
    def get_window_extent(self, renderer):
        '''
        get the bounding box in display space.
        '''
        ...
    
    def get_extent(self, renderer):
        ...
    
    def draw(self, renderer):
        """
        Draw the children
        """
        self.stale = ...
    


class AuxTransformBox(OffsetBox):
    """
    Offset Box with the aux_transform . Its children will be
    transformed with the aux_transform first then will be
    offseted. The absolute coordinate of the aux_transform is meaning
    as it will be automatically adjust so that the left-lower corner
    of the bounding box of children will be set to (0,0) before the
    offset transform.

    It is similar to drawing area, except that the extent of the box
    is not predetermined but calculated from the window extent of its
    children. Furthermore, the extent of the children will be
    calculated in the transformed coordinate.
    """
    def __init__(self, aux_transform):
        self.aux_transform = ...
        self.offset_transform = ...
        self.ref_offset_transform = ...
    
    def add_artist(self, a):
        'Add any :class:`~matplotlib.artist.Artist` to the container box'
        self.stale = ...
    
    def get_transform(self):
        """
        Return the :class:`~matplotlib.transforms.Transform` applied
        to the children
        """
        ...
    
    def set_transform(self, t):
        """
        set_transform is ignored.
        """
        ...
    
    def set_offset(self, xy):
        """
        set offset of the container.

        Accept : tuple of x,y coordinate in display units.
        """
        self.stale = ...
    
    def get_offset(self):
        """
        return offset of the container.
        """
        ...
    
    def get_window_extent(self, renderer):
        '''
        get the bounding box in display space.
        '''
        ...
    
    def get_extent(self, renderer):
        ...
    
    def draw(self, renderer):
        """
        Draw the children
        """
        self.stale = ...
    


class AnchoredOffsetbox(OffsetBox):
    """
    An offset box placed according to the legend location
    loc. AnchoredOffsetbox has a single child. When multiple children
    is needed, use other OffsetBox class to enclose them.  By default,
    the offset box is anchored against its parent axes. You may
    explicitly specify the bbox_to_anchor.
    """
    zorder = ...
    codes = ...
    def __init__(self, loc, pad=..., borderpad=..., child: Optional[Any] = ..., prop: Optional[Any] = ..., frameon: bool = ..., bbox_to_anchor: Optional[Any] = ..., bbox_transform: Optional[Any] = ..., **kwargs):
        """
        loc is a string or an integer specifying the legend location.
        The valid location codes are::

        'upper right'  : 1,
        'upper left'   : 2,
        'lower left'   : 3,
        'lower right'  : 4,
        'right'        : 5, (same as 'center right', for back-compatibility)
        'center left'  : 6,
        'center right' : 7,
        'lower center' : 8,
        'upper center' : 9,
        'center'       : 10,

        pad : pad around the child for drawing a frame. given in
          fraction of fontsize.

        borderpad : pad between offsetbox frame and the bbox_to_anchor,

        child : OffsetBox instance that will be anchored.

        prop : font property. This is only used as a reference for paddings.

        frameon : draw a frame box if True.

        bbox_to_anchor : bbox to anchor. Use self.axes.bbox if None.

        bbox_transform : with which the bbox_to_anchor will be transformed.

        """
        self.loc = ...
        self.borderpad = ...
        self.pad = ...
        self.patch = ...
    
    def set_child(self, child):
        "set the child to be anchored"
        self.stale = ...
    
    def get_child(self):
        "return the child"
        ...
    
    def get_children(self):
        "return the list of children"
        ...
    
    def get_extent(self, renderer):
        """
        return the extent of the artist. The extent of the child
        added with the pad is returned
        """
        ...
    
    def get_bbox_to_anchor(self):
        """
        return the bbox that the legend will be anchored
        """
        ...
    
    def set_bbox_to_anchor(self, bbox, transform: Optional[Any] = ...):
        """
        set the bbox that the child will be anchored.

        *bbox* can be a Bbox instance, a list of [left, bottom, width,
        height], or a list of [left, bottom] where the width and
        height will be assumed to be zero. The bbox will be
        transformed to display coordinate by the given transform.
        """
        self.stale = ...
    
    def get_window_extent(self, renderer):
        '''
        get the bounding box in display space.
        '''
        ...
    
    def _update_offset_func(self, renderer, fontsize: Optional[Any] = ...):
        """
        Update the offset func which depends on the dpi of the
        renderer (because of the padding).
        """
        ...
    
    def update_frame(self, bbox, fontsize: Optional[Any] = ...):
        ...
    
    def draw(self, renderer):
        "draw the artist"
        self.stale = ...
    
    def _get_anchored_bbox(self, loc, bbox, parentbbox, borderpad):
        """
        return the position of the bbox anchored at the parentbbox
        with the loc code, with the borderpad.
        """
        ...
    


class AnchoredText(AnchoredOffsetbox):
    """
    AnchoredOffsetbox with Text.
    """
    def __init__(self, s, loc, pad=..., borderpad=..., prop: Optional[Any] = ..., **kwargs):
        """
        Parameters
        ----------
        s : string
            Text.

        loc : str
            Location code.

        pad : float, optional
            Pad between the text and the frame as fraction of the font
            size.

        borderpad : float, optional
            Pad between the frame and the axes (or *bbox_to_anchor*).

        prop : `matplotlib.font_manager.FontProperties`
            Font properties.

        Notes
        -----
        Other keyword parameters of `AnchoredOffsetbox` are also
        allowed.
        """
        self.txt = ...
    


class OffsetImage(OffsetBox):
    def __init__(self, arr, zoom=..., cmap: Optional[Any] = ..., norm: Optional[Any] = ..., interpolation: Optional[Any] = ..., origin: Optional[Any] = ..., filternorm=..., filterrad=..., resample: bool = ..., dpi_cor: bool = ..., **kwargs):
        self.image = ...
    
    def set_data(self, arr):
        self.stale = ...
    
    def get_data(self):
        ...
    
    def set_zoom(self, zoom):
        self.stale = ...
    
    def get_zoom(self):
        ...
    
    def get_offset(self):
        """
        return offset of the container.
        """
        ...
    
    def get_children(self):
        ...
    
    def get_window_extent(self, renderer):
        '''
        get the bounding box in display space.
        '''
        ...
    
    def get_extent(self, renderer):
        ...
    
    def draw(self, renderer):
        """
        Draw the children
        """
        self.stale = ...
    


class AnnotationBbox(martist.Artist, _AnnotationBase):
    """
    Annotation-like class, but with offsetbox instead of Text.
    """
    zorder = ...
    def __str__(self):
        ...
    
    @docstring.dedent_interpd
    def __init__(self, offsetbox, xy, xybox: Optional[Any] = ..., xycoords=..., boxcoords: Optional[Any] = ..., frameon: bool = ..., pad=..., annotation_clip: Optional[Any] = ..., box_alignment=..., bboxprops: Optional[Any] = ..., arrowprops: Optional[Any] = ..., fontsize: Optional[Any] = ..., **kwargs):
        """
        *offsetbox* : OffsetBox instance

        *xycoords* : same as Annotation but can be a tuple of two
           strings which are interpreted as x and y coordinates.

        *boxcoords* : similar to textcoords as Annotation but can be a
           tuple of two strings which are interpreted as x and y
           coordinates.

        *box_alignment* : a tuple of two floats for a vertical and
           horizontal alignment of the offset box w.r.t. the *boxcoords*.
           The lower-left corner is (0.0) and upper-right corner is (1.1).

        other parameters are identical to that of Annotation.
        """
        self.offsetbox = ...
        self.arrowprops = ...
        self.patch = ...
    
    @property
    def xyann(self):
        ...
    
    @xyann.setter
    def xyann(self, xyann):
        self.xybox = ...
        self.stale = ...
    
    @property
    def anncoords(self):
        ...
    
    @anncoords.setter
    def anncoords(self, coords):
        self.boxcoords = ...
        self.stale = ...
    
    def contains(self, event):
        ...
    
    def get_children(self):
        ...
    
    def set_figure(self, fig):
        ...
    
    def set_fontsize(self, s: Optional[Any] = ...):
        """
        set fontsize in points
        """
        self.prop = ...
        self.stale = ...
    
    def get_fontsize(self, s: Optional[Any] = ...):
        """
        return fontsize in points
        """
        ...
    
    def update_positions(self, renderer):
        """
        Update the pixel positions of the annotated point and the text.
        """
        ...
    
    def _update_position_xybox(self, renderer, xy_pixel):
        """
        Update the pixel positions of the annotation text and the arrow
        patch.
        """
        ...
    
    def draw(self, renderer):
        """
        Draw the :class:`Annotation` object to the given *renderer*.
        """
        self.stale = ...
    


class DraggableBase(object):
    """
    helper code for a draggable artist (legend, offsetbox)
    The derived class must override following two method.

      def save_offset(self):
          pass

      def update_offset(self, dx, dy):
          pass

    *save_offset* is called when the object is picked for dragging and it
    is meant to save reference position of the artist.

    *update_offset* is called during the dragging. dx and dy is the pixel
     offset from the point where the mouse drag started.

    Optionally you may override following two methods.

      def artist_picker(self, artist, evt):
          return self.ref_artist.contains(evt)

      def finalize_offset(self):
          pass

    *artist_picker* is a picker method that will be
     used. *finalize_offset* is called when the mouse is released. In
     current implementation of DraggableLegend and DraggableAnnotation,
     *update_offset* places the artists simply in display
     coordinates. And *finalize_offset* recalculate their position in
     the normalized axes coordinate and set a relavant attribute.

    """
    def __init__(self, ref_artist, use_blit: bool = ...):
        self.ref_artist = ...
        self.got_artist = ...
        self.canvas = ...
        self.cids = ...
    
    def on_motion(self, evt):
        ...
    
    def on_motion_blit(self, evt):
        ...
    
    def on_pick(self, evt):
        ...
    
    def on_release(self, event):
        ...
    
    def disconnect(self):
        """disconnect the callbacks"""
        ...
    
    def artist_picker(self, artist, evt):
        ...
    
    def save_offset(self):
        ...
    
    def update_offset(self, dx, dy):
        ...
    
    def finalize_offset(self):
        ...
    


class DraggableOffsetBox(DraggableBase):
    def __init__(self, ref_artist, offsetbox, use_blit: bool = ...):
        self.offsetbox = ...
    
    def save_offset(self):
        ...
    
    def update_offset(self, dx, dy):
        ...
    
    def get_loc_in_canvas(self):
        ...
    


class DraggableAnnotation(DraggableBase):
    def __init__(self, annotation, use_blit: bool = ...):
        self.annotation = ...
    
    def save_offset(self):
        ...
    
    def update_offset(self, dx, dy):
        ...
    


if __name__ == "__main__":
    fig = plt.figure(1)
    ax = plt.subplot(121)
    kwargs = dict()
    a = np.arange(256).reshape(16, 16) / 256
    myimage = OffsetImage(a, zoom=2, norm=None, origin=None, **kwargs)
    myimage2 = OffsetImage(a, zoom=2, norm=None, origin=None, **kwargs)
    ann = AnnotationBbox(myimage2, (0.5, 0.5), xybox=(30, 30), xycoords='data', boxcoords="offset points", frameon=True, pad=0.4, bboxprops=dict(boxstyle="round", fc="y"), fontsize=None, arrowprops=dict(arrowstyle="->"))
