"""
This type stub file was generated by pyright.
"""

import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.text as text
import matplotlib.cbook as cbook
from typing import Any, Optional

"""
These are classes to support contour plotting and labelling for the Axes class.
"""
class ClabelText(text.Text):
    """
    Unlike the ordinary text, the get_rotation returns an updated
    angle in the pixel coordinate assuming that the input rotation is
    an angle in data coordinate (or whatever transform set).
    """
    def get_rotation(self):
        ...
    


class ContourLabeler(object):
    """Mixin to provide labelling capability to `.ContourSet`."""
    def clabel(self, *args, **kwargs):
        """
        Label a contour plot.

        Call signature::

          clabel(cs, **kwargs)

        Adds labels to line contours in *cs*, where *cs* is a
        :class:`~matplotlib.contour.ContourSet` object returned by
        contour.

        ::

          clabel(cs, v, **kwargs)

        only labels contours listed in *v*.

        Parameters
        ----------
        fontsize : string or float, optional
            Size in points or relative size e.g., 'smaller', 'x-large'.
            See `Text.set_size` for accepted string values.

        colors :
            Color of each label

            - if *None*, the color of each label matches the color of
              the corresponding contour

            - if one string color, e.g., *colors* = 'r' or *colors* =
              'red', all labels will be plotted in this color

            - if a tuple of matplotlib color args (string, float, rgb, etc),
              different labels will be plotted in different colors in the order
              specified

        inline : bool, optional
            If ``True`` the underlying contour is removed where the label is
            placed. Default is ``True``.

        inline_spacing : float, optional
            Space in pixels to leave on each side of label when
            placing inline. Defaults to 5.

            This spacing will be exact for labels at locations where the
            contour is straight, less so for labels on curved contours.

        fmt : string or dict, optional
            A format string for the label. Default is '%1.3f'

            Alternatively, this can be a dictionary matching contour
            levels with arbitrary strings to use for each contour level
            (i.e., fmt[level]=string), or it can be any callable, such
            as a :class:`~matplotlib.ticker.Formatter` instance, that
            returns a string when called with a numeric contour level.

        manual : bool or iterable, optional
            If ``True``, contour labels will be placed manually using
            mouse clicks. Click the first button near a contour to
            add a label, click the second button (or potentially both
            mouse buttons at once) to finish adding labels. The third
            button can be used to remove the last label added, but
            only if labels are not inline. Alternatively, the keyboard
            can be used to select label locations (enter to end label
            placement, delete or backspace act like the third mouse button,
            and any other key will select a label location).

            *manual* can also be an iterable object of x,y tuples.
            Contour labels will be created as if mouse is clicked at each
            x,y positions.

        rightside_up : bool, optional
            If ``True``, label rotations will always be plus
            or minus 90 degrees from level. Default is ``True``.

        use_clabeltext : bool, optional
            If ``True``, `ClabelText` class (instead of `Text`) is used to
            create labels. `ClabelText` recalculates rotation angles
            of texts during the drawing time, therefore this can be used if
            aspect of the axes changes. Default is ``False``.
        """
        self.labelFmt = ...
        self.labelManual = ...
        self.rightside_up = ...
        self.labelLevelList = ...
        self.labelIndiceList = ...
        self.labelFontProps = ...
        self.labelFontSizeList = ...
        self.labelXYs = ...
        self.cl = ...
        self.cl_xy = ...
        self.cl_cvalues = ...
        self.labelTextsList = ...
    
    def print_label(self, linecontour, labelwidth):
        "Return *False* if contours are too short for a label."
        ...
    
    def too_close(self, x, y, lw):
        "Return *True* if a label is already near this location."
        ...
    
    def get_label_coords(self, distances, XX, YY, ysize, lw):
        """
        Return x, y, and the index of a label location.

        Labels are plotted at a location with the smallest
        deviation of the contour from a straight line
        unless there is another label nearby, in which case
        the next best place on the contour is picked up.
        If all such candidates are rejected, the beginning
        of the contour is chosen.
        """
        ...
    
    def get_label_width(self, lev, fmt, fsize):
        """
        Return the width of the label in points.
        """
        ...
    
    @cbook.deprecated("2.2")
    def get_real_label_width(self, lev, fmt, fsize):
        """
        This computes actual onscreen label width.
        This uses some black magic to determine onscreen extent of non-drawn
        label.  This magic may not be very robust.

        This method is not being used, and may be modified or removed.
        """
        ...
    
    def set_label_props(self, label, text, color):
        """Set the label properties - color, fontsize, text."""
        ...
    
    def get_text(self, lev, fmt):
        """Get the text of the label."""
        ...
    
    def locate_label(self, linecontour, labelwidth):
        """
        Find good place to draw a label (relatively flat part of the contour).
        """
        ...
    
    def calc_label_rot_and_inline(self, slc, ind, lw, lc: Optional[Any] = ..., spacing=...):
        """
        This function calculates the appropriate label rotation given
        the linecontour coordinates in screen units, the index of the
        label location and the label width.

        It will also break contour and calculate inlining if *lc* is
        not empty (lc defaults to the empty list if None).  *spacing*
        is the space around the label in pixels to leave empty.

        Do both of these tasks at once to avoid calculating path lengths
        multiple times, which is relatively costly.

        The method used here involves calculating the path length
        along the contour in pixel coordinates and then looking
        approximately label width / 2 away from central point to
        determine rotation and then to break contour if desired.
        """
        ...
    
    def _get_label_text(self, x, y, rotation):
        ...
    
    def _get_label_clabeltext(self, x, y, rotation):
        ...
    
    def _add_label(self, t, x, y, lev, cvalue):
        ...
    
    def add_label(self, x, y, rotation, lev, cvalue):
        """
        Add contour label using :class:`~matplotlib.text.Text` class.
        """
        ...
    
    def add_label_clabeltext(self, x, y, rotation, lev, cvalue):
        """
        Add contour label using :class:`ClabelText` class.
        """
        ...
    
    def add_label_near(self, x, y, inline: bool = ..., inline_spacing=..., transform: Optional[Any] = ...):
        """
        Add a label near the point (x, y). If transform is None
        (default), (x, y) is in data coordinates; if transform is
        False, (x, y) is in display coordinates; otherwise, the
        specified transform will be used to translate (x, y) into
        display coordinates.

        Parameters
        ----------
        x, y : float
            The approximate location of the label.

        inline : bool, optional, default: True
            If *True* remove the segment of the contour beneath the label.

        inline_spacing : int, optional, default: 5
            Space in pixels to leave on each side of label when placing
            inline. This spacing will be exact for labels at locations where
            the contour is straight, less so for labels on curved contours.
        """
        ...
    
    def pop_label(self, index=...):
        """Defaults to removing last label, but any index can be supplied"""
        ...
    
    def labels(self, inline, inline_spacing):
        ...
    


def _find_closest_point_on_leg(p1, p2, p0):
    """Find the closest point to p0 on line segment connecting p1 and p2."""
    ...

def _is_closed_polygon(X):
    """
    Return whether first and last object in a sequence are the same. These are
    presumably coordinates on a polygonal curve, in which case this function
    tests if that curve is closed.
    """
    ...

def _find_closest_point_on_path(lc, point):
    """
    lc: coordinates of vertices
    point: coordinates of test point
    """
    ...

class ContourSet(cm.ScalarMappable, ContourLabeler):
    """
    Store a set of contour lines or filled regions.

    User-callable method: `~.axes.Axes.clabel`

    Parameters
    ----------
    ax : `~.axes.Axes`

    levels : [level0, level1, ..., leveln]
        A list of floating point numbers indicating the contour
        levels.

    allsegs : [level0segs, level1segs, ...]
        List of all the polygon segments for all the *levels*.
        For contour lines ``len(allsegs) == len(levels)``, and for
        filled contour regions ``len(allsegs) = len(levels)-1``. The lists
        should look like::

            level0segs = [polygon0, polygon1, ...]
            polygon0 = array_like [[x0,y0], [x1,y1], ...]

    allkinds : ``None`` or [level0kinds, level1kinds, ...]
        Optional list of all the polygon vertex kinds (code types), as
        described and used in Path. This is used to allow multiply-
        connected paths such as holes within filled polygons.
        If not ``None``, ``len(allkinds) == len(allsegs)``. The lists
        should look like::

            level0kinds = [polygon0kinds, ...]
            polygon0kinds = [vertexcode0, vertexcode1, ...]

        If *allkinds* is not ``None``, usually all polygons for a
        particular contour level are grouped together so that
        ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.

    kwargs :
        Keyword arguments are as described in the docstring of
        `~.axes.Axes.contour`.

    Attributes
    ----------
    ax:
        The axes object in which the contours are drawn.

    collections:
        A silent_list of LineCollections or PolyCollections.

    levels:
        Contour levels.

    layers:
        Same as levels for line contours; half-way between
        levels for filled contours.  See :meth:`_process_colors`.
    """
    def __init__(self, ax, *args, **kwargs):
        """
        Draw contour lines or filled regions, depending on
        whether keyword arg *filled* is ``False`` (default) or ``True``.

        Call signature::

            ContourSet(ax, levels, allsegs, [allkinds], **kwargs)

        Parameters
        ----------
        ax :
            The `~.axes.Axes` object to draw on.

        levels : [level0, level1, ..., leveln]
            A list of floating point numbers indicating the contour
            levels.

        allsegs : [level0segs, level1segs, ...]
            List of all the polygon segments for all the *levels*.
            For contour lines ``len(allsegs) == len(levels)``, and for
            filled contour regions ``len(allsegs) = len(levels)-1``. The lists
            should look like::

                level0segs = [polygon0, polygon1, ...]
                polygon0 = array_like [[x0,y0], [x1,y1], ...]

        allkinds : [level0kinds, level1kinds, ...], optional
            Optional list of all the polygon vertex kinds (code types), as
            described and used in Path. This is used to allow multiply-
            connected paths such as holes within filled polygons.
            If not ``None``, ``len(allkinds) == len(allsegs)``. The lists
            should look like::

                level0kinds = [polygon0kinds, ...]
                polygon0kinds = [vertexcode0, vertexcode1, ...]

            If *allkinds* is not ``None``, usually all polygons for a
            particular contour level are grouped together so that
            ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.

        **kwargs
            Keyword arguments are as described in the docstring of
            `~axes.Axes.contour`.
        """
        self.ax = ...
        self.levels = ...
        self.filled = ...
        self.linewidths = ...
        self.linestyles = ...
        self.hatches = ...
        self.alpha = ...
        self.origin = ...
        self.extent = ...
        self.colors = ...
        self.extend = ...
        self.antialiased = ...
        self.nchunk = ...
        self.locator = ...
        self.labelTexts = ...
        self.labelCValues = ...
    
    def get_transform(self):
        """
        Return the :class:`~matplotlib.transforms.Transform`
        instance used by this ContourSet.
        """
        ...
    
    def __getstate__(self):
        ...
    
    def legend_elements(self, variable_name=..., str_format=...):
        """
        Return a list of artists and labels suitable for passing through
        to :func:`plt.legend` which represent this ContourSet.

        The labels have the form "0 < x <= 1" stating the data ranges which
        the artists represent.

        Parameters
        ----------
        variable_name : str
            The string used inside the inequality used on the labels.

        str_format : function: float -> str
            Function used to format the numbers in the labels.

        Returns
        -------
        artists : List[`.Artist`]
            A list of the artists.

        labels : List[str]
            A list of the labels.

        """
        ...
    
    def _process_args(self, *args, **kwargs):
        """
        Process *args* and *kwargs*; override in derived classes.

        Must set self.levels, self.zmin and self.zmax, and update axes
        limits.
        """
        self.levels = ...
        self.allsegs = ...
        self.allkinds = ...
        self.zmax = ...
        self.zmin = ...
    
    def _get_allsegs_and_allkinds(self):
        """
        Override in derived classes to create and return allsegs and allkinds.
        allkinds can be None.
        """
        ...
    
    def _get_lowers_and_uppers(self):
        """
        Return (lowers,uppers) for filled contours.
        """
        ...
    
    def _make_paths(self, segs, kinds):
        ...
    
    def changed(self):
        self.tcolors = ...
    
    def _autolev(self, N):
        """
        Select contour levels to span the data.

        We need two more levels for filled contours than for
        line contours, because for the latter we need to specify
        the lower and upper boundary of each range. For example,
        a single contour boundary, say at z = 0, requires only
        one contour line, but two filled regions, and therefore
        three levels to provide boundaries for both regions.
        """
        ...
    
    def _contour_level_args(self, z, args):
        """
        Determine the contour levels and store in self.levels.
        """
        ...
    
    def _process_levels(self):
        """
        Assign values to :attr:`layers` based on :attr:`levels`,
        adding extended layers as needed if contours are filled.

        For line contours, layers simply coincide with levels;
        a line is a thin layer.  No extended levels are needed
        with line contours.
        """
        self.layers = ...
    
    def _process_colors(self):
        """
        Color argument processing for contouring.

        Note that we base the color mapping on the contour levels
        and layers, not on the actual range of the Z values.  This
        means we don't have to worry about bad values in Z, and we
        always have the full dynamic range available for the selected
        levels.

        The color is based on the midpoint of the layer, except for
        extended end layers.  By default, the norm vmin and vmax
        are the extreme values of the non-extended levels.  Hence,
        the layer color extremes are not the extreme values of
        the colormap itself, but approach those values as the number
        of levels increases.  An advantage of this scheme is that
        line contours, when added to filled contours, take on
        colors that are consistent with those of the filled regions;
        for example, a contour line on the boundary between two
        regions will have a color intermediate between those
        of the regions.

        """
        self.monochrome = ...
    
    def _process_linewidths(self):
        ...
    
    def _process_linestyles(self):
        ...
    
    def get_alpha(self):
        """returns alpha to be applied to all ContourSet artists"""
        ...
    
    def set_alpha(self, alpha):
        """
        Set the alpha blending value for all ContourSet artists.
        *alpha* must be between 0 (transparent) and 1 (opaque).
        """
        self.alpha = ...
    
    def find_nearest_contour(self, x, y, indices: Optional[Any] = ..., pixel: bool = ...):
        """
        Finds contour that is closest to a point.  Defaults to
        measuring distance in pixels (screen space - useful for manual
        contour labeling), but this can be controlled via a keyword
        argument.

        Returns a tuple containing the contour, segment, index of
        segment, x & y of segment point and distance to minimum point.

        Optional keyword arguments:

          *indices*:
            Indexes of contour levels to consider when looking for
            nearest point.  Defaults to using all levels.

          *pixel*:
            If *True*, measure distance in pixel space, if not, measure
            distance in axes space.  Defaults to *True*.

        """
        ...
    


class QuadContourSet(ContourSet):
    """
    Create and store a set of contour lines or filled regions.

    User-callable method: `~axes.Axes.clabel`

    Attributes
    ----------
    ax:
        The axes object in which the contours are drawn.

    collections:
        A silent_list of LineCollections or PolyCollections.

    levels:
        Contour levels.

    layers:
        Same as levels for line contours; half-way between
        levels for filled contours. See :meth:`_process_colors` method.
    """
    def _process_args(self, *args, **kwargs):
        """
        Process args and kwargs.
        """
        ...
    
    def _get_allsegs_and_allkinds(self):
        """Compute ``allsegs`` and ``allkinds`` using C extension."""
        ...
    
    def _contour_args(self, args, kwargs):
        self.zmax = ...
        self.zmin = ...
    
    def _check_xyz(self, args, kwargs):
        """
        For functions like contour, check that the dimensions
        of the input arrays match; if x and y are 1D, convert
        them to 2D using meshgrid.

        Possible change: I think we should make and use an ArgumentError
        Exception class (here and elsewhere).
        """
        ...
    
    def _initialize_x_y(self, z):
        """
        Return X, Y arrays such that contour(Z) will match imshow(Z)
        if origin is not None.
        The center of pixel Z[i,j] depends on origin:
        if origin is None, x = j, y = i;
        if origin is 'lower', x = j + 0.5, y = i + 0.5;
        if origin is 'upper', x = j + 0.5, y = Nrows - i - 0.5
        If extent is not None, x and y will be scaled to match,
        as in imshow.
        If origin is None and extent is not None, then extent
        will give the minimum and maximum values of x and y.
        """
        ...
    
    _contour_doc = ...


