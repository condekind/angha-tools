"""
This type stub file was generated by pyright.
"""

import matplotlib.axis as maxis
import matplotlib.ticker as mticker
import matplotlib.transforms as mtransforms
from matplotlib.axes import Axes
from matplotlib import docstring
from typing import Any, Optional

class PolarTransform(mtransforms.Transform):
    """
    The base polar transform.  This handles projection *theta* and
    *r* into Cartesian coordinate space *x* and *y*, but does not
    perform the ultimate affine transformation into the correct
    position.
    """
    input_dims = ...
    output_dims = ...
    is_separable = ...
    def __init__(self, axis: Optional[Any] = ..., use_rmin: bool = ..., _apply_theta_transforms: bool = ...):
        ...
    
    def __str__(self):
        ...
    
    def transform_non_affine(self, tr):
        ...
    
    def transform_path_non_affine(self, path):
        ...
    
    def inverted(self):
        ...
    


class PolarAffine(mtransforms.Affine2DBase):
    """
    The affine part of the polar projection.  Scales the output so
    that maximum radius rests on the edge of the axes circle.
    """
    def __init__(self, scale_transform, limits):
        """
        *limits* is the view limit of the data.  The only part of
        its bounds that is used is the y limits (for the radius limits).
        The theta range is handled by the non-affine transform.
        """
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


class InvertedPolarTransform(mtransforms.Transform):
    """
    The inverse of the polar transform, mapping Cartesian
    coordinate space *x* and *y* back to *theta* and *r*.
    """
    input_dims = ...
    output_dims = ...
    is_separable = ...
    def __init__(self, axis: Optional[Any] = ..., use_rmin: bool = ..., _apply_theta_transforms: bool = ...):
        ...
    
    def __str__(self):
        ...
    
    def transform_non_affine(self, xy):
        ...
    
    def inverted(self):
        ...
    


class ThetaFormatter(mticker.Formatter):
    """
    Used to format the *theta* tick labels.  Converts the native
    unit of radians into degrees and adds a degree symbol.
    """
    def __call__(self, x, pos: Optional[Any] = ...):
        ...
    


class _AxisWrapper(object):
    def __init__(self, axis):
        ...
    
    def get_view_interval(self):
        ...
    
    def set_view_interval(self, vmin, vmax):
        ...
    
    def get_minpos(self):
        ...
    
    def get_data_interval(self):
        ...
    
    def set_data_interval(self, vmin, vmax):
        ...
    
    def get_tick_space(self):
        ...
    


class ThetaLocator(mticker.Locator):
    """
    Used to locate theta ticks.

    This will work the same as the base locator except in the case that the
    view spans the entire circle. In such cases, the previously used default
    locations of every 45 degrees are returned.
    """
    def __init__(self, base):
        self.base = ...
        self.axis = ...
    
    def set_axis(self, axis):
        self.axis = ...
    
    def __call__(self):
        ...
    
    def autoscale(self):
        ...
    
    def pan(self, numsteps):
        ...
    
    def refresh(self):
        ...
    
    def view_limits(self, vmin, vmax):
        ...
    
    def zoom(self, direction):
        ...
    


class ThetaTick(maxis.XTick):
    """
    A theta-axis tick.

    This subclass of `XTick` provides angular ticks with some small
    modification to their re-positioning such that ticks are rotated based on
    tick location. This results in ticks that are correctly perpendicular to
    the arc spine.

    When 'auto' rotation is enabled, labels are also rotated to be parallel to
    the spine. The label padding is also applied here since it's not possible
    to use a generic axes transform to produce tick-specific padding.
    """
    def __init__(self, axes, *args, **kwargs):
        ...
    
    def _get_text1(self):
        ...
    
    def _get_text2(self):
        ...
    
    def _apply_params(self, **kw):
        ...
    
    def _update_padding(self, pad, angle):
        ...
    
    def update_position(self, loc):
        ...
    


class ThetaAxis(maxis.XAxis):
    """
    A theta Axis.

    This overrides certain properties of an `XAxis` to provide special-casing
    for an angular axis.
    """
    __name__ = ...
    axis_name = ...
    def _get_tick(self, major):
        ...
    
    def _wrap_locator_formatter(self):
        self.isDefault_majloc = ...
        self.isDefault_majfmt = ...
    
    def cla(self):
        ...
    
    def _set_scale(self, value, **kwargs):
        ...
    
    def _copy_tick_props(self, src, dest):
        'Copy the props from src tick to dest tick'
        ...
    


class RadialLocator(mticker.Locator):
    """
    Used to locate radius ticks.

    Ensures that all ticks are strictly positive.  For all other
    tasks, it delegates to the base
    :class:`~matplotlib.ticker.Locator` (which may be different
    depending on the scale of the *r*-axis.
    """
    def __init__(self, base, axes: Optional[Any] = ...):
        self.base = ...
    
    def __call__(self):
        ...
    
    def autoscale(self):
        ...
    
    def pan(self, numsteps):
        ...
    
    def zoom(self, direction):
        ...
    
    def refresh(self):
        ...
    
    def view_limits(self, vmin, vmax):
        ...
    


class _ThetaShift(mtransforms.ScaledTranslation):
    """
    Apply a padding shift based on axes theta limits.

    This is used to create padding for radial ticks.

    Parameters
    ----------
    axes : matplotlib.axes.Axes
        The owning axes; used to determine limits.
    pad : float
        The padding to apply, in points.
    start : str, {'min', 'max', 'rlabel'}
        Whether to shift away from the start (``'min'``) or the end (``'max'``)
        of the axes, or using the rlabel position (``'rlabel'``).
    """
    def __init__(self, axes, pad, mode):
        self.axes = ...
        self.mode = ...
        self.pad = ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


class RadialTick(maxis.YTick):
    """
    A radial-axis tick.

    This subclass of `YTick` provides radial ticks with some small modification
    to their re-positioning such that ticks are rotated based on axes limits.
    This results in ticks that are correctly perpendicular to the spine. Labels
    are also rotated to be perpendicular to the spine, when 'auto' rotation is
    enabled.
    """
    def _get_text1(self):
        ...
    
    def _get_text2(self):
        ...
    
    def _determine_anchor(self, mode, angle, start):
        ...
    
    def update_position(self, loc):
        ...
    


class RadialAxis(maxis.YAxis):
    """
    A radial Axis.

    This overrides certain properties of a `YAxis` to provide special-casing
    for a radial axis.
    """
    __name__ = ...
    axis_name = ...
    def __init__(self, *args, **kwargs):
        ...
    
    def _get_tick(self, major):
        ...
    
    def _wrap_locator_formatter(self):
        self.isDefault_majloc = ...
    
    def cla(self):
        ...
    
    def _set_scale(self, value, **kwargs):
        ...
    


def _is_full_circle_deg(thetamin, thetamax):
    """
    Determine if a wedge (in degrees) spans the full circle.

    The condition is derived from :class:`~matplotlib.patches.Wedge`.
    """
    ...

def _is_full_circle_rad(thetamin, thetamax):
    """
    Determine if a wedge (in radians) spans the full circle.

    The condition is derived from :class:`~matplotlib.patches.Wedge`.
    """
    ...

class _WedgeBbox(mtransforms.Bbox):
    """
    Transform (theta,r) wedge Bbox into axes bounding box.

    Parameters
    ----------
    center : tuple of float
        Center of the wedge
    viewLim : `~matplotlib.transforms.Bbox`
        Bbox determining the boundaries of the wedge
    originLim : `~matplotlib.transforms.Bbox`
        Bbox determining the origin for the wedge, if different from *viewLim*
    """
    def __init__(self, center, viewLim, originLim, **kwargs):
        ...
    
    def __str__(self):
        ...
    
    def get_points(self):
        ...
    


class PolarAxes(Axes):
    """
    A polar graph projection, where the input dimensions are *theta*, *r*.

    Theta starts pointing east and goes anti-clockwise.
    """
    name = ...
    def __init__(self, *args, **kwargs):
        """
        Create a new Polar Axes for a polar plot.
        """
        self.use_sticky_edges = ...
    
    def cla(self):
        ...
    
    def _init_axis(self):
        "move this out of __init__ because non-separable axes don't use it"
        self.xaxis = ...
        self.yaxis = ...
    
    def _set_lim_and_transforms(self):
        self.transShift = ...
        self.transScale = ...
        self.axesLim = ...
        self.transWedge = ...
        self.transAxes = ...
        self.transProjection = ...
        self.transProjectionAffine = ...
        self.transData = ...
    
    def get_xaxis_transform(self, which=...):
        ...
    
    def get_xaxis_text1_transform(self, pad):
        ...
    
    def get_xaxis_text2_transform(self, pad):
        ...
    
    def get_yaxis_transform(self, which=...):
        ...
    
    def get_yaxis_text1_transform(self, pad):
        ...
    
    def get_yaxis_text2_transform(self, pad):
        ...
    
    def draw(self, *args, **kwargs):
        ...
    
    def _gen_axes_patch(self):
        ...
    
    def _gen_axes_spines(self):
        ...
    
    def set_thetamax(self, thetamax):
        ...
    
    def get_thetamax(self):
        ...
    
    def set_thetamin(self, thetamin):
        ...
    
    def get_thetamin(self):
        ...
    
    def set_thetalim(self, *args, **kwargs):
        ...
    
    def set_theta_offset(self, offset):
        """
        Set the offset for the location of 0 in radians.
        """
        ...
    
    def get_theta_offset(self):
        """
        Get the offset for the location of 0 in radians.
        """
        ...
    
    def set_theta_zero_location(self, loc, offset=...):
        """
        Sets the location of theta's zero.  (Calls set_theta_offset
        with the correct value in radians under the hood.)

        loc : str
            May be one of "N", "NW", "W", "SW", "S", "SE", "E", or "NE".

        offset : float, optional
            An offset in degrees to apply from the specified `loc`. **Note:**
            this offset is *always* applied counter-clockwise regardless of
            the direction setting.
        """
        ...
    
    def set_theta_direction(self, direction):
        """
        Set the direction in which theta increases.

        clockwise, -1:
           Theta increases in the clockwise direction

        counterclockwise, anticlockwise, 1:
           Theta increases in the counterclockwise direction
        """
        ...
    
    def get_theta_direction(self):
        """
        Get the direction in which theta increases.

        -1:
           Theta increases in the clockwise direction

        1:
           Theta increases in the counterclockwise direction
        """
        ...
    
    def set_rmax(self, rmax):
        ...
    
    def get_rmax(self):
        ...
    
    def set_rmin(self, rmin):
        ...
    
    def get_rmin(self):
        ...
    
    def set_rorigin(self, rorigin):
        ...
    
    def get_rorigin(self):
        ...
    
    def set_rlim(self, *args, **kwargs):
        ...
    
    def get_rlabel_position(self):
        """
        Returns
        -------
        float
            The theta position of the radius labels in degrees.
        """
        ...
    
    def set_rlabel_position(self, value):
        """Updates the theta position of the radius labels.

        Parameters
        ----------
        value : number
            The angular position of the radius labels in degrees.
        """
        ...
    
    def set_yscale(self, *args, **kwargs):
        ...
    
    def set_rscale(self, *args, **kwargs):
        ...
    
    def set_rticks(self, *args, **kwargs):
        ...
    
    @docstring.dedent_interpd
    def set_thetagrids(self, angles, labels: Optional[Any] = ..., frac: Optional[Any] = ..., fmt: Optional[Any] = ..., **kwargs):
        """
        Set the angles at which to place the theta grids (these
        gridlines are equal along the theta dimension).  *angles* is in
        degrees.

        *labels*, if not None, is a ``len(angles)`` list of strings of
        the labels to use at each angle.

        If *labels* is None, the labels will be ``fmt %% angle``

        *frac* is the fraction of the polar axes radius at which to
        place the label (1 is the edge). e.g., 1.05 is outside the axes
        and 0.95 is inside the axes.

        Return value is a list of tuples (*line*, *label*), where
        *line* is :class:`~matplotlib.lines.Line2D` instances and the
        *label* is :class:`~matplotlib.text.Text` instances.

        kwargs are optional text properties for the labels:

        %(Text)s

        ACCEPTS: sequence of floats
        """
        ...
    
    @docstring.dedent_interpd
    def set_rgrids(self, radii, labels: Optional[Any] = ..., angle: Optional[Any] = ..., fmt: Optional[Any] = ..., **kwargs):
        """
        Set the radial locations and labels of the *r* grids.

        The labels will appear at radial distances *radii* at the
        given *angle* in degrees.

        *labels*, if not None, is a ``len(radii)`` list of strings of the
        labels to use at each radius.

        If *labels* is None, the built-in formatter will be used.

        Return value is a list of tuples (*line*, *label*), where
        *line* is :class:`~matplotlib.lines.Line2D` instances and the
        *label* is :class:`~matplotlib.text.Text` instances.

        kwargs are optional text properties for the labels:

        %(Text)s

        ACCEPTS: sequence of floats
        """
        ...
    
    def set_xscale(self, scale, *args, **kwargs):
        ...
    
    def format_coord(self, theta, r):
        """
        Return a format string formatting the coordinate using Unicode
        characters.
        """
        ...
    
    def get_data_ratio(self):
        '''
        Return the aspect ratio of the data itself.  For a polar plot,
        this should always be 1.0
        '''
        ...
    
    def can_zoom(self):
        """
        Return *True* if this axes supports the zoom box button functionality.

        Polar axes do not support zoom boxes.
        """
        ...
    
    def can_pan(self):
        """
        Return *True* if this axes supports the pan/zoom button functionality.

        For polar axes, this is slightly misleading. Both panning and
        zooming are performed by the same button. Panning is performed
        in azimuth while zooming is done along the radial.
        """
        ...
    
    def start_pan(self, x, y, button):
        ...
    
    def end_pan(self):
        ...
    
    def drag_pan(self, button, key, x, y):
        ...
    


