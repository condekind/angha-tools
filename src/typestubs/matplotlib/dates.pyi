"""
This type stub file was generated by pyright.
"""

import datetime
import logging
import numpy as np
import matplotlib.units as units
import matplotlib.ticker as ticker
from dateutil.rrule import DAILY, FR, HOURLY, MINUTELY, MO, MONTHLY, SA, SECONDLY, SU, TH, TU, WE, WEEKLY, YEARLY, rrule
from dateutil.relativedelta import relativedelta
from typing import Any, Optional

"""
Matplotlib provides sophisticated date plotting capabilities, standing on the
shoulders of python :mod:`datetime`, the add-on modules :mod:`pytz` and
:mod:`dateutil`.


.. _date-format:

Matplotlib date format
----------------------
Matplotlib represents dates using floating point numbers specifying the number
of days since 0001-01-01 UTC, plus 1.  For example, 0001-01-01, 06:00 is 1.25,
not 0.25. Values < 1, i.e. dates before 0001-01-01 UTC are not supported.

There are a number of helper functions to convert between :mod:`datetime`
objects and Matplotlib dates:

.. currentmodule:: matplotlib.dates

.. autosummary::
   :nosignatures:

   date2num
   num2date
   num2timedelta
   epoch2num
   num2epoch
   mx2num
   drange

.. note::

   Like Python's datetime, mpl uses the Gregorian calendar for all
   conversions between dates and floating point numbers. This practice
   is not universal, and calendar differences can cause confusing
   differences between what Python and mpl give as the number of days
   since 0001-01-01 and what other software and databases yield.  For
   example, the US Naval Observatory uses a calendar that switches
   from Julian to Gregorian in October, 1582.  Hence, using their
   calculator, the number of days between 0001-01-01 and 2006-04-01 is
   732403, whereas using the Gregorian calendar via the datetime
   module we find::

     In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()
     Out[1]: 732401

All the Matplotlib date converters, tickers and formatters are timezone aware.
If no explicit timezone is provided, the rcParam ``timezone`` is assumend.  If
you want to use a custom time zone, pass a :class:`pytz.timezone` instance
with the tz keyword argument to :func:`num2date`, :func:`.plot_date`, and any
custom date tickers or locators you create.
See `pytz <http://pythonhosted.org/pytz/>`_ for information on :mod:`pytz` and
timezone handling.

A wide range of specific and general purpose date tick locators and
formatters are provided in this module.  See
:mod:`matplotlib.ticker` for general information on tick locators
and formatters.  These are described below.


The `dateutil module <https://dateutil.readthedocs.io/en/stable/>`_ provides
additional code to handle date ticking, making it easy to place ticks
on any kinds of dates.  See examples below.

Date tickers
------------

Most of the date tickers can locate single or multiple values.  For
example::

    # import constants for the days of the week
    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU

    # tick on mondays every week
    loc = WeekdayLocator(byweekday=MO, tz=tz)

    # tick on mondays and saturdays
    loc = WeekdayLocator(byweekday=(MO, SA))

In addition, most of the constructors take an interval argument::

    # tick on mondays every second week
    loc = WeekdayLocator(byweekday=MO, interval=2)

The rrule locator allows completely general date ticking::

    # tick every 5th easter
    rule = rrulewrapper(YEARLY, byeaster=1, interval=5)
    loc = RRuleLocator(rule)

Here are all the date tickers:

    * :class:`MicrosecondLocator`: locate microseconds

    * :class:`SecondLocator`: locate seconds

    * :class:`MinuteLocator`: locate minutes

    * :class:`HourLocator`: locate hours

    * :class:`DayLocator`: locate specified days of the month

    * :class:`WeekdayLocator`: Locate days of the week, e.g., MO, TU

    * :class:`MonthLocator`: locate months, e.g., 7 for july

    * :class:`YearLocator`: locate years that are multiples of base

    * :class:`RRuleLocator`: locate using a
      :class:`matplotlib.dates.rrulewrapper`.  The
      :class:`rrulewrapper` is a simple wrapper around a
      :class:`dateutil.rrule` (`dateutil
      <https://dateutil.readthedocs.io/en/stable/>`_) which allow almost
      arbitrary date tick specifications.  See `rrule example
      <../gallery/ticks_and_spines/date_demo_rrule.html>`_.

    * :class:`AutoDateLocator`: On autoscale, this class picks the best
      :class:`DateLocator` (e.g., :class:`RRuleLocator`)
      to set the view limits and the tick
      locations.  If called with ``interval_multiples=True`` it will
      make ticks line up with sensible multiples of the tick intervals.  E.g.
      if the interval is 4 hours, it will pick hours 0, 4, 8, etc as ticks.
      This behaviour is not guaranteed by default.

Date formatters
---------------

Here all all the date formatters:

    * :class:`AutoDateFormatter`: attempts to figure out the best format
      to use.  This is most useful when used with the :class:`AutoDateLocator`.

    * :class:`DateFormatter`: use :func:`strftime` format strings

    * :class:`IndexDateFormatter`: date plots with implicit *x*
      indexing.
"""
_log = logging.getLogger(__name__)
__all__ = ('date2num', 'num2date', 'num2timedelta', 'drange', 'epoch2num', 'num2epoch', 'mx2num', 'DateFormatter', 'IndexDateFormatter', 'AutoDateFormatter', 'DateLocator', 'RRuleLocator', 'AutoDateLocator', 'YearLocator', 'MonthLocator', 'WeekdayLocator', 'DayLocator', 'HourLocator', 'MinuteLocator', 'SecondLocator', 'MicrosecondLocator', 'rrule', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU', 'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY', 'MICROSECONDLY', 'relativedelta', 'seconds', 'minutes', 'hours', 'weeks')
_log = logging.getLogger(__name__)
class _UTC(datetime.tzinfo):
    """UTC"""
    def utcoffset(self, dt):
        ...
    
    def tzname(self, dt):
        ...
    
    def dst(self, dt):
        ...
    


UTC = _UTC()
def _get_rc_timezone():
    """
    Retrieve the preferred timeszone from the rcParams dictionary.
    """
    ...

EPOCH_OFFSET = float(datetime.datetime(1970, 1, 1).toordinal())
JULIAN_OFFSET = 1721424.5
MICROSECONDLY = SECONDLY + 1
HOURS_PER_DAY = 24
MIN_PER_HOUR = 60
SEC_PER_MIN = 60
MONTHS_PER_YEAR = 12
DAYS_PER_WEEK = 7
DAYS_PER_MONTH = 30
DAYS_PER_YEAR = 365
MINUTES_PER_DAY = MIN_PER_HOUR * HOURS_PER_DAY
SEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR
SEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY
SEC_PER_WEEK = SEC_PER_DAY * DAYS_PER_WEEK
MUSECONDS_PER_DAY = 1000000 * SEC_PER_DAY
WEEKDAYS = (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY)
def _to_ordinalf(dt):
    """
    Convert :mod:`datetime` or :mod:`date` to the Gregorian date as UTC float
    days, preserving hours, minutes, seconds and microseconds.  Return value
    is a :func:`float`.
    """
    ...

_to_ordinalf_np_vectorized = np.vectorize(_to_ordinalf)
def _dt64_to_ordinalf(d):
    """
    Convert `numpy.datetime64` or an ndarray of those types to Gregorian
    date as UTC float.  Roundoff is via float64 precision.  Practically:
    microseconds for dates between 290301 BC, 294241 AD, milliseconds for
    larger dates (see `numpy.datetime64`).  Nanoseconds aren't possible
    because we do times compared to ``0001-01-01T00:00:00`` (plus one day).
    """
    ...

def _from_ordinalf(x, tz: Optional[Any] = ...):
    """
    Convert Gregorian float of the date, preserving hours, minutes,
    seconds and microseconds.  Return value is a `.datetime`.

    The input date *x* is a float in ordinal days at UTC, and the output will
    be the specified `.datetime` object corresponding to that time in
    timezone *tz*, or if *tz* is ``None``, in the timezone specified in
    :rc:`timezone`.
    """
    ...

_from_ordinalf_np_vectorized = np.vectorize(_from_ordinalf)
class strpdate2num(object):
    """
    Use this class to parse date strings to matplotlib datenums when
    you know the date format string of the date you are parsing.
    """
    def __init__(self, fmt):
        """ fmt: any valid strptime format is supported """
        self.fmt = ...
    
    def __call__(self, s):
        """s : string to be converted
           return value: a date2num float
        """
        ...
    


class bytespdate2num(strpdate2num):
    """
    Use this class to parse date strings to matplotlib datenums when
    you know the date format string of the date you are parsing.  See
    :file:`examples/misc/load_converter.py`.
    """
    def __init__(self, fmt, encoding=...):
        """
        Args:
            fmt: any valid strptime format is supported
            encoding: encoding to use on byte input (default: 'utf-8')
        """
        self.encoding = ...
    
    def __call__(self, b):
        """
        Args:
            b: byte input to be converted
        Returns:
            A date2num float
        """
        ...
    


_dateutil_parser_parse_np_vectorized = np.vectorize(dateutil.parser.parse)
def datestr2num(d, default: Optional[Any] = ...):
    """
    Convert a date string to a datenum using
    :func:`dateutil.parser.parse`.

    Parameters
    ----------
    d : string or sequence of strings
        The dates to convert.

    default : datetime instance, optional
        The default date to use when fields are missing in *d*.
    """
    ...

def date2num(d):
    """
    Convert datetime objects to Matplotlib dates.

    Parameters
    ----------
    d : `datetime.datetime` or `numpy.datetime64` or sequences of these

    Returns
    -------
    float or sequence of floats
        Number of days (fraction part represents hours, minutes, seconds, ms)
        since 0001-01-01 00:00:00 UTC, plus one.

    Notes
    -----
    The addition of one here is a historical artifact. Also, note that the
    Gregorian calendar is assumed; this is not universal practice.
    For details see the module docstring.
    """
    ...

def julian2num(j):
    """
    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).

    Parameters
    ----------
    j : float or sequence of floats
        Julian date(s)

    Returns
    -------
    float or sequence of floats
        Matplotlib date(s)
    """
    ...

def num2julian(n):
    """
    Convert a Matplotlib date (or sequence) to a Julian date (or sequence).

    Parameters
    ----------
    n : float or sequence of floats
        Matplotlib date(s)

    Returns
    -------
    float or sequence of floats
        Julian date(s)
    """
    ...

def num2date(x, tz: Optional[Any] = ...):
    """
    Convert Matplotlib dates to `~datetime.datetime` objects.

    Parameters
    ----------
    x : float or sequence of floats
        Number of days (fraction part represents hours, minutes, seconds)
        since 0001-01-01 00:00:00 UTC, plus one.
    tz : string, optional
        Timezone of *x* (defaults to rcparams ``timezone``).

    Returns
    -------
    `~datetime.datetime` or sequence of `~datetime.datetime`
        Dates are returned in timezone *tz*.

        If *x* is a sequence, a sequence of :class:`datetime` objects will
        be returned.

    Notes
    -----
    The addition of one here is a historical artifact. Also, note that the
    Gregorian calendar is assumed; this is not universal practice.
    For details, see the module docstring.
    """
    ...

def _ordinalf_to_timedelta(x):
    ...

_ordinalf_to_timedelta_np_vectorized = np.vectorize(_ordinalf_to_timedelta)
def num2timedelta(x):
    """
    Convert number of days to a `~datetime.timedelta` object.

    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will
    be returned.

    Parameters
    ----------
    x : float, sequence of floats
        Number of days. The fraction part represents hours, minutes, seconds.

    Returns
    -------
    `datetime.timedelta` or list[`datetime.timedelta`]

    """
    ...

def drange(dstart, dend, delta):
    """
    Return a sequence of equally spaced Matplotlib dates.

    The dates start at *dstart* and reach up to, but not including *dend*.
    They are spaced by *delta*.

    Parameters
    ----------
    dstart, dend : `~datetime.datetime`
        The date limits.
    delta : `datetime.timedelta`
        Spacing of the dates.

    Returns
    -------
    drange : `numpy.array`
        A list floats representing Matplotlib dates.

    """
    ...

class DateFormatter(ticker.Formatter):
    """
    Tick location is seconds since the epoch.  Use a :func:`strftime`
    format string.

    Python only supports :mod:`datetime` :func:`strftime` formatting
    for years greater than 1900.  Thanks to Andrew Dalke, Dalke
    Scientific Software who contributed the :func:`strftime` code
    below to include dates earlier than this year.
    """
    illegal_s = ...
    def __init__(self, fmt, tz: Optional[Any] = ...):
        """
        *fmt* is a :func:`strftime` format string; *tz* is the
         :class:`tzinfo` instance.
        """
        self.fmt = ...
        self.tz = ...
    
    def __call__(self, x, pos=...):
        ...
    
    def set_tzinfo(self, tz):
        self.tz = ...
    
    def _replace_common_substr(self, s1, s2, sub1, sub2, replacement):
        """Helper function for replacing substrings sub1 and sub2
        located at the same indexes in strings s1 and s2 respectively,
        with the string replacement.  It is expected that sub1 and sub2
        have the same length.  Returns the pair s1, s2 after the
        substitutions.
        """
        ...
    
    def strftime_pre_1900(self, dt, fmt: Optional[Any] = ...):
        """Call time.strftime for years before 1900 by rolling
        forward a multiple of 28 years.

        *fmt* is a :func:`strftime` format string.

        Dalke: I hope I did this math right.  Every 28 years the
        calendar repeats, except through century leap years excepting
        the 400 year leap years.  But only if you're using the Gregorian
        calendar.
        """
        ...
    
    def strftime(self, dt, fmt: Optional[Any] = ...):
        """
        Refer to documentation for :meth:`datetime.datetime.strftime`

        *fmt* is a :meth:`datetime.datetime.strftime` format string.

        Warning: For years before 1900, depending upon the current
        locale it is possible that the year displayed with %x might
        be incorrect. For years before 100, %y and %Y will yield
        zero-padded strings.
        """
        ...
    


class IndexDateFormatter(ticker.Formatter):
    """
    Use with :class:`~matplotlib.ticker.IndexLocator` to cycle format
    strings by index.
    """
    def __init__(self, t, fmt, tz: Optional[Any] = ...):
        """
        *t* is a sequence of dates (floating point days).  *fmt* is a
        :func:`strftime` format string.
        """
        self.t = ...
        self.fmt = ...
        self.tz = ...
    
    def __call__(self, x, pos=...):
        'Return the label for time *x* at position *pos*'
        ...
    


class AutoDateFormatter(ticker.Formatter):
    """
    This class attempts to figure out the best format to use.  This is
    most useful when used with the :class:`AutoDateLocator`.


    The AutoDateFormatter has a scale dictionary that maps the scale
    of the tick (the distance in days between one major tick) and a
    format string.  The default looks like this::

        self.scaled = {
            DAYS_PER_YEAR: rcParams['date.autoformat.year'],
            DAYS_PER_MONTH: rcParams['date.autoformat.month'],
            1.0: rcParams['date.autoformat.day'],
            1. / HOURS_PER_DAY: rcParams['date.autoformat.hour'],
            1. / (MINUTES_PER_DAY): rcParams['date.autoformat.minute'],
            1. / (SEC_PER_DAY): rcParams['date.autoformat.second'],
            1. / (MUSECONDS_PER_DAY): rcParams['date.autoformat.microsecond'],
            }


    The algorithm picks the key in the dictionary that is >= the
    current scale and uses that format string.  You can customize this
    dictionary by doing::


    >>> locator = AutoDateLocator()
    >>> formatter = AutoDateFormatter(locator)
    >>> formatter.scaled[1/(24.*60.)] = '%M:%S' # only show min and sec

    A custom :class:`~matplotlib.ticker.FuncFormatter` can also be used.
    The following example shows how to use a custom format function to strip
    trailing zeros from decimal seconds and adds the date to the first
    ticklabel::

        >>> def my_format_function(x, pos=None):
        ...     x = matplotlib.dates.num2date(x)
        ...     if pos == 0:
        ...         fmt = '%D %H:%M:%S.%f'
        ...     else:
        ...         fmt = '%H:%M:%S.%f'
        ...     label = x.strftime(fmt)
        ...     label = label.rstrip("0")
        ...     label = label.rstrip(".")
        ...     return label
        >>> from matplotlib.ticker import FuncFormatter
        >>> formatter.scaled[1/(24.*60.)] = FuncFormatter(my_format_function)
    """
    def __init__(self, locator, tz: Optional[Any] = ..., defaultfmt=...):
        """
        Autoformat the date labels.  The default format is the one to use
        if none of the values in ``self.scaled`` are greater than the unit
        returned by ``locator._get_unit()``.
        """
        self.defaultfmt = ...
        self.scaled = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        ...
    


class rrulewrapper(object):
    def __init__(self, freq, tzinfo: Optional[Any] = ..., **kwargs):
        ...
    
    def set(self, **kwargs):
        ...
    
    def _update_rrule(self, **kwargs):
        ...
    
    def _attach_tzinfo(self, dt, tzinfo):
        ...
    
    def _aware_return_wrapper(self, f, returns_list: bool = ...):
        """Decorator function that allows rrule methods to handle tzinfo."""
        ...
    
    def __getattr__(self, name):
        ...
    
    def __setstate__(self, state):
        ...
    


class DateLocator(ticker.Locator):
    """
    Determines the tick locations when plotting dates.

    This class is subclassed by other Locators and
    is not meant to be used on its own.
    """
    hms0d = ...
    def __init__(self, tz: Optional[Any] = ...):
        """
        *tz* is a :class:`tzinfo` instance.
        """
        self.tz = ...
    
    def set_tzinfo(self, tz):
        """
        Set time zone info.
        """
        self.tz = ...
    
    def datalim_to_dt(self):
        """
        Convert axis data interval to datetime objects.
        """
        ...
    
    def viewlim_to_dt(self):
        """
        Converts the view interval to datetime objects.
        """
        ...
    
    def _get_unit(self):
        """
        Return how many days a unit of the locator is; used for
        intelligent autoscaling.
        """
        ...
    
    def _get_interval(self):
        """
        Return the number of units for each tick.
        """
        ...
    
    def nonsingular(self, vmin, vmax):
        """
        Given the proposed upper and lower extent, adjust the range
        if it is too close to being singular (i.e. a range of ~0).

        """
        ...
    


class RRuleLocator(DateLocator):
    def __init__(self, o, tz: Optional[Any] = ...):
        self.rule = ...
    
    def __call__(self):
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def _get_unit(self):
        """
        Return how many days a unit of the locator is; used for
        intelligent autoscaling.
        """
        ...
    
    @staticmethod
    def get_unit_generic(freq):
        ...
    
    def _get_interval(self):
        ...
    
    def autoscale(self):
        """
        Set the view limits to include the data range.
        """
        ...
    


class AutoDateLocator(DateLocator):
    """
    On autoscale, this class picks the best
    :class:`DateLocator` to set the view limits and the tick
    locations.
    """
    def __init__(self, tz: Optional[Any] = ..., minticks=..., maxticks: Optional[Any] = ..., interval_multiples: bool = ...):
        """
        *minticks* is the minimum number of ticks desired, which is used to
        select the type of ticking (yearly, monthly, etc.).

        *maxticks* is the maximum number of ticks desired, which controls
        any interval between ticks (ticking every other, every 3, etc.).
        For really fine-grained control, this can be a dictionary mapping
        individual rrule frequency constants (YEARLY, MONTHLY, etc.)
        to their own maximum number of ticks.  This can be used to keep
        the number of ticks appropriate to the format chosen in
        :class:`AutoDateFormatter`. Any frequency not specified in this
        dictionary is given a default value.

        *tz* is a :class:`tzinfo` instance.

        *interval_multiples* is a boolean that indicates whether ticks
        should be chosen to be multiple of the interval. This will lock
        ticks to 'nicer' locations. For example, this will force the
        ticks to be at hours 0,6,12,18 when hourly ticking is done at
        6 hour intervals.

        The AutoDateLocator has an interval dictionary that maps the
        frequency of the tick (a constant from dateutil.rrule) and a
        multiple allowed for that ticking.  The default looks like this::

          self.intervald = {
            YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,
                      1000, 2000, 4000, 5000, 10000],
            MONTHLY : [1, 2, 3, 4, 6],
            DAILY   : [1, 2, 3, 7, 14],
            HOURLY  : [1, 2, 3, 4, 6, 12],
            MINUTELY: [1, 5, 10, 15, 30],
            SECONDLY: [1, 5, 10, 15, 30],
            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,
                           5000, 10000, 20000, 50000, 100000, 200000, 500000,
                           1000000],
            }

        The interval is used to specify multiples that are appropriate for
        the frequency of ticking. For instance, every 7 days is sensible
        for daily ticks, but for minutes/seconds, 15 or 30 make sense.
        You can customize this dictionary by doing::

          locator = AutoDateLocator()
          locator.intervald[HOURLY] = [3] # only show every 3 hours
        """
        self.minticks = ...
        self.maxticks = ...
        self.interval_multiples = ...
        self.intervald = ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def nonsingular(self, vmin, vmax):
        ...
    
    def set_axis(self, axis):
        ...
    
    def refresh(self):
        'Refresh internal information based on current limits.'
        ...
    
    def _get_unit(self):
        ...
    
    def autoscale(self):
        'Try to choose the view limits intelligently.'
        ...
    
    def get_locator(self, dmin, dmax):
        'Pick the best locator based on a distance.'
        ...
    


class YearLocator(DateLocator):
    """
    Make ticks on a given day of each year that is a multiple of base.

    Examples::

      # Tick every year on Jan 1st
      locator = YearLocator()

      # Tick every 5 years on July 4th
      locator = YearLocator(5, month=7, day=4)
    """
    def __init__(self, base=..., month=..., day=..., tz: Optional[Any] = ...):
        """
        Mark years that are multiple of base on a given month and day
        (default jan 1).
        """
        self.base = ...
        self.replaced = ...
    
    def __call__(self):
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def autoscale(self):
        """
        Set the view limits to include the data range.
        """
        ...
    


class MonthLocator(RRuleLocator):
    """
    Make ticks on occurrences of each month, e.g., 1, 3, 12.
    """
    def __init__(self, bymonth: Optional[Any] = ..., bymonthday=..., interval=..., tz: Optional[Any] = ...):
        """
        Mark every month in *bymonth*; *bymonth* can be an int or
        sequence.  Default is ``range(1,13)``, i.e. every month.

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurrence.
        """
        ...
    


class WeekdayLocator(RRuleLocator):
    """
    Make ticks on occurrences of each weekday.
    """
    def __init__(self, byweekday=..., interval=..., tz: Optional[Any] = ...):
        """
        Mark every weekday in *byweekday*; *byweekday* can be a number or
        sequence.

        Elements of *byweekday* must be one of MO, TU, WE, TH, FR, SA,
        SU, the constants from :mod:`dateutil.rrule`, which have been
        imported into the :mod:`matplotlib.dates` namespace.

        *interval* specifies the number of weeks to skip.  For example,
        ``interval=2`` plots every second week.
        """
        ...
    


class DayLocator(RRuleLocator):
    """
    Make ticks on occurrences of each day of the month.  For example,
    1, 15, 30.
    """
    def __init__(self, bymonthday: Optional[Any] = ..., interval=..., tz: Optional[Any] = ...):
        """
        Mark every day in *bymonthday*; *bymonthday* can be an int or
        sequence.

        Default is to tick every day of the month: ``bymonthday=range(1,32)``
        """
        ...
    


class HourLocator(RRuleLocator):
    """
    Make ticks on occurrences of each hour.
    """
    def __init__(self, byhour: Optional[Any] = ..., interval=..., tz: Optional[Any] = ...):
        """
        Mark every hour in *byhour*; *byhour* can be an int or sequence.
        Default is to tick every hour: ``byhour=range(24)``

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurrence.
        """
        ...
    


class MinuteLocator(RRuleLocator):
    """
    Make ticks on occurrences of each minute.
    """
    def __init__(self, byminute: Optional[Any] = ..., interval=..., tz: Optional[Any] = ...):
        """
        Mark every minute in *byminute*; *byminute* can be an int or
        sequence.  Default is to tick every minute: ``byminute=range(60)``

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurrence.
        """
        ...
    


class SecondLocator(RRuleLocator):
    """
    Make ticks on occurrences of each second.
    """
    def __init__(self, bysecond: Optional[Any] = ..., interval=..., tz: Optional[Any] = ...):
        """
        Mark every second in *bysecond*; *bysecond* can be an int or
        sequence.  Default is to tick every second: ``bysecond = range(60)``

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurrence.

        """
        ...
    


class MicrosecondLocator(DateLocator):
    """
    Make ticks on regular intervals of one or more microsecond(s).

    .. note::

        Due to the floating point representation of time in days since
        0001-01-01 UTC (plus 1), plotting data with microsecond time
        resolution does not work well with current dates.

        If you want microsecond resolution time plots, it is strongly
        recommended to use floating point seconds, not datetime-like
        time representation.

        If you really must use datetime.datetime() or similar and still
        need microsecond precision, your only chance is to use very
        early years; using year 0001 is recommended.

    """
    def __init__(self, interval=..., tz: Optional[Any] = ...):
        """
        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second microsecond.

        """
        self.tz = ...
    
    def set_axis(self, axis):
        ...
    
    def set_view_interval(self, vmin, vmax):
        ...
    
    def set_data_interval(self, vmin, vmax):
        ...
    
    def __call__(self):
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def _get_unit(self):
        """
        Return how many days a unit of the locator is; used for
        intelligent autoscaling.
        """
        ...
    
    def _get_interval(self):
        """
        Return the number of units for each tick.
        """
        ...
    


def _close_to_dt(d1, d2, epsilon=...):
    """
    Assert that datetimes *d1* and *d2* are within *epsilon* microseconds.
    """
    ...

def _close_to_num(o1, o2, epsilon=...):
    """
    Assert that float ordinals *o1* and *o2* are within *epsilon*
    microseconds.
    """
    ...

def epoch2num(e):
    """
    Convert an epoch or sequence of epochs to the new date format,
    that is days since 0001.
    """
    ...

def num2epoch(d):
    """
    Convert days since 0001 to epoch.  *d* can be a number or sequence.
    """
    ...

def mx2num(mxdates):
    """
    Convert mx :class:`datetime` instance (or sequence of mx
    instances) to the new date format.
    """
    ...

def date_ticker_factory(span, tz: Optional[Any] = ..., numticks=...):
    """
    Create a date locator with *numticks* (approx) and a date formatter
    for *span* in days.  Return value is (locator, formatter).
    """
    ...

def seconds(s):
    """
    Return seconds as days.
    """
    ...

def minutes(m):
    """
    Return minutes as days.
    """
    ...

def hours(h):
    """
    Return hours as days.
    """
    ...

def weeks(w):
    """
    Return weeks as days.
    """
    ...

class DateConverter(units.ConversionInterface):
    """
    Converter for datetime.date and datetime.datetime data,
    or for date/time data represented as it would be converted
    by :func:`date2num`.

    The 'unit' tag for such data is None or a tzinfo instance.
    """
    @staticmethod
    def axisinfo(unit, axis):
        """
        Return the :class:`~matplotlib.units.AxisInfo` for *unit*.

        *unit* is a tzinfo instance or None.
        The *axis* argument is required but not used.
        """
        ...
    
    @staticmethod
    def convert(value, unit, axis):
        """
        If *value* is not already a number or sequence of numbers,
        convert it with :func:`date2num`.

        The *unit* and *axis* arguments are not used.
        """
        ...
    
    @staticmethod
    def default_units(x, axis):
        """
        Return the tzinfo instance of *x* or of its first element, or None
        """
        ...
    


