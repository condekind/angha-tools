"""
This type stub file was generated by pyright.
"""

import matplotlib
from matplotlib import _pylab_helpers, docstring, rc_context
from matplotlib.cbook import deprecated
from matplotlib.backend_bases import FigureCanvasBase
from matplotlib.figure import Figure
from matplotlib.image import imread as _imread, imsave as _imsave
from matplotlib.artist import Artist, setp as _setp
from matplotlib.axes import Axes
from typing import Any, Optional

"""
`matplotlib.pyplot` is a state-based interface to matplotlib. It provides
a MATLAB-like way of plotting.

pyplot is mainly intended for interactive plots and simple cases of programmatic
plot generation::

    import numpy as np
    import matplotlib.pyplot as plt

    x = np.arange(0, 5, 0.1)
    y = np.sin(x)
    plt.plot(x, y)

The object-oriented API is recommended for more complex plots.
"""
def _backend_selection():
    """ If rcParams['backend_fallback'] is true, check to see if the
        current backend is compatible with the current running event
        loop, and if not switches to a compatible one.
    """
    ...

_IP_REGISTERED = None
_INSTALL_FIG_OBSERVER = False
def install_repl_displayhook():
    """
    Install a repl display hook so that any stale figure are automatically
    redrawn when control is returned to the repl.

    This works with IPython terminals and kernels,
    as well as vanilla python shells.
    """
    class _NotIPython(Exception):
        ...
    
    

def uninstall_repl_displayhook():
    """
    Uninstalls the matplotlib display hook.

    .. warning

       Need IPython >= 2 for this to work.  For IPython < 2 will raise a
       ``NotImplementedError``

    .. warning

       If you are using vanilla python and have installed another
       display hook this will reset ``sys.displayhook`` to what ever
       function was there when matplotlib installed it's displayhook,
       possibly discarding your changes.
    """
    ...

draw_all = _pylab_helpers.Gcf.draw_all
@docstring.copy_dedent(Artist.findobj)
def findobj(o: Optional[Any] = ..., match: Optional[Any] = ..., include_self: bool = ...):
    ...

def switch_backend(newbackend):
    """
    Switch the default backend.  This feature is **experimental**, and
    is only expected to work switching to an image backend.  e.g., if
    you have a bunch of PostScript scripts that you want to run from
    an interactive ipython session, you may want to switch to the PS
    backend before running them to avoid having a bunch of GUI windows
    popup.  If you try to interactively switch from one GUI backend to
    another, you will explode.

    Calling this command will close all open windows.
    """
    ...

def show(*args, **kw):
    """
    Display a figure.
    When running in ipython with its pylab mode, display all
    figures and return to the ipython prompt.

    In non-interactive mode, display all figures and block until
    the figures have been closed; in interactive mode it has no
    effect unless figures were created prior to a change from
    non-interactive to interactive mode (not recommended).  In
    that case it displays the figures but does not block.

    A single experimental keyword argument, *block*, may be
    set to True or False to override the blocking behavior
    described above.
    """
    ...

def isinteractive():
    """
    Return status of interactive mode.
    """
    ...

def ioff():
    """Turn interactive mode off."""
    ...

def ion():
    """Turn interactive mode on."""
    ...

def pause(interval):
    """
    Pause for *interval* seconds.

    If there is an active figure, it will be updated and displayed before the
    pause, and the GUI event loop (if any) will run during the pause.

    This can be used for crude animation.  For more complex animation, see
    :mod:`matplotlib.animation`.

    Notes
    -----
    This function is experimental; its behavior may be changed or extended in a
    future release.
    """
    ...

@docstring.copy_dedent(matplotlib.rc)
def rc(*args, **kwargs):
    ...

@docstring.copy_dedent(matplotlib.rc_context)
def rc_context(rc: Optional[Any] = ..., fname: Optional[Any] = ...):
    ...

@docstring.copy_dedent(matplotlib.rcdefaults)
def rcdefaults():
    ...

def gci():
    """
    Get the current colorable artist.  Specifically, returns the
    current :class:`~matplotlib.cm.ScalarMappable` instance (image or
    patch collection), or *None* if no images or patch collections
    have been defined.  The commands :func:`~matplotlib.pyplot.imshow`
    and :func:`~matplotlib.pyplot.figimage` create
    :class:`~matplotlib.image.Image` instances, and the commands
    :func:`~matplotlib.pyplot.pcolor` and
    :func:`~matplotlib.pyplot.scatter` create
    :class:`~matplotlib.collections.Collection` instances.  The
    current image is an attribute of the current axes, or the nearest
    earlier axes in the current figure that contains an image.
    """
    ...

def sci(im):
    """
    Set the current image.  This image will be the target of colormap
    commands like :func:`~matplotlib.pyplot.jet`,
    :func:`~matplotlib.pyplot.hot` or
    :func:`~matplotlib.pyplot.clim`).  The current image is an
    attribute of the current axes.
    """
    ...

@docstring.copy(_setp)
def setp(*args, **kwargs):
    ...

def xkcd(scale=..., length=..., randomness=...):
    """
    Turns on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.
    This will only have effect on things drawn after this function is
    called.

    For best results, the "Humor Sans" font should be installed: it is
    not included with matplotlib.

    Parameters
    ----------
    scale : float, optional
        The amplitude of the wiggle perpendicular to the source line.
    length : float, optional
        The length of the wiggle along the line.
    randomness : float, optional
        The scale factor by which the length is shrunken or expanded.

    Notes
    -----
    This function works by a number of rcParams, so it will probably
    override others you have set before.

    If you want the effects of this function to be temporary, it can
    be used as a context manager, for example::

        with plt.xkcd():
            # This figure will be in XKCD-style
            fig1 = plt.figure()
            # ...

        # This figure will be in regular style
        fig2 = plt.figure()
    """
    ...

def figure(num: Optional[Any] = ..., figsize: Optional[Any] = ..., dpi: Optional[Any] = ..., facecolor: Optional[Any] = ..., edgecolor: Optional[Any] = ..., frameon: bool = ..., FigureClass=..., clear: bool = ..., **kwargs):
    """
    Creates a new figure.

    Parameters
    ----------

    num : integer or string, optional, default: none
        If not provided, a new figure will be created, and the figure number
        will be incremented. The figure objects holds this number in a `number`
        attribute.
        If num is provided, and a figure with this id already exists, make
        it active, and returns a reference to it. If this figure does not
        exists, create it and returns it.
        If num is a string, the window title will be set to this figure's
        `num`.

    figsize : tuple of integers, optional, default: None
        width, height in inches. If not provided, defaults to rc
        figure.figsize.

    dpi : integer, optional, default: None
        resolution of the figure. If not provided, defaults to rc figure.dpi.

    facecolor :
        the background color. If not provided, defaults to rc figure.facecolor.

    edgecolor :
        the border color. If not provided, defaults to rc figure.edgecolor.

    frameon : bool, optional, default: True
        If False, suppress drawing the figure frame.

    FigureClass : class derived from matplotlib.figure.Figure
        Optionally use a custom Figure instance.

    clear : bool, optional, default: False
        If True and the figure already exists, then it is cleared.

    Returns
    -------
    figure : Figure
        The Figure instance returned will also be passed to new_figure_manager
        in the backends, which allows to hook custom Figure classes into the
        pylab interface. Additional kwargs will be passed to the figure init
        function.

    Notes
    -----
    If you are creating many figures, make sure you explicitly call "close"
    on the figures you are not using, because this will enable pylab
    to properly clean up the memory.

    rcParams defines the default values, which can be modified in the
    matplotlibrc file

    """
    ...

def _auto_draw_if_interactive(fig, val):
    """
    This is an internal helper function for making sure that auto-redrawing
    works as intended in the plain python repl.

    Parameters
    ----------
    fig : Figure
        A figure object which is assumed to be associated with a canvas
    """
    ...

def gcf():
    """Get a reference to the current figure."""
    ...

def fignum_exists(num):
    ...

def get_fignums():
    """Return a list of existing figure numbers."""
    ...

def get_figlabels():
    """Return a list of existing figure labels."""
    ...

def get_current_fig_manager():
    ...

@docstring.copy_dedent(FigureCanvasBase.mpl_connect)
def connect(s, func):
    ...

@docstring.copy_dedent(FigureCanvasBase.mpl_disconnect)
def disconnect(cid):
    ...

def close(*args):
    """
    Close a figure window.

    ``close()`` by itself closes the current figure

    ``close(fig)`` closes the `.Figure` instance *fig*

    ``close(num)`` closes the figure number *num*

    ``close(name)`` where *name* is a string, closes figure with that label

    ``close('all')`` closes all the figure windows
    """
    ...

def clf():
    """
    Clear the current figure.
    """
    ...

def draw():
    """Redraw the current figure.

    This is used to update a figure that has been altered, but not
    automatically re-drawn.  If interactive mode is on (:func:`.ion()`), this
    should be only rarely needed, but there may be ways to modify the state of
    a figure without marking it as `stale`.  Please report these cases as
    bugs.

    A more object-oriented alternative, given any
    :class:`~matplotlib.figure.Figure` instance, :attr:`fig`, that
    was created using a :mod:`~matplotlib.pyplot` function, is::

        fig.canvas.draw_idle()
    """
    ...

@docstring.copy_dedent(Figure.savefig)
def savefig(*args, **kwargs):
    ...

@docstring.copy_dedent(Figure.ginput)
def ginput(*args, **kwargs):
    """
    Blocking call to interact with the figure.

    This will wait for *n* clicks from the user and return a list of the
    coordinates of each click.

    If *timeout* is negative, does not timeout.
    """
    ...

@docstring.copy_dedent(Figure.waitforbuttonpress)
def waitforbuttonpress(*args, **kwargs):
    """
    Blocking call to interact with the figure.

    This will wait for *n* key or mouse clicks from the user and
    return a list containing True's for keyboard clicks and False's
    for mouse clicks.

    If *timeout* is negative, does not timeout.
    """
    ...

@docstring.copy_dedent(Figure.text)
def figtext(*args, **kwargs):
    ...

@docstring.copy_dedent(Figure.suptitle)
def suptitle(*args, **kwargs):
    ...

@docstring.copy_dedent(Figure.figimage)
def figimage(*args, **kwargs):
    ...

def figlegend(*args, **kwargs):
    """
    Place a legend in the figure.

    *labels*
      a sequence of strings

    *handles*
      a sequence of :class:`~matplotlib.lines.Line2D` or
      :class:`~matplotlib.patches.Patch` instances

    *loc*
      can be a string or an integer specifying the legend
      location

    A :class:`matplotlib.legend.Legend` instance is returned.

    Examples
    --------

    To make a legend from existing artists on every axes::

      figlegend()

    To make a legend for a list of lines and labels::

      figlegend( (line1, line2, line3),
                 ('label1', 'label2', 'label3'),
                 'upper right' )

    .. seealso::

       :func:`~matplotlib.pyplot.legend`

    """
    ...

_hold_msg = """pyplot.hold is deprecated.
    Future behavior will be consistent with the long-time default:
    plot commands add elements without first clearing the
    Axes and/or Figure."""
@deprecated("2.0", message=_hold_msg)
def hold(b: Optional[Any] = ...):
    """
    Set the hold state.  If *b* is None (default), toggle the
    hold state, else set the hold state to boolean value *b*::

      hold()      # toggle hold
      hold(True)  # hold is on
      hold(False) # hold is off

    When *hold* is *True*, subsequent plot commands will add elements to
    the current axes.  When *hold* is *False*, the current axes and
    figure will be cleared on the next plot command.

    """
    ...

@deprecated("2.0", message=_hold_msg)
def ishold():
    """
    Return the hold status of the current axes.
    """
    ...

@deprecated("2.0", message=_hold_msg)
def over(func, *args, **kwargs):
    """
    Call a function with hold(True).

    Calls::

      func(*args, **kwargs)

    with ``hold(True)`` and then restores the hold state.

    """
    ...

def axes(arg: Optional[Any] = ..., **kwargs):
    """
    Add an axes to the current figure and make it the current axes.

    Parameters
    ----------
    arg : None or 4-tuple or Axes
        The exact behavior of this function depends on the type:

        - *None*: A new full window axes is added using
          ``subplot(111, **kwargs)``
        - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
          A new axes is added with dimensions *rect* in normalized
          (0, 1) units using `~.Figure.add_axes` on the current figure.
        - `~matplotlib.axes.Axes`: This is equivalent to `.pyplot.sca`.
          It sets the current axes to *arg*. Note: This implicitly
          changes the current figure to the parent of *arg*.

          .. note:: The use of an Axes as an argument is deprecated and will be
                    removed in v3.0. Please use `.pyplot.sca` instead.

    Other Parameters
    ----------------
    **kwargs :
        For allowed keyword arguments see `.pyplot.subplot` and
        `.Figure.add_axes` respectively. Some common keyword arguments are
        listed below:

        ========= =========== =================================================
        kwarg     Accepts     Description
        ========= =========== =================================================
        facecolor color       the axes background color
        frameon   bool        whether to display the frame
        sharex    otherax     share x-axis with *otherax*
        sharey    otherax     share y-axis with *otherax*
        polar     bool        whether to use polar axes
        aspect    [str | num] ['equal', 'auto'] or a number.  If a number, the
                              ratio of y-unit/x-unit in screen-space.  See also
                              `~.Axes.set_aspect`.
        ========= =========== =================================================

    Returns
    -------
    axes : Axes
        The created or activated axes.

    Examples
    --------
    Creating a new full window axes::

        >>> plt.axes()

    Creating a new axes with specified dimensions and some kwargs::

        >>> plt.axes((left, bottom, width, height), facecolor='w')

    """
    ...

def delaxes(ax: Optional[Any] = ...):
    """
    Remove the given `Axes` *ax* from the current figure. If *ax* is *None*,
    the current axes is removed. A KeyError is raised if the axes doesn't exist.
    """
    ...

def sca(ax):
    """
    Set the current Axes instance to *ax*.

    The current Figure is updated to the parent of *ax*.
    """
    ...

def gca(**kwargs):
    """
    Get the current :class:`~matplotlib.axes.Axes` instance on the
    current figure matching the given keyword args, or create one.

    Examples
    --------
    To get the current polar axes on the current figure::

        plt.gca(projection='polar')

    If the current axes doesn't exist, or isn't a polar one, the appropriate
    axes will be created and then returned.

    See Also
    --------
    matplotlib.figure.Figure.gca : The figure's gca method.
    """
    ...

def subplot(*args, **kwargs):
    """
    Return a subplot axes at the given grid position.

    Call signature::

       subplot(nrows, ncols, index, **kwargs)

    In the current figure, create and return an `~matplotlib.axes.Axes`,
    at position *index* of a (virtual) grid of *nrows* by *ncols* axes.
    Indexes go from 1 to ``nrows * ncols``, incrementing in row-major order.

    If *nrows*, *ncols* and *index* are all less than 10, they can also be
    given as a single, concatenated, three-digit number.

    For example, ``subplot(2, 3, 3)`` and ``subplot(233)`` both create an
    `matplotlib.axes.Axes` at the top right corner of the current figure,
    occupying half of the figure height and a third of the figure width.

    .. note::

       Creating a subplot will delete any pre-existing subplot that overlaps
       with it beyond sharing a boundary::

          import matplotlib.pyplot as plt
          # plot a line, implicitly creating a subplot(111)
          plt.plot([1,2,3])
          # now create a subplot which represents the top plot of a grid
          # with 2 rows and 1 column. Since this subplot will overlap the
          # first, the plot (and its axes) previously created, will be removed
          plt.subplot(211)
          plt.plot(range(12))
          plt.subplot(212, facecolor='y') # creates 2nd subplot with yellow background

       If you do not want this behavior, use the
       :meth:`~matplotlib.figure.Figure.add_subplot` method or the
       :func:`~matplotlib.pyplot.axes` function instead.

    Keyword arguments:

      *facecolor*:
        The background color of the subplot, which can be any valid
        color specifier.  See :mod:`matplotlib.colors` for more
        information.

      *polar*:
        A boolean flag indicating whether the subplot plot should be
        a polar projection.  Defaults to *False*.

      *projection*:
        A string giving the name of a custom projection to be used
        for the subplot. This projection must have been previously
        registered. See :mod:`matplotlib.projections`.

    .. seealso::

        :func:`~matplotlib.pyplot.axes`
            For additional information on :func:`axes` and
            :func:`subplot` keyword arguments.

        :file:`gallery/pie_and_polar_charts/polar_scatter.py`
            For an example

    **Example:**

    .. plot:: gallery/subplots_axes_and_figures/subplot.py

    """
    ...

def subplots(nrows=..., ncols=..., sharex: bool = ..., sharey: bool = ..., squeeze: bool = ..., subplot_kw: Optional[Any] = ..., gridspec_kw: Optional[Any] = ..., **fig_kw):
    """
    Create a figure and a set of subplots

    This utility wrapper makes it convenient to create common layouts of
    subplots, including the enclosing figure object, in a single call.

    Parameters
    ----------
    nrows, ncols : int, optional, default: 1
        Number of rows/columns of the subplot grid.

    sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
        Controls sharing of properties among x (`sharex`) or y (`sharey`)
        axes:

            - True or 'all': x- or y-axis will be shared among all
              subplots.
            - False or 'none': each subplot x- or y-axis will be
              independent.
            - 'row': each subplot row will share an x- or y-axis.
            - 'col': each subplot column will share an x- or y-axis.

        When subplots have a shared x-axis along a column, only the x tick
        labels of the bottom subplot are created. Similarly, when subplots
        have a shared y-axis along a row, only the y tick labels of the first
        column subplot are created. To later turn other subplots' ticklabels
        on, use :meth:`~matplotlib.axes.Axes.tick_params`.

    squeeze : bool, optional, default: True
        - If True, extra dimensions are squeezed out from the returned
          array of Axes:

            - if only one subplot is constructed (nrows=ncols=1), the
              resulting single Axes object is returned as a scalar.
            - for Nx1 or 1xM subplots, the returned object is a 1D numpy
              object array of Axes objects.
            - for NxM, subplots with N>1 and M>1 are returned as a 2D array.

        - If False, no squeezing at all is done: the returned Axes object is
          always a 2D array containing Axes instances, even if it ends up
          being 1x1.

    subplot_kw : dict, optional
        Dict with keywords passed to the
        :meth:`~matplotlib.figure.Figure.add_subplot` call used to create each
        subplot.

    gridspec_kw : dict, optional
        Dict with keywords passed to the
        :class:`~matplotlib.gridspec.GridSpec` constructor used to create the
        grid the subplots are placed on.

    **fig_kw :
        All additional keyword arguments are passed to the :func:`figure` call.

    Returns
    -------
    fig : :class:`matplotlib.figure.Figure` object

    ax : Axes object or array of Axes objects.

        ax can be either a single :class:`matplotlib.axes.Axes` object or an
        array of Axes objects if more than one subplot was created.  The
        dimensions of the resulting array can be controlled with the squeeze
        keyword, see above.

    Examples
    --------
    First create some toy data:

    >>> x = np.linspace(0, 2*np.pi, 400)
    >>> y = np.sin(x**2)

    Creates just a figure and only one subplot

    >>> fig, ax = plt.subplots()
    >>> ax.plot(x, y)
    >>> ax.set_title('Simple plot')

    Creates two subplots and unpacks the output array immediately

    >>> f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
    >>> ax1.plot(x, y)
    >>> ax1.set_title('Sharing Y axis')
    >>> ax2.scatter(x, y)

    Creates four polar axes, and accesses them through the returned array

    >>> fig, axes = plt.subplots(2, 2, subplot_kw=dict(polar=True))
    >>> axes[0, 0].plot(x, y)
    >>> axes[1, 1].scatter(x, y)

    Share a X axis with each column of subplots

    >>> plt.subplots(2, 2, sharex='col')

    Share a Y axis with each row of subplots

    >>> plt.subplots(2, 2, sharey='row')

    Share both X and Y axes with all subplots

    >>> plt.subplots(2, 2, sharex='all', sharey='all')

    Note that this is the same as

    >>> plt.subplots(2, 2, sharex=True, sharey=True)

    See Also
    --------
    figure
    subplot
    """
    ...

def subplot2grid(shape, loc, rowspan=..., colspan=..., fig: Optional[Any] = ..., **kwargs):
    """
    Create an axis at specific location inside a regular grid.

    Parameters
    ----------
    shape : sequence of 2 ints
        Shape of grid in which to place axis.
        First entry is number of rows, second entry is number of columns.

    loc : sequence of 2 ints
        Location to place axis within grid.
        First entry is row number, second entry is column number.

    rowspan : int
        Number of rows for the axis to span to the right.

    colspan : int
        Number of columns for the axis to span downwards.

    fig : `Figure`, optional
        Figure to place axis in. Defaults to current figure.

    **kwargs
        Additional keyword arguments are handed to `add_subplot`.


    Notes
    -----
    The following call ::

        subplot2grid(shape, loc, rowspan=1, colspan=1)

    is identical to ::

        gridspec=GridSpec(shape[0], shape[1])
        subplotspec=gridspec.new_subplotspec(loc, rowspan, colspan)
        subplot(subplotspec)
    """
    ...

def twinx(ax: Optional[Any] = ...):
    """
    Make a second axes that shares the *x*-axis.  The new axes will
    overlay *ax* (or the current axes if *ax* is *None*).  The ticks
    for *ax2* will be placed on the right, and the *ax2* instance is
    returned.

    .. seealso::

       :file:`examples/api_examples/two_scales.py`
          For an example
    """
    ...

def twiny(ax: Optional[Any] = ...):
    """
    Make a second axes that shares the *y*-axis.  The new axis will
    overlay *ax* (or the current axes if *ax* is *None*).  The ticks
    for *ax2* will be placed on the top, and the *ax2* instance is
    returned.
    """
    ...

def subplots_adjust(*args, **kwargs):
    """
    Tune the subplot layout.

    call signature::

      subplots_adjust(left=None, bottom=None, right=None, top=None,
                      wspace=None, hspace=None)

    The parameter meanings (and suggested defaults) are::

      left  = 0.125  # the left side of the subplots of the figure
      right = 0.9    # the right side of the subplots of the figure
      bottom = 0.1   # the bottom of the subplots of the figure
      top = 0.9      # the top of the subplots of the figure
      wspace = 0.2   # the amount of width reserved for space between subplots,
                     # expressed as a fraction of the average axis width
      hspace = 0.2   # the amount of height reserved for space between subplots,
                     # expressed as a fraction of the average axis height

    The actual defaults are controlled by the rc file
    """
    ...

def subplot_tool(targetfig: Optional[Any] = ...):
    """
    Launch a subplot tool window for a figure.

    A :class:`matplotlib.widgets.SubplotTool` instance is returned.
    """
    ...

def tight_layout(pad=..., h_pad: Optional[Any] = ..., w_pad: Optional[Any] = ..., rect: Optional[Any] = ...):
    """
    Automatically adjust subplot parameters to give specified padding.

    Parameters
    ----------
    pad : float
        padding between the figure edge and the edges of subplots, as a fraction of the font-size.
    h_pad, w_pad : float
        padding (height/width) between edges of adjacent subplots.
        Defaults to `pad_inches`.
    rect : if rect is given, it is interpreted as a rectangle
        (left, bottom, right, top) in the normalized figure
        coordinate that the whole subplots area (including
        labels) will fit into. Default is (0, 0, 1, 1).

    """
    ...

def box(on: Optional[Any] = ...):
    """
    Turn the axes box on or off on the current axes.

    Parameters
    ----------
    on : bool or None
        The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
        the state.

    See Also
    --------
    :meth:`matplotlib.axes.Axes.set_frame_on`
    :meth:`matplotlib.axes.Axes.get_frame_on`
    """
    ...

def title(s, *args, **kwargs):
    """
    Set a title of the current axes.

    Set one of the three available axes titles. The available titles are
    positioned above the axes in the center, flush with the left edge,
    and flush with the right edge.

    .. seealso::
        See :func:`~matplotlib.pyplot.text` for adding text
        to the current axes

    Parameters
    ----------
    label : str
        Text to use for the title

    fontdict : dict
        A dictionary controlling the appearance of the title text,
        the default `fontdict` is:

            {'fontsize': rcParams['axes.titlesize'],
            'fontweight' : rcParams['axes.titleweight'],
            'verticalalignment': 'baseline',
            'horizontalalignment': loc}

    loc : {'center', 'left', 'right'}, str, optional
        Which title to set, defaults to 'center'

    Returns
    -------
    text : :class:`~matplotlib.text.Text`
        The matplotlib text instance representing the title

    Other parameters
    ----------------
    kwargs : text properties
        Other keyword arguments are text properties, see
        :class:`~matplotlib.text.Text` for a list of valid text
        properties.

    """
    ...

def axis(*v, **kwargs):
    """
    Convenience method to get or set axis properties.

    Calling with no arguments::

      >>> axis()

    returns the current axes limits ``[xmin, xmax, ymin, ymax]``.::

      >>> axis(v)

    sets the min and max of the x and y axes, with
    ``v = [xmin, xmax, ymin, ymax]``.::

      >>> axis('off')

    turns off the axis lines and labels.::

      >>> axis('equal')

    changes limits of *x* or *y* axis so that equal increments of *x*
    and *y* have the same length; a circle is circular.::

      >>> axis('scaled')

    achieves the same result by changing the dimensions of the plot box instead
    of the axis data limits.::

      >>> axis('tight')

    changes *x* and *y* axis limits such that all data is shown. If
    all data is already shown, it will move it to the center of the
    figure without modifying (*xmax* - *xmin*) or (*ymax* -
    *ymin*). Note this is slightly different than in MATLAB.::

      >>> axis('image')

    is 'scaled' with the axis limits equal to the data limits.::

      >>> axis('auto')

    and::

      >>> axis('normal')

    are deprecated. They restore default behavior; axis limits are automatically
    scaled to make the data fit comfortably within the plot box.

    if ``len(*v)==0``, you can pass in *xmin*, *xmax*, *ymin*, *ymax*
    as kwargs selectively to alter just those limits without changing
    the others.

      >>> axis('square')

    changes the limit ranges (*xmax*-*xmin*) and (*ymax*-*ymin*) of
    the *x* and *y* axes to be the same, and have the same scaling,
    resulting in a square plot.

    The xmin, xmax, ymin, ymax tuple is returned

    .. seealso::

        :func:`xlim`, :func:`ylim`
           For setting the x- and y-limits individually.
    """
    ...

def xlabel(s, *args, **kwargs):
    """
    Set the x-axis label of the current axes.

    Call signature::

        xlabel(label, fontdict=None, labelpad=None, **kwargs)

    This is the pyplot equivalent of calling `.set_xlabel` on the current axes.
    See there for a full parameter description.
    """
    ...

def ylabel(s, *args, **kwargs):
    """
    Set the y-axis label of the current axes.

    Call signature::

        ylabel(label, fontdict=None, labelpad=None, **kwargs)

    This is the pyplot equivalent of calling `.set_ylabel` on the current axes.
    See there for a full parameter description.
    """
    ...

def xlim(*args, **kwargs):
    """
    Get or set the x limits of the current axes.

    Call signatures::

        xmin, xmax = xlim()  # return the current xlim
        xlim((xmin, xmax))   # set the xlim to xmin, xmax
        xlim(xmin, xmax)     # set the xlim to xmin, xmax

    If you do not specify args, you can pass *xmin* or *xmax* as kwargs, i.e.::

        xlim(xmax=3)  # adjust the max leaving min unchanged
        xlim(xmin=1)  # adjust the min leaving max unchanged

    Setting limits turns autoscaling off for the x-axis.

    Returns
    -------
    xmin, xmax
        A tuple of the new x-axis limits.

    Notes
    -----
    Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
    equivalent of calling `~.Axes.get_xlim` on the current axes.
    Calling this function with arguments is the pyplot equivalent of calling
    `~.Axes.set_xlim` on the current axes. All arguments are passed though.
    """
    ...

def ylim(*args, **kwargs):
    """
    Get or set the y-limits of the current axes.

    Call signatures::

        ymin, ymax = ylim()  # return the current ylim
        ylim((ymin, ymax))   # set the ylim to ymin, ymax
        ylim(ymin, ymax)     # set the ylim to ymin, ymax

    If you do not specify args, you can alternatively pass *ymin* or *ymax* as
    kwargs, i.e.::

        ylim(ymax=3)  # adjust the max leaving min unchanged
        ylim(ymin=1)  # adjust the min leaving max unchanged

    Setting limits turns autoscaling off for the y-axis.

    Returns
    -------
    ymin, ymax
        A tuple of the new y-axis limits.

    Notes
    -----
    Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
    equivalent of calling `~.Axes.get_ylim` on the current axes.
    Calling this function with arguments is the pyplot equivalent of calling
    `~.Axes.set_ylim` on the current axes. All arguments are passed though.
    """
    ...

@docstring.dedent_interpd
def xscale(*args, **kwargs):
    """
    Set the scaling of the x-axis.

    Call signature::

        xscale(scale, **kwargs)

    Parameters
    ----------
    scale : [%(scale)s]
        The scaling type.
    **kwargs
        Additional parameters depend on *scale*. See Notes.

    Notes
    -----
    This is the pyplot equivalent of calling `~.Axes.set_xscale` on the
    current axes.

    Different keywords may be accepted, depending on the scale:

    %(scale_docs)s
    """
    ...

@docstring.dedent_interpd
def yscale(*args, **kwargs):
    """
    Set the scaling of the y-axis.

    Call signature::

        yscale(scale, **kwargs)

    Parameters
    ----------
    scale : [%(scale)s]
        The scaling type.
    **kwargs
        Additional parameters depend on *scale*. See Notes.

    Notes
    -----
    This is the pyplot equivalent of calling `~.Axes.set_yscale` on the
    current axes.

    Different keywords may be accepted, depending on the scale:

    %(scale_docs)s
    """
    ...

def xticks(*args, **kwargs):
    """
    Get or set the current tick locations and labels of the x-axis.

    Call signatures::

        locs, labels = xticks()           # Get locations and labels

        xticks(locs, [labels], **kwargs)  # Set locations and labels

    Parameters
    ----------
    locs : array_like
        A list of positions at which ticks should be placed. You can pass an
        empty list to disable xticks.

    labels : array_like, optional
        A list of explicit labels to place at the given *locs*.

    **kwargs
        :class:`.Text` properties can be used to control the appearance of
        the labels.

    Returns
    -------
    locs
        An array of label locations.
    labels
        A list of `.Text` objects.

    Notes
    -----
    Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
    equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
    the current axes.
    Calling this function with arguments is the pyplot equivalent of calling
    `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.

    Examples
    --------
    Get the current locations and labels:

        >>> locs, labels = xticks()

    Set label locations:

        >>> xticks(np.arange(0, 1, step=0.2))

    Set text labels:

        >>> xticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))

    Set text labels and properties:

        >>> xticks(np.arange(12), calendar.month_name[1:13], rotation=20)

    Disable xticks:

        >>> xticks([])
    """
    ...

def yticks(*args, **kwargs):
    """
    Get or set the current tick locations and labels of the y-axis.

    Call signatures::

        locs, labels = yticks()           # Get locations and labels

        yticks(locs, [labels], **kwargs)  # Set locations and labels

    Parameters
    ----------
    locs : array_like
        A list of positions at which ticks should be placed. You can pass an
        empty list to disable yticks.

    labels : array_like, optional
        A list of explicit labels to place at the given *locs*.

    **kwargs
        :class:`.Text` properties can be used to control the appearance of
        the labels.

    Returns
    -------
    locs
        An array of label locations.
    labels
        A list of `.Text` objects.

    Notes
    -----
    Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
    equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
    the current axes.
    Calling this function with arguments is the pyplot equivalent of calling
    `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.

    Examples
    --------
    Get the current locations and labels:

        >>> locs, labels = yticks()

    Set label locations:

        >>> yticks(np.arange(0, 1, step=0.2))

    Set text labels:

        >>> yticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))

    Set text labels and properties:

        >>> yticks(np.arange(12), calendar.month_name[1:13], rotation=45)

    Disable yticks:

        >>> yticks([])
    """
    ...

def minorticks_on():
    """
    Display minor ticks on the current plot.

    Displaying minor ticks reduces performance; turn them off using
    minorticks_off() if drawing speed is a problem.
    """
    ...

def minorticks_off():
    """
    Remove minor ticks from the current plot.
    """
    ...

def rgrids(*args, **kwargs):
    """
    Get or set the radial gridlines on a polar plot.

    call signatures::

      lines, labels = rgrids()
      lines, labels = rgrids(radii, labels=None, angle=22.5, **kwargs)

    When called with no arguments, :func:`rgrid` simply returns the
    tuple (*lines*, *labels*), where *lines* is an array of radial
    gridlines (:class:`~matplotlib.lines.Line2D` instances) and
    *labels* is an array of tick labels
    (:class:`~matplotlib.text.Text` instances). When called with
    arguments, the labels will appear at the specified radial
    distances and angles.

    *labels*, if not *None*, is a len(*radii*) list of strings of the
    labels to use at each angle.

    If *labels* is None, the rformatter will be used

    Examples::

      # set the locations of the radial gridlines and labels
      lines, labels = rgrids( (0.25, 0.5, 1.0) )

      # set the locations and labels of the radial gridlines and labels
      lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' )

    """
    ...

def thetagrids(*args, **kwargs):
    """
    Get or set the theta locations of the gridlines in a polar plot.

    If no arguments are passed, return a tuple (*lines*, *labels*)
    where *lines* is an array of radial gridlines
    (:class:`~matplotlib.lines.Line2D` instances) and *labels* is an
    array of tick labels (:class:`~matplotlib.text.Text` instances)::

      lines, labels = thetagrids()

    Otherwise the syntax is::

      lines, labels = thetagrids(angles, labels=None, fmt='%d', frac = 1.1)

    set the angles at which to place the theta grids (these gridlines
    are equal along the theta dimension).

    *angles* is in degrees.

    *labels*, if not *None*, is a len(angles) list of strings of the
    labels to use at each angle.

    If *labels* is *None*, the labels will be ``fmt%angle``.

    *frac* is the fraction of the polar axes radius at which to place
    the label (1 is the edge). e.g., 1.05 is outside the axes and 0.95
    is inside the axes.

    Return value is a list of tuples (*lines*, *labels*):

      - *lines* are :class:`~matplotlib.lines.Line2D` instances

      - *labels* are :class:`~matplotlib.text.Text` instances.

    Note that on input, the *labels* argument is a list of strings,
    and on output it is a list of :class:`~matplotlib.text.Text`
    instances.

    Examples::

      # set the locations of the radial gridlines and labels
      lines, labels = thetagrids( range(45,360,90) )

      # set the locations and labels of the radial gridlines and labels
      lines, labels = thetagrids( range(45,360,90), ('NE', 'NW', 'SW','SE') )
    """
    ...

def plotting():
    ...

def get_plot_commands():
    """
    Get a sorted list of all of the plotting commands.
    """
    ...

@deprecated('2.1')
def colors():
    """
    This is a do-nothing function to provide you with help on how
    matplotlib handles colors.

    Commands which take color arguments can use several formats to
    specify the colors.  For the basic built-in colors, you can use a
    single letter

      =====   =======
      Alias   Color
      =====   =======
      'b'     blue
      'g'     green
      'r'     red
      'c'     cyan
      'm'     magenta
      'y'     yellow
      'k'     black
      'w'     white
      =====   =======

    For a greater range of colors, you have two options.  You can
    specify the color using an html hex string, as in::

      color = '#eeefff'

    or you can pass an R,G,B tuple, where each of R,G,B are in the
    range [0,1].

    You can also use any legal html name for a color, for example::

      color = 'red'
      color = 'burlywood'
      color = 'chartreuse'

    The example below creates a subplot with a dark
    slate gray background::

       subplot(111, facecolor=(0.1843, 0.3098, 0.3098))

    Here is an example that creates a pale turquoise title::

      title('Is this the best color?', color='#afeeee')

    """
    ...

def colormaps():
    """
    Matplotlib provides a number of colormaps, and others can be added using
    :func:`~matplotlib.cm.register_cmap`.  This function documents the built-in
    colormaps, and will also return a list of all registered colormaps if called.

    You can set the colormap for an image, pcolor, scatter, etc,
    using a keyword argument::

      imshow(X, cmap=cm.hot)

    or using the :func:`set_cmap` function::

      imshow(X)
      pyplot.set_cmap('hot')
      pyplot.set_cmap('jet')

    In interactive mode, :func:`set_cmap` will update the colormap post-hoc,
    allowing you to see which one works best for your data.

    All built-in colormaps can be reversed by appending ``_r``: For instance,
    ``gray_r`` is the reverse of ``gray``.

    There are several common color schemes used in visualization:

    Sequential schemes
      for unipolar data that progresses from low to high
    Diverging schemes
      for bipolar data that emphasizes positive or negative deviations from a
      central value
    Cyclic schemes
      meant for plotting values that wrap around at the
      endpoints, such as phase angle, wind direction, or time of day
    Qualitative schemes
      for nominal data that has no inherent ordering, where color is used
      only to distinguish categories

    Matplotlib ships with 4 perceptually uniform color maps which are
    the recommended color maps for sequential data:

      =========   ===================================================
      Colormap    Description
      =========   ===================================================
      inferno     perceptually uniform shades of black-red-yellow
      magma       perceptually uniform shades of black-red-white
      plasma      perceptually uniform shades of blue-red-yellow
      viridis     perceptually uniform shades of blue-green-yellow
      =========   ===================================================

    The following colormaps are based on the `ColorBrewer
    <http://colorbrewer2.org>`_ color specifications and designs developed by
    Cynthia Brewer:

    ColorBrewer Diverging (luminance is highest at the midpoint, and
    decreases towards differently-colored endpoints):

      ========  ===================================
      Colormap  Description
      ========  ===================================
      BrBG      brown, white, blue-green
      PiYG      pink, white, yellow-green
      PRGn      purple, white, green
      PuOr      orange, white, purple
      RdBu      red, white, blue
      RdGy      red, white, gray
      RdYlBu    red, yellow, blue
      RdYlGn    red, yellow, green
      Spectral  red, orange, yellow, green, blue
      ========  ===================================

    ColorBrewer Sequential (luminance decreases monotonically):

      ========  ====================================
      Colormap  Description
      ========  ====================================
      Blues     white to dark blue
      BuGn      white, light blue, dark green
      BuPu      white, light blue, dark purple
      GnBu      white, light green, dark blue
      Greens    white to dark green
      Greys     white to black (not linear)
      Oranges   white, orange, dark brown
      OrRd      white, orange, dark red
      PuBu      white, light purple, dark blue
      PuBuGn    white, light purple, dark green
      PuRd      white, light purple, dark red
      Purples   white to dark purple
      RdPu      white, pink, dark purple
      Reds      white to dark red
      YlGn      light yellow, dark green
      YlGnBu    light yellow, light green, dark blue
      YlOrBr    light yellow, orange, dark brown
      YlOrRd    light yellow, orange, dark red
      ========  ====================================

    ColorBrewer Qualitative:

    (For plotting nominal data, :class:`ListedColormap` is used,
    not :class:`LinearSegmentedColormap`.  Different sets of colors are
    recommended for different numbers of categories.)

    * Accent
    * Dark2
    * Paired
    * Pastel1
    * Pastel2
    * Set1
    * Set2
    * Set3

    A set of colormaps derived from those of the same name provided
    with Matlab are also included:

      =========   =======================================================
      Colormap    Description
      =========   =======================================================
      autumn      sequential linearly-increasing shades of red-orange-yellow
      bone        sequential increasing black-white color map with
                  a tinge of blue, to emulate X-ray film
      cool        linearly-decreasing shades of cyan-magenta
      copper      sequential increasing shades of black-copper
      flag        repetitive red-white-blue-black pattern (not cyclic at
                  endpoints)
      gray        sequential linearly-increasing black-to-white
                  grayscale
      hot         sequential black-red-yellow-white, to emulate blackbody
                  radiation from an object at increasing temperatures
      hsv         cyclic red-yellow-green-cyan-blue-magenta-red, formed
                  by changing the hue component in the HSV color space
      jet         a spectral map with dark endpoints, blue-cyan-yellow-red;
                  based on a fluid-jet simulation by NCSA [#]_
      pink        sequential increasing pastel black-pink-white, meant
                  for sepia tone colorization of photographs
      prism       repetitive red-yellow-green-blue-purple-...-green pattern
                  (not cyclic at endpoints)
      spring      linearly-increasing shades of magenta-yellow
      summer      sequential linearly-increasing shades of green-yellow
      winter      linearly-increasing shades of blue-green
      =========   =======================================================

    A set of palettes from the `Yorick scientific visualisation
    package <https://dhmunro.github.io/yorick-doc/>`_, an evolution of
    the GIST package, both by David H. Munro are included:

      ============  =======================================================
      Colormap      Description
      ============  =======================================================
      gist_earth    mapmaker's colors from dark blue deep ocean to green
                    lowlands to brown highlands to white mountains
      gist_heat     sequential increasing black-red-orange-white, to emulate
                    blackbody radiation from an iron bar as it grows hotter
      gist_ncar     pseudo-spectral black-blue-green-yellow-red-purple-white
                    colormap from National Center for Atmospheric
                    Research [#]_
      gist_rainbow  runs through the colors in spectral order from red to
                    violet at full saturation (like *hsv* but not cyclic)
      gist_stern    "Stern special" color table from Interactive Data
                    Language software
      ============  =======================================================


    Other miscellaneous schemes:

      ============= =======================================================
      Colormap      Description
      ============= =======================================================
      afmhot        sequential black-orange-yellow-white blackbody
                    spectrum, commonly used in atomic force microscopy
      brg           blue-red-green
      bwr           diverging blue-white-red
      coolwarm      diverging blue-gray-red, meant to avoid issues with 3D
                    shading, color blindness, and ordering of colors [#]_
      CMRmap        "Default colormaps on color images often reproduce to
                    confusing grayscale images. The proposed colormap
                    maintains an aesthetically pleasing color image that
                    automatically reproduces to a monotonic grayscale with
                    discrete, quantifiable saturation levels." [#]_
      cubehelix     Unlike most other color schemes cubehelix was designed
                    by D.A. Green to be monotonically increasing in terms
                    of perceived brightness. Also, when printed on a black
                    and white postscript printer, the scheme results in a
                    greyscale with monotonically increasing brightness.
                    This color scheme is named cubehelix because the r,g,b
                    values produced can be visualised as a squashed helix
                    around the diagonal in the r,g,b color cube.
      gnuplot       gnuplot's traditional pm3d scheme
                    (black-blue-red-yellow)
      gnuplot2      sequential color printable as gray
                    (black-blue-violet-yellow-white)
      ocean         green-blue-white
      rainbow       spectral purple-blue-green-yellow-orange-red colormap
                    with diverging luminance
      seismic       diverging blue-white-red
      nipy_spectral black-purple-blue-green-yellow-red-white spectrum,
                    originally from the Neuroimaging in Python project
      terrain       mapmaker's colors, blue-green-yellow-brown-white,
                    originally from IGOR Pro
      ============= =======================================================

    The following colormaps are redundant and may be removed in future
    versions.  It's recommended to use the names in the descriptions
    instead, which produce identical output:

      =========  =======================================================
      Colormap   Description
      =========  =======================================================
      gist_gray  identical to *gray*
      gist_yarg  identical to *gray_r*
      binary     identical to *gray_r*
      spectral   identical to *nipy_spectral* [#]_
      =========  =======================================================

    .. rubric:: Footnotes

    .. [#] Rainbow colormaps, ``jet`` in particular, are considered a poor
      choice for scientific visualization by many researchers: `Rainbow Color
      Map (Still) Considered Harmful
      <http://ieeexplore.ieee.org/document/4118486/?arnumber=4118486>`_

    .. [#] Resembles "BkBlAqGrYeOrReViWh200" from NCAR Command
      Language. See `Color Table Gallery
      <https://www.ncl.ucar.edu/Document/Graphics/color_table_gallery.shtml>`_

    .. [#] See `Diverging Color Maps for Scientific Visualization
      <http://www.kennethmoreland.com/color-maps/>`_ by Kenneth Moreland.

    .. [#] See `A Color Map for Effective Black-and-White Rendering of
      Color-Scale Images
      <https://www.mathworks.com/matlabcentral/fileexchange/2662-cmrmap-m>`_
      by Carey Rappaport

    .. [#] Changed to distinguish from ColorBrewer's *Spectral* map.
      :func:`spectral` still works, but
      ``set_cmap('nipy_spectral')`` is recommended for clarity.


    """
    ...

def _setup_pyplot_info_docstrings():
    """
    Generates the plotting and docstring.

    These must be done after the entire module is imported, so it is
    called from the end of this module, which is generated by
    boilerplate.py.
    """
    ...

def colorbar(mappable: Optional[Any] = ..., cax: Optional[Any] = ..., ax: Optional[Any] = ..., **kw):
    ...

def clim(vmin: Optional[Any] = ..., vmax: Optional[Any] = ...):
    """
    Set the color limits of the current image.

    To apply clim to all axes images do::

      clim(0, 0.5)

    If either *vmin* or *vmax* is None, the image min/max respectively
    will be used for color scaling.

    If you want to set the clim of multiple images,
    use, for example::

      for im in gca().get_images():
          im.set_clim(0, 0.05)

    """
    ...

def set_cmap(cmap):
    """
    Set the default colormap.  Applies to the current image if any.
    See help(colormaps) for more information.

    *cmap* must be a :class:`~matplotlib.colors.Colormap` instance, or
    the name of a registered colormap.

    See :func:`matplotlib.cm.register_cmap` and
    :func:`matplotlib.cm.get_cmap`.
    """
    ...

@docstring.copy_dedent(_imread)
def imread(*args, **kwargs):
    ...

@docstring.copy_dedent(_imsave)
def imsave(*args, **kwargs):
    ...

def matshow(A, fignum: Optional[Any] = ..., **kwargs):
    """
    Display an array as a matrix in a new figure window.

    The origin is set at the upper left hand corner and rows (first
    dimension of the array) are displayed horizontally.  The aspect
    ratio of the figure window is that of the array, unless this would
    make an excessively short or narrow figure.

    Tick labels for the xaxis are placed on top.

    Parameters
    ----------
    A : array-like(M, N)
        The matrix to be displayed.

    fignum : None or int or False
        If *None*, create a new figure window with automatic numbering.

        If *fignum* is an integer, draw into the figure with the given number
        (create it if it does not exist).

        If 0 or *False*, use the current axes if it exists instead of creating
        a new figure.

        .. note::

           Because of how `.Axes.matshow` tries to set the figure aspect
           ratio to be the one of the array, strange things may happen if you
           reuse an existing figure.

    Returns
    -------
    image : `~matplotlib.image.AxesImage`

    Other Parameters
    ----------------
    **kwargs : `~matplotlib.axes.Axes.imshow` arguments

    """
    ...

def polar(*args, **kwargs):
    """
    Make a polar plot.

    call signature::

      polar(theta, r, **kwargs)

    Multiple *theta*, *r* arguments are supported, with format
    strings, as in :func:`~matplotlib.pyplot.plot`.

    """
    ...

def plotfile(fname, cols=..., plotfuncs: Optional[Any] = ..., comments=..., skiprows=..., checkrows=..., delimiter=..., names: Optional[Any] = ..., subplots: bool = ..., newfig: bool = ..., **kwargs):
    """
    Plot the data in a file.

    *cols* is a sequence of column identifiers to plot.  An identifier
    is either an int or a string.  If it is an int, it indicates the
    column number.  If it is a string, it indicates the column header.
    matplotlib will make column headers lower case, replace spaces with
    underscores, and remove all illegal characters; so ``'Adj Close*'``
    will have name ``'adj_close'``.

    - If len(*cols*) == 1, only that column will be plotted on the *y* axis.

    - If len(*cols*) > 1, the first element will be an identifier for
      data for the *x* axis and the remaining elements will be the
      column indexes for multiple subplots if *subplots* is *True*
      (the default), or for lines in a single subplot if *subplots*
      is *False*.

    *plotfuncs*, if not *None*, is a dictionary mapping identifier to
    an :class:`~matplotlib.axes.Axes` plotting function as a string.
    Default is 'plot', other choices are 'semilogy', 'fill', 'bar',
    etc.  You must use the same type of identifier in the *cols*
    vector as you use in the *plotfuncs* dictionary, e.g., integer
    column numbers in both or column names in both. If *subplots*
    is *False*, then including any function such as 'semilogy'
    that changes the axis scaling will set the scaling for all
    columns.

    *comments*, *skiprows*, *checkrows*, *delimiter*, and *names*
    are all passed on to :func:`matplotlib.pylab.csv2rec` to
    load the data into a record array.

    If *newfig* is *True*, the plot always will be made in a new figure;
    if *False*, it will be made in the current figure if one exists,
    else in a new figure.

    kwargs are passed on to plotting functions.

    Example usage::

      # plot the 2nd and 4th column against the 1st in two subplots
      plotfile(fname, (0,1,3))

      # plot using column names; specify an alternate plot type for volume
      plotfile(fname, ('date', 'volume', 'adj_close'),
                                    plotfuncs={'volume': 'semilogy'})

    Note: plotfile is intended as a convenience for quickly plotting
    data from flat files; it is not intended as an alternative
    interface to general plotting with pyplot or matplotlib.
    """
    ...

def _autogen_docstring(base):
    """Autogenerated wrappers will get their docstring from a base function
    with an addendum."""
    ...

@_autogen_docstring(Axes.spy)
def spy(Z, precision=..., marker: Optional[Any] = ..., markersize: Optional[Any] = ..., aspect=..., **kwargs):
    ...

@_autogen_docstring(Axes.acorr)
def acorr(x, hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.angle_spectrum)
def angle_spectrum(x, Fs: Optional[Any] = ..., Fc: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.arrow)
def arrow(x, y, dx, dy, hold: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.axhline)
def axhline(y=..., xmin=..., xmax=..., hold: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.axhspan)
def axhspan(ymin, ymax, xmin=..., xmax=..., hold: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.axvline)
def axvline(x=..., ymin=..., ymax=..., hold: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.axvspan)
def axvspan(xmin, xmax, ymin=..., ymax=..., hold: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.bar)
def bar(*args, **kwargs):
    ...

@_autogen_docstring(Axes.barh)
def barh(*args, **kwargs):
    ...

@_autogen_docstring(Axes.broken_barh)
def broken_barh(xranges, yrange, hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.boxplot)
def boxplot(x, notch: Optional[Any] = ..., sym: Optional[Any] = ..., vert: Optional[Any] = ..., whis: Optional[Any] = ..., positions: Optional[Any] = ..., widths: Optional[Any] = ..., patch_artist: Optional[Any] = ..., bootstrap: Optional[Any] = ..., usermedians: Optional[Any] = ..., conf_intervals: Optional[Any] = ..., meanline: Optional[Any] = ..., showmeans: Optional[Any] = ..., showcaps: Optional[Any] = ..., showbox: Optional[Any] = ..., showfliers: Optional[Any] = ..., boxprops: Optional[Any] = ..., labels: Optional[Any] = ..., flierprops: Optional[Any] = ..., medianprops: Optional[Any] = ..., meanprops: Optional[Any] = ..., capprops: Optional[Any] = ..., whiskerprops: Optional[Any] = ..., manage_xticks: bool = ..., autorange: bool = ..., zorder: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ...):
    ...

@_autogen_docstring(Axes.cohere)
def cohere(x, y, NFFT=..., Fs=..., Fc=..., detrend=..., window=..., noverlap=..., pad_to: Optional[Any] = ..., sides=..., scale_by_freq: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.clabel)
def clabel(CS, *args, **kwargs):
    ...

@_autogen_docstring(Axes.contour)
def contour(*args, **kwargs):
    ...

@_autogen_docstring(Axes.contourf)
def contourf(*args, **kwargs):
    ...

@_autogen_docstring(Axes.csd)
def csd(x, y, NFFT: Optional[Any] = ..., Fs: Optional[Any] = ..., Fc: Optional[Any] = ..., detrend: Optional[Any] = ..., window: Optional[Any] = ..., noverlap: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale_by_freq: Optional[Any] = ..., return_line: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.errorbar)
def errorbar(x, y, yerr: Optional[Any] = ..., xerr: Optional[Any] = ..., fmt=..., ecolor: Optional[Any] = ..., elinewidth: Optional[Any] = ..., capsize: Optional[Any] = ..., barsabove: bool = ..., lolims: bool = ..., uplims: bool = ..., xlolims: bool = ..., xuplims: bool = ..., errorevery=..., capthick: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.eventplot)
def eventplot(positions, orientation=..., lineoffsets=..., linelengths=..., linewidths: Optional[Any] = ..., colors: Optional[Any] = ..., linestyles=..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.fill)
def fill(*args, **kwargs):
    ...

@_autogen_docstring(Axes.fill_between)
def fill_between(x, y1, y2=..., where: Optional[Any] = ..., interpolate: bool = ..., step: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.fill_betweenx)
def fill_betweenx(y, x1, x2=..., where: Optional[Any] = ..., step: Optional[Any] = ..., interpolate: bool = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.hexbin)
def hexbin(x, y, C: Optional[Any] = ..., gridsize=..., bins: Optional[Any] = ..., xscale=..., yscale=..., extent: Optional[Any] = ..., cmap: Optional[Any] = ..., norm: Optional[Any] = ..., vmin: Optional[Any] = ..., vmax: Optional[Any] = ..., alpha: Optional[Any] = ..., linewidths: Optional[Any] = ..., edgecolors=..., reduce_C_function=..., mincnt: Optional[Any] = ..., marginals: bool = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.hist)
def hist(x, bins: Optional[Any] = ..., range: Optional[Any] = ..., density: Optional[Any] = ..., weights: Optional[Any] = ..., cumulative: bool = ..., bottom: Optional[Any] = ..., histtype=..., align=..., orientation=..., rwidth: Optional[Any] = ..., log: bool = ..., color: Optional[Any] = ..., label: Optional[Any] = ..., stacked: bool = ..., normed: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.hist2d)
def hist2d(x, y, bins=..., range: Optional[Any] = ..., normed: bool = ..., weights: Optional[Any] = ..., cmin: Optional[Any] = ..., cmax: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.hlines)
def hlines(y, xmin, xmax, colors=..., linestyles=..., label=..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.imshow)
def imshow(X, cmap: Optional[Any] = ..., norm: Optional[Any] = ..., aspect: Optional[Any] = ..., interpolation: Optional[Any] = ..., alpha: Optional[Any] = ..., vmin: Optional[Any] = ..., vmax: Optional[Any] = ..., origin: Optional[Any] = ..., extent: Optional[Any] = ..., shape: Optional[Any] = ..., filternorm=..., filterrad=..., imlim: Optional[Any] = ..., resample: Optional[Any] = ..., url: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.loglog)
def loglog(*args, **kwargs):
    ...

@_autogen_docstring(Axes.magnitude_spectrum)
def magnitude_spectrum(x, Fs: Optional[Any] = ..., Fc: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.pcolor)
def pcolor(*args, **kwargs):
    ...

@_autogen_docstring(Axes.pcolormesh)
def pcolormesh(*args, **kwargs):
    ...

@_autogen_docstring(Axes.phase_spectrum)
def phase_spectrum(x, Fs: Optional[Any] = ..., Fc: Optional[Any] = ..., window: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.pie)
def pie(x, explode: Optional[Any] = ..., labels: Optional[Any] = ..., colors: Optional[Any] = ..., autopct: Optional[Any] = ..., pctdistance=..., shadow: bool = ..., labeldistance=..., startangle: Optional[Any] = ..., radius: Optional[Any] = ..., counterclock: bool = ..., wedgeprops: Optional[Any] = ..., textprops: Optional[Any] = ..., center=..., frame: bool = ..., rotatelabels: bool = ..., hold: Optional[Any] = ..., data: Optional[Any] = ...):
    ...

@_autogen_docstring(Axes.plot)
def plot(*args, **kwargs):
    ...

@_autogen_docstring(Axes.plot_date)
def plot_date(x, y, fmt=..., tz: Optional[Any] = ..., xdate: bool = ..., ydate: bool = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.psd)
def psd(x, NFFT: Optional[Any] = ..., Fs: Optional[Any] = ..., Fc: Optional[Any] = ..., detrend: Optional[Any] = ..., window: Optional[Any] = ..., noverlap: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale_by_freq: Optional[Any] = ..., return_line: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.quiver)
def quiver(*args, **kw):
    ...

@_autogen_docstring(Axes.quiverkey)
def quiverkey(*args, **kw):
    ...

@_autogen_docstring(Axes.scatter)
def scatter(x, y, s: Optional[Any] = ..., c: Optional[Any] = ..., marker: Optional[Any] = ..., cmap: Optional[Any] = ..., norm: Optional[Any] = ..., vmin: Optional[Any] = ..., vmax: Optional[Any] = ..., alpha: Optional[Any] = ..., linewidths: Optional[Any] = ..., verts: Optional[Any] = ..., edgecolors: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.semilogx)
def semilogx(*args, **kwargs):
    ...

@_autogen_docstring(Axes.semilogy)
def semilogy(*args, **kwargs):
    ...

@_autogen_docstring(Axes.specgram)
def specgram(x, NFFT: Optional[Any] = ..., Fs: Optional[Any] = ..., Fc: Optional[Any] = ..., detrend: Optional[Any] = ..., window: Optional[Any] = ..., noverlap: Optional[Any] = ..., cmap: Optional[Any] = ..., xextent: Optional[Any] = ..., pad_to: Optional[Any] = ..., sides: Optional[Any] = ..., scale_by_freq: Optional[Any] = ..., mode: Optional[Any] = ..., scale: Optional[Any] = ..., vmin: Optional[Any] = ..., vmax: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.stackplot)
def stackplot(x, *args, **kwargs):
    ...

@_autogen_docstring(Axes.stem)
def stem(*args, **kwargs):
    ...

@_autogen_docstring(Axes.step)
def step(x, y, *args, **kwargs):
    ...

@_autogen_docstring(Axes.streamplot)
def streamplot(x, y, u, v, density=..., linewidth: Optional[Any] = ..., color: Optional[Any] = ..., cmap: Optional[Any] = ..., norm: Optional[Any] = ..., arrowsize=..., arrowstyle=..., minlength=..., transform: Optional[Any] = ..., zorder: Optional[Any] = ..., start_points: Optional[Any] = ..., maxlength=..., integration_direction=..., hold: Optional[Any] = ..., data: Optional[Any] = ...):
    ...

@_autogen_docstring(Axes.tricontour)
def tricontour(*args, **kwargs):
    ...

@_autogen_docstring(Axes.tricontourf)
def tricontourf(*args, **kwargs):
    ...

@_autogen_docstring(Axes.tripcolor)
def tripcolor(*args, **kwargs):
    ...

@_autogen_docstring(Axes.triplot)
def triplot(*args, **kwargs):
    ...

@_autogen_docstring(Axes.violinplot)
def violinplot(dataset, positions: Optional[Any] = ..., vert: bool = ..., widths=..., showmeans: bool = ..., showextrema: bool = ..., showmedians: bool = ..., points=..., bw_method: Optional[Any] = ..., hold: Optional[Any] = ..., data: Optional[Any] = ...):
    ...

@_autogen_docstring(Axes.vlines)
def vlines(x, ymin, ymax, colors=..., linestyles=..., label=..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.xcorr)
def xcorr(x, y, normed: bool = ..., detrend=..., usevlines: bool = ..., maxlags=..., hold: Optional[Any] = ..., data: Optional[Any] = ..., **kwargs):
    ...

@_autogen_docstring(Axes.barbs)
def barbs(*args, **kw):
    ...

@docstring.copy_dedent(Axes.cla)
def cla():
    ...

@docstring.copy_dedent(Axes.grid)
def grid(b: Optional[Any] = ..., which=..., axis=..., **kwargs):
    ...

@docstring.copy_dedent(Axes.legend)
def legend(*args, **kwargs):
    ...

@docstring.copy_dedent(Axes.table)
def table(**kwargs):
    ...

@docstring.copy_dedent(Axes.text)
def text(x, y, s, fontdict: Optional[Any] = ..., withdash: bool = ..., **kwargs):
    ...

@docstring.copy_dedent(Axes.annotate)
def annotate(*args, **kwargs):
    ...

@docstring.copy_dedent(Axes.ticklabel_format)
def ticklabel_format(**kwargs):
    ...

@docstring.copy_dedent(Axes.locator_params)
def locator_params(axis=..., tight: Optional[Any] = ..., **kwargs):
    ...

@docstring.copy_dedent(Axes.tick_params)
def tick_params(axis=..., **kwargs):
    ...

@docstring.copy_dedent(Axes.margins)
def margins(*args, **kw):
    ...

@docstring.copy_dedent(Axes.autoscale)
def autoscale(enable: bool = ..., axis=..., tight: Optional[Any] = ...):
    ...

def autumn():
    """
    Set the colormap to "autumn".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def bone():
    """
    Set the colormap to "bone".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def cool():
    """
    Set the colormap to "cool".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def copper():
    """
    Set the colormap to "copper".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def flag():
    """
    Set the colormap to "flag".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def gray():
    """
    Set the colormap to "gray".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def hot():
    """
    Set the colormap to "hot".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def hsv():
    """
    Set the colormap to "hsv".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def jet():
    """
    Set the colormap to "jet".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def pink():
    """
    Set the colormap to "pink".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def prism():
    """
    Set the colormap to "prism".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def spring():
    """
    Set the colormap to "spring".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def summer():
    """
    Set the colormap to "summer".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def winter():
    """
    Set the colormap to "winter".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def magma():
    """
    Set the colormap to "magma".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def inferno():
    """
    Set the colormap to "inferno".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def plasma():
    """
    Set the colormap to "plasma".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def viridis():
    """
    Set the colormap to "viridis".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def nipy_spectral():
    """
    Set the colormap to "nipy_spectral".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

def spectral():
    """
    Set the colormap to "spectral".

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    ...

