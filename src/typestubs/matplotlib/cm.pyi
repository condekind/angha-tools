"""
This type stub file was generated by pyright.
"""

import matplotlib as mpl
from typing import Any, Optional

"""
Builtin colormaps, colormap handling utilities, and the `ScalarMappable` mixin.

See :doc:`/gallery/color/colormap_reference` for a list of builtin colormaps.
See :doc:`/tutorials/colors/colormaps` for an in-depth discussion of colormaps.
"""
cmap_d = {  }
def _reverser(f):
    ...

def revcmap(data):
    """Can only handle specification *data* in dictionary format."""
    ...

def _reverse_cmap_spec(spec):
    """Reverses cmap specification *spec*, can handle both dict and tuple
    type specs."""
    ...

def _generate_cmap(name, lutsize):
    """Generates the requested cmap from its *name*.  The lut size is
    *lutsize*."""
    ...

LUTSIZE = mpl.rcParams['image.lut']
def register_cmap(name: Optional[Any] = ..., cmap: Optional[Any] = ..., data: Optional[Any] = ..., lut: Optional[Any] = ...):
    """
    Add a colormap to the set recognized by :func:`get_cmap`.

    It can be used in two ways::

        register_cmap(name='swirly', cmap=swirly_cmap)

        register_cmap(name='choppy', data=choppydata, lut=128)

    In the first case, *cmap* must be a :class:`matplotlib.colors.Colormap`
    instance.  The *name* is optional; if absent, the name will
    be the :attr:`~matplotlib.colors.Colormap.name` attribute of the *cmap*.

    In the second case, the three arguments are passed to
    the :class:`~matplotlib.colors.LinearSegmentedColormap` initializer,
    and the resulting colormap is registered.

    """
    ...

def get_cmap(name: Optional[Any] = ..., lut: Optional[Any] = ...):
    """
    Get a colormap instance, defaulting to rc values if *name* is None.

    Colormaps added with :func:`register_cmap` take precedence over
    built-in colormaps.

    If *name* is a :class:`matplotlib.colors.Colormap` instance, it will be
    returned.

    If *lut* is not None it must be an integer giving the number of
    entries desired in the lookup table, and *name* must be a standard
    mpl colormap name.
    """
    ...

class ScalarMappable(object):
    """
    This is a mixin class to support scalar data to RGBA mapping.
    The ScalarMappable makes use of data normalization before returning
    RGBA colors from the given colormap.

    """
    def __init__(self, norm: Optional[Any] = ..., cmap: Optional[Any] = ...):
        r"""

        Parameters
        ----------
        norm : :class:`matplotlib.colors.Normalize` instance
            The normalizing object which scales data, typically into the
            interval ``[0, 1]``.
            If *None*, *norm* defaults to a *colors.Normalize* object which
            initializes its scaling based on the first data processed.
        cmap : str or :class:`~matplotlib.colors.Colormap` instance
            The colormap used to map normalized data values to RGBA colors.
        """
        self.callbacksSM = ...
        self.norm = ...
        self.cmap = ...
        self.colorbar = ...
        self.update_dict = ...
    
    def to_rgba(self, x, alpha: Optional[Any] = ..., bytes: bool = ..., norm: bool = ...):
        """
        Return a normalized rgba array corresponding to *x*.

        In the normal case, *x* is a 1-D or 2-D sequence of scalars, and
        the corresponding ndarray of rgba values will be returned,
        based on the norm and colormap set for this ScalarMappable.

        There is one special case, for handling images that are already
        rgb or rgba, such as might have been read from an image file.
        If *x* is an ndarray with 3 dimensions,
        and the last dimension is either 3 or 4, then it will be
        treated as an rgb or rgba array, and no mapping will be done.
        The array can be uint8, or it can be floating point with
        values in the 0-1 range; otherwise a ValueError will be raised.
        If it is a masked array, the mask will be ignored.
        If the last dimension is 3, the *alpha* kwarg (defaulting to 1)
        will be used to fill in the transparency.  If the last dimension
        is 4, the *alpha* kwarg is ignored; it does not
        replace the pre-existing alpha.  A ValueError will be raised
        if the third dimension is other than 3 or 4.

        In either case, if *bytes* is *False* (default), the rgba
        array will be floats in the 0-1 range; if it is *True*,
        the returned rgba array will be uint8 in the 0 to 255 range.

        If norm is False, no normalization of the input data is
        performed, and it is assumed to be in the range (0-1).

        """
        ...
    
    def set_array(self, A):
        """Set the image array from numpy array *A*.

        .. ACCEPTS: ndarray

        Parameters
        ----------
        A : ndarray
        """
        ...
    
    def get_array(self):
        'Return the array'
        ...
    
    def get_cmap(self):
        'return the colormap'
        ...
    
    def get_clim(self):
        'return the min, max of the color limits for image scaling'
        ...
    
    def set_clim(self, vmin: Optional[Any] = ..., vmax: Optional[Any] = ...):
        """
        set the norm limits for image scaling; if *vmin* is a length2
        sequence, interpret it as ``(vmin, vmax)`` which is used to
        support setp

        ACCEPTS: a length 2 sequence of floats; may be overridden in methods
        that have ``vmin`` and ``vmax`` kwargs.
        """
        ...
    
    def set_cmap(self, cmap):
        """
        set the colormap for luminance data

        ACCEPTS: a colormap or registered colormap name
        """
        self.cmap = ...
    
    def set_norm(self, norm):
        """Set the normalization instance.

        .. ACCEPTS: `.Normalize`

        Parameters
        ----------
        norm : `.Normalize`
        """
        self.norm = ...
    
    def autoscale(self):
        """
        Autoscale the scalar limits on the norm instance using the
        current array
        """
        ...
    
    def autoscale_None(self):
        """
        Autoscale the scalar limits on the norm instance using the
        current array, changing only limits that are None
        """
        ...
    
    def add_checker(self, checker):
        """
        Add an entry to a dictionary of boolean flags
        that are set to True when the mappable is changed.
        """
        ...
    
    def check_update(self, checker):
        """
        If mappable has changed since the last check,
        return True; else return False
        """
        ...
    
    def changed(self):
        """
        Call this whenever the mappable is changed to notify all the
        callbackSM listeners to the 'changed' signal
        """
        self.stale = ...
    


