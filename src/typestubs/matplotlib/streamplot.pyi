"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

"""
Streamline plotting for 2D vector fields.

"""
__all__ = ['streamplot']
def streamplot(axes, x, y, u, v, density=..., linewidth: Optional[Any] = ..., color: Optional[Any] = ..., cmap: Optional[Any] = ..., norm: Optional[Any] = ..., arrowsize=..., arrowstyle=..., minlength=..., transform: Optional[Any] = ..., zorder: Optional[Any] = ..., start_points: Optional[Any] = ..., maxlength=..., integration_direction=...):
    """Draws streamlines of a vector flow.

    *x*, *y* : 1d arrays
        an *evenly spaced* grid.
    *u*, *v* : 2d arrays
        x and y-velocities. Number of rows should match length of y, and
        the number of columns should match x.
    *density* : float or 2-tuple
        Controls the closeness of streamlines. When `density = 1`, the domain
        is divided into a 30x30 grid---*density* linearly scales this grid.
        Each cell in the grid can have, at most, one traversing streamline.
        For different densities in each direction, use [density_x, density_y].
    *linewidth* : numeric or 2d array
        vary linewidth when given a 2d array with the same shape as velocities.
    *color* : matplotlib color code, or 2d array
        Streamline color. When given an array with the same shape as
        velocities, *color* values are converted to colors using *cmap*.
    *cmap* : :class:`~matplotlib.colors.Colormap`
        Colormap used to plot streamlines and arrows. Only necessary when using
        an array input for *color*.
    *norm* : :class:`~matplotlib.colors.Normalize`
        Normalize object used to scale luminance data to 0, 1. If None, stretch
        (min, max) to (0, 1). Only necessary when *color* is an array.
    *arrowsize* : float
        Factor scale arrow size.
    *arrowstyle* : str
        Arrow style specification.
        See :class:`~matplotlib.patches.FancyArrowPatch`.
    *minlength* : float
        Minimum length of streamline in axes coordinates.
    *start_points*: Nx2 array
        Coordinates of starting points for the streamlines.
        In data coordinates, the same as the ``x`` and ``y`` arrays.
    *zorder* : int
        any number
    *maxlength* : float
        Maximum length of streamline in axes coordinates.
    *integration_direction* : ['forward', 'backward', 'both']
        Integrate the streamline in forward, backward or both directions.

    Returns:

        *stream_container* : StreamplotSet
            Container object with attributes

                - lines: `matplotlib.collections.LineCollection` of streamlines

                - arrows: collection of `matplotlib.patches.FancyArrowPatch`
                  objects representing arrows half-way along stream
                  lines.

            This container will probably change in the future to allow changes
            to the colormap, alpha, etc. for both lines and arrows, but these
            changes should be backward compatible.

    """
    ...

class StreamplotSet(object):
    def __init__(self, lines, arrows, **kwargs):
        self.lines = ...
        self.arrows = ...
    


class DomainMap(object):
    """Map representing different coordinate systems.

    Coordinate definitions:

    * axes-coordinates goes from 0 to 1 in the domain.
    * data-coordinates are specified by the input x-y coordinates.
    * grid-coordinates goes from 0 to N and 0 to M for an N x M grid,
      where N and M match the shape of the input data.
    * mask-coordinates goes from 0 to N and 0 to M for an N x M mask,
      where N and M are user-specified to control the density of streamlines.

    This class also has methods for adding trajectories to the StreamMask.
    Before adding a trajectory, run `start_trajectory` to keep track of regions
    crossed by a given trajectory. Later, if you decide the trajectory is bad
    (e.g., if the trajectory is very short) just call `undo_trajectory`.
    """
    def __init__(self, grid, mask):
        self.grid = ...
        self.mask = ...
        self.x_grid2mask = ...
        self.y_grid2mask = ...
        self.x_mask2grid = ...
        self.y_mask2grid = ...
        self.x_data2grid = ...
        self.y_data2grid = ...
    
    def grid2mask(self, xi, yi):
        """Return nearest space in mask-coords from given grid-coords."""
        ...
    
    def mask2grid(self, xm, ym):
        ...
    
    def data2grid(self, xd, yd):
        ...
    
    def grid2data(self, xg, yg):
        ...
    
    def start_trajectory(self, xg, yg):
        ...
    
    def reset_start_point(self, xg, yg):
        ...
    
    def update_trajectory(self, xg, yg):
        ...
    
    def undo_trajectory(self):
        ...
    


class Grid(object):
    """Grid of data."""
    def __init__(self, x, y):
        self.nx = ...
        self.ny = ...
        self.dx = ...
        self.dy = ...
        self.x_origin = ...
        self.y_origin = ...
        self.width = ...
        self.height = ...
    
    @property
    def shape(self):
        ...
    
    def within_grid(self, xi, yi):
        """Return True if point is a valid index of grid."""
        ...
    


class StreamMask(object):
    """Mask to keep track of discrete regions crossed by streamlines.

    The resolution of this grid determines the approximate spacing between
    trajectories. Streamlines are only allowed to pass through zeroed cells:
    When a streamline enters a cell, that cell is set to 1, and no new
    streamlines are allowed to enter.
    """
    def __init__(self, density):
        self.shape = ...
    
    def __getitem__(self, *args):
        ...
    
    def _start_trajectory(self, xm, ym):
        """Start recording streamline trajectory"""
        ...
    
    def _undo_trajectory(self):
        """Remove current trajectory from mask"""
        ...
    
    def _update_trajectory(self, xm, ym):
        """Update current trajectory position in mask.

        If the new position has already been filled, raise `InvalidIndexError`.
        """
        ...
    


class InvalidIndexError(Exception):
    ...


class TerminateTrajectory(Exception):
    ...


def get_integrator(u, v, dmap, minlength, maxlength, integration_direction):
    ...

def _integrate_rk12(x0, y0, dmap, f, maxlength):
    """2nd-order Runge-Kutta algorithm with adaptive step size.

    This method is also referred to as the improved Euler's method, or Heun's
    method. This method is favored over higher-order methods because:

    1. To get decent looking trajectories and to sample every mask cell
       on the trajectory we need a small timestep, so a lower order
       solver doesn't hurt us unless the data is *very* high resolution.
       In fact, for cases where the user inputs
       data smaller or of similar grid size to the mask grid, the higher
       order corrections are negligible because of the very fast linear
       interpolation used in `interpgrid`.

    2. For high resolution input data (i.e. beyond the mask
       resolution), we must reduce the timestep. Therefore, an adaptive
       timestep is more suited to the problem as this would be very hard
       to judge automatically otherwise.

    This integrator is about 1.5 - 2x as fast as both the RK4 and RK45
    solvers in most setups on my machine. I would recommend removing the
    other two to keep things simple.
    """
    ...

def _euler_step(xf_traj, yf_traj, dmap, f):
    """Simple Euler integration step that extends streamline to boundary."""
    ...

def interpgrid(a, xi, yi):
    """Fast 2D, linear interpolation on an integer grid"""
    ...

def _gen_starting_points(shape):
    """Yield starting points for streamlines.

    Trying points on the boundary first gives higher quality streamlines.
    This algorithm starts with a point on the mask corner and spirals inward.
    This algorithm is inefficient, but fast compared to rest of streamplot.
    """
    ...

