"""
This type stub file was generated by pyright.
"""

import six
import atexit
import contextlib
import distutils.version
import functools
import io
import inspect
import itertools
import locale
import logging
import os
import re
import shutil
import stat
import sys
import tempfile
import warnings
import numpy
from __future__ import absolute_import, division, print_function
from collections import MutableMapping
from . import cbook
from matplotlib.cbook import _backports, dedent, get_label, mplDeprecation, sanitize_sequence
from matplotlib.compat import subprocess
from matplotlib.rcsetup import cycler, defaultParams, validate_backend
from six.moves.urllib.request import urlopen
from six.moves import reload_module as reload
from ._version import get_versions
from typing import Any, Optional

"""
This is an object-oriented plotting library.

A procedural interface is provided by the companion pyplot module,
which may be imported directly, e.g.::

    import matplotlib.pyplot as plt

or using ipython::

    ipython

at your terminal, followed by::

    In [1]: %matplotlib
    In [2]: import matplotlib.pyplot as plt

at the ipython shell prompt.

For the most part, direct use of the object-oriented library is
encouraged when programming; pyplot is primarily for working
interactively.  The
exceptions are the pyplot commands :func:`~matplotlib.pyplot.figure`,
:func:`~matplotlib.pyplot.subplot`,
:func:`~matplotlib.pyplot.subplots`, and
:func:`~pyplot.savefig`, which can greatly simplify scripting.

Modules include:

    :mod:`matplotlib.axes`
        defines the :class:`~matplotlib.axes.Axes` class.  Most pylab
        commands are wrappers for :class:`~matplotlib.axes.Axes`
        methods.  The axes module is the highest level of OO access to
        the library.

    :mod:`matplotlib.figure`
        defines the :class:`~matplotlib.figure.Figure` class.

    :mod:`matplotlib.artist`
        defines the :class:`~matplotlib.artist.Artist` base class for
        all classes that draw things.

    :mod:`matplotlib.lines`
        defines the :class:`~matplotlib.lines.Line2D` class for
        drawing lines and markers

    :mod:`matplotlib.patches`
        defines classes for drawing polygons

    :mod:`matplotlib.text`
        defines the :class:`~matplotlib.text.Text`,
        :class:`~matplotlib.text.TextWithDash`, and
        :class:`~matplotlib.text.Annotate` classes

    :mod:`matplotlib.image`
        defines the :class:`~matplotlib.image.AxesImage` and
        :class:`~matplotlib.image.FigureImage` classes

    :mod:`matplotlib.collections`
        classes for efficient drawing of groups of lines or polygons

    :mod:`matplotlib.colors`
        classes for interpreting color specifications and for making
        colormaps

    :mod:`matplotlib.cm`
        colormaps and the :class:`~matplotlib.image.ScalarMappable`
        mixin class for providing color mapping functionality to other
        classes

    :mod:`matplotlib.ticker`
        classes for calculating tick mark locations and for formatting
        tick labels

    :mod:`matplotlib.backends`
        a subpackage with modules for various gui libraries and output
        formats

The base matplotlib namespace includes:

    :data:`~matplotlib.rcParams`
        a global dictionary of default configuration settings.  It is
        initialized by code which may be overridden by a matplotlibrc
        file.

    :func:`~matplotlib.rc`
        a function for setting groups of rcParams values

    :func:`~matplotlib.use`
        a function for setting the matplotlib backend.  If used, this
        function must be called immediately after importing matplotlib
        for the first time.  In particular, it must be called
        **before** importing pylab (if pylab is imported).

matplotlib was initially written by John D. Hunter (1968-2012) and is now
developed and maintained by a host of others.

Occasionally the internal documentation (python docstrings) will refer
to MATLAB&reg;, a registered trademark of The MathWorks, Inc.

"""
__version__ = str(get_versions()['version'])
_log = logging.getLogger(__name__)
__version__numpy__ = str('1.7.1')
__bibtex__ = r"""@Article{Hunter:2007,
  Author    = {Hunter, J. D.},
  Title     = {Matplotlib: A 2D graphics environment},
  Journal   = {Computing In Science \& Engineering},
  Volume    = {9},
  Number    = {3},
  Pages     = {90--95},
  abstract  = {Matplotlib is a 2D graphics package used for Python
  for application development, interactive scripting, and
  publication-quality image generation across user
  interfaces and operating systems.},
  publisher = {IEEE COMPUTER SOC},
  year      = 2007
}"""
_python27 = sys.version_info.major == 2 and sys.version_info.minor >= 7
_python34 = sys.version_info.major == 3 and sys.version_info.minor >= 4
if not _python27 or _python34:
    ...
if _python27:
    ...
def compare_versions(a, b):
    "return True if a is greater than or equal to b"
    ...

if not compare_versions(six.__version__, '1.10'):
    ...
if not compare_versions(numpy.__version__, __version__numpy__):
    ...
if not hasattr(sys, 'argv'):
    ...
def _is_writable_dir(p):
    """
    p is a string pointing to a putative writable dir -- return True p
    is such a string, else False
    """
    ...

_verbose_msg = """\
matplotlib.verbose is deprecated;
Command line argument --verbose-LEVEL is deprecated.
This functionality is now provided by the standard
python logging library.  To get more (or less) logging output:
    import logging
    logger = logging.getLogger('matplotlib')
    logger.set_level(logging.INFO)"""
def _set_logger_verbose_level(level_str=..., file_str=...):
    """
    Use a --verbose-LEVEL level to set the logging level:

    """
    ...

def _parse_commandline():
    """
    Check for --verbose-LEVEL type command line arguments and
    set logging level appropriately.
    """
    ...

class Verbose(object):
    """
    A class to handle reporting.  Set the fileo attribute to any file
    instance to handle the output.  Default is sys.stdout
    """
    levels = ...
    vald = ...
    _commandLineVerbose = ...
    @cbook.deprecated("2.2", message=_verbose_msg)
    def __init__(self):
        self.fileo = ...
    
    @cbook.deprecated("2.2", message=_verbose_msg)
    def set_level(self, level):
        'set the verbosity to one of the Verbose.levels strings'
        ...
    
    @cbook.deprecated("2.2", message=_verbose_msg)
    def set_fileo(self, fname):
        ...
    
    @cbook.deprecated("2.2", message=_verbose_msg)
    def report(self, s, level=...):
        """
        print message s to self.fileo if self.level>=level.  Return
        value indicates whether a message was issued

        """
        ...
    
    @cbook.deprecated("2.2", message=_verbose_msg)
    def wrap(self, fmt, func, level=..., always: bool = ...):
        """
        return a callable function that wraps func and reports it
        output through the verbose handler if current verbosity level
        is higher than level

        if always is True, the report will occur on every function
        call; otherwise only on the first time the function is called
        """
        ...
    
    @cbook.deprecated("2.2", message=_verbose_msg)
    def ge(self, level):
        'return true if self.level is >= level'
        ...
    


def _wrap(fmt, func, level=..., always: bool = ...):
    """
    return a callable function that wraps func and reports its
    output through logger

    if always is True, the report will occur on every function
    call; otherwise only on the first time the function is called
    """
    ...

def checkdep_dvipng():
    ...

def checkdep_ghostscript():
    ...

@cbook.deprecated("2.1")
def checkdep_tex():
    ...

def checkdep_pdftops():
    ...

def checkdep_inkscape():
    ...

@cbook.deprecated("2.1")
def checkdep_xmllint():
    ...

def checkdep_ps_distiller(s):
    ...

def checkdep_usetex(s):
    ...

def _get_home():
    """Find user's home directory if possible.
    Otherwise, returns None.

    :see:
        http://mail.python.org/pipermail/python-list/2005-February/325395.html
    """
    ...

def _create_tmp_config_dir():
    """
    If the config directory can not be created, create a temporary
    directory.
    """
    ...

get_home = _wrap('$HOME=%s', _get_home, always=False)
def _get_xdg_config_dir():
    """
    Returns the XDG configuration directory, according to the `XDG
    base directory spec
    <http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html>`_.
    """
    ...

def _get_xdg_cache_dir():
    """
    Returns the XDG cache directory, according to the `XDG
    base directory spec
    <http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html>`_.
    """
    ...

def _get_config_or_cache_dir(xdg_base):
    ...

def _get_configdir():
    """
    Return the string representing the configuration directory.

    The directory is chosen as follows:

    1. If the MPLCONFIGDIR environment variable is supplied, choose that.

    2a. On Linux, follow the XDG specification and look first in
        `$XDG_CONFIG_HOME`, if defined, or `$HOME/.config`.

    2b. On other platforms, choose `$HOME/.matplotlib`.

    3. If the chosen directory exists and is writable, use that as the
       configuration directory.
    4. If possible, create a temporary directory, and use it as the
       configuration directory.
    5. A writable directory could not be found or created; return None.
    """
    ...

get_configdir = _wrap('CONFIGDIR=%s', _get_configdir, always=False)
def _get_cachedir():
    """
    Return the location of the cache directory.

    The procedure used to find the directory is the same as for
    _get_config_dir, except using `$XDG_CACHE_HOME`/`~/.cache` instead.
    """
    ...

get_cachedir = _wrap('CACHEDIR=%s', _get_cachedir, always=False)
def _decode_filesystem_path(path):
    ...

def _get_data_path():
    'get the path to matplotlib data'
    ...

def _get_data_path_cached():
    ...

get_data_path = _wrap('matplotlib data path %s', _get_data_path_cached, always=False)
def get_py2exe_datafiles():
    ...

def matplotlib_fname():
    """
    Get the location of the config file.

    The file location is determined in the following order

    - `$PWD/matplotlibrc`

    - `$MATPLOTLIBRC` if it is a file (or a named pipe, which can be created
      e.g. by process substitution)

    - `$MATPLOTLIBRC/matplotlibrc`

    - `$MPLCONFIGDIR/matplotlibrc`

    - On Linux,

          - `$XDG_CONFIG_HOME/matplotlib/matplotlibrc` (if
            $XDG_CONFIG_HOME is defined)

          - or `$HOME/.config/matplotlib/matplotlibrc` (if
            $XDG_CONFIG_HOME is not defined)

    - On other platforms,

         - `$HOME/.matplotlib/matplotlibrc` if `$HOME` is defined.

    - Lastly, it looks in `$MATPLOTLIBDATA/matplotlibrc` for a
      system-defined copy.
    """
    ...

_deprecated_map = {  }
_deprecated_ignore_map = { 'nbagg.transparent': 'figure.facecolor' }
_obsolete_set = 'plugins.directory', 'text.dvipnghack'
_deprecated_set = 'axes.hold', 'backend.qt4', 'backend.qt5'
_all_deprecated = set(itertools.chain(_deprecated_ignore_map, _deprecated_map, _obsolete_set))
class RcParams(MutableMapping, dict):
    """
    A dictionary object including validation

    validating functions are defined and associated with rc parameters in
    :mod:`matplotlib.rcsetup`
    """
    validate = ...
    msg_depr = ...
    msg_depr_set = ...
    msg_depr_ignore = ...
    msg_obsolete = ...
    msg_backend_obsolete = ...
    def __init__(self, *args, **kwargs):
        ...
    
    def __setitem__(self, key, val):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self):
        ...
    
    def __iter__(self):
        """
        Yield sorted list of keys.
        """
        ...
    
    def find_all(self, pattern):
        """
        Return the subset of this RcParams dictionary whose keys match,
        using :func:`re.search`, the given ``pattern``.

        .. note::

            Changes to the returned dictionary are *not* propagated to
            the parent RcParams dictionary.

        """
        ...
    


def rc_params(fail_on_error: bool = ...):
    """Return a :class:`matplotlib.RcParams` instance from the
    default matplotlib rc file.
    """
    ...

URL_REGEX = re.compile(r'http://|https://|ftp://|file://|file:\\')
def is_url(filename):
    """Return True if string is an http, ftp, or file URL path."""
    ...

def _url_lines(f):
    ...

@contextlib.contextmanager
def _open_file_or_url(fname):
    ...

_error_details_fmt = 'line #%d\n\t"%s"\n\tin file "%s"'
def _rc_params_in_file(fname, fail_on_error: bool = ...):
    """Return :class:`matplotlib.RcParams` from the contents of the given file.

    Unlike `rc_params_from_file`, the configuration class only contains the
    parameters specified in the file (i.e. default values are not filled in).
    """
    ...

def rc_params_from_file(fname, fail_on_error: bool = ..., use_default_template: bool = ...):
    """Return :class:`matplotlib.RcParams` from the contents of the given file.

    Parameters
    ----------
    fname : str
        Name of file parsed for matplotlib settings.
    fail_on_error : bool
        If True, raise an error when the parser fails to convert a parameter.
    use_default_template : bool
        If True, initialize with default parameters before updating with those
        in the given file. If False, the configuration class only contains the
        parameters specified in the file. (Useful for updating dicts.)
    """
    ...

rcParams = rc_params()
if rcParams['examples.directory']:
    ...
rcParamsOrig = rcParams.copy()
if rcParams['axes.formatter.use_locale']:
    ...
def rc(group, **kwargs):
    """
    Set the current rc params.  Group is the grouping for the rc, e.g.,
    for ``lines.linewidth`` the group is ``lines``, for
    ``axes.facecolor``, the group is ``axes``, and so on.  Group may
    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).
    *kwargs* is a dictionary attribute name/value pairs, e.g.,::

      rc('lines', linewidth=2, color='r')

    sets the current rc params and is equivalent to::

      rcParams['lines.linewidth'] = 2
      rcParams['lines.color'] = 'r'

    The following aliases are available to save typing for interactive
    users:

    =====   =================
    Alias   Property
    =====   =================
    'lw'    'linewidth'
    'ls'    'linestyle'
    'c'     'color'
    'fc'    'facecolor'
    'ec'    'edgecolor'
    'mew'   'markeredgewidth'
    'aa'    'antialiased'
    =====   =================

    Thus you could abbreviate the above rc command as::

          rc('lines', lw=2, c='r')


    Note you can use python's kwargs dictionary facility to store
    dictionaries of default parameters.  e.g., you can customize the
    font rc as follows::

      font = {'family' : 'monospace',
              'weight' : 'bold',
              'size'   : 'larger'}

      rc('font', **font)  # pass in the font dict as kwargs

    This enables you to easily switch between several configurations.  Use
    ``matplotlib.style.use('default')`` or :func:`~matplotlib.rcdefaults` to
    restore the default rc params after changes.
    """
    ...

def rcdefaults():
    """Restore the rc params from Matplotlib's internal defaults.

    See Also
    --------
    rc_file_defaults :
        Restore the rc params from the rc file originally loaded by Matplotlib.
    matplotlib.style.use :
        Use a specific style file.  Call ``style.use('default')`` to restore
        the default style.
    """
    ...

def rc_file_defaults():
    """Restore the rc params from the original rc file loaded by Matplotlib.
    """
    ...

def rc_file(fname):
    """
    Update rc params from file.
    """
    ...

class rc_context(object):
    """
    Return a context manager for managing rc settings.

    This allows one to do::

        with mpl.rc_context(fname='screen.rc'):
            plt.plot(x, a)
            with mpl.rc_context(fname='print.rc'):
                plt.plot(x, b)
            plt.plot(x, c)

    The 'a' vs 'x' and 'c' vs 'x' plots would have settings from
    'screen.rc', while the 'b' vs 'x' plot would have settings from
    'print.rc'.

    A dictionary can also be passed to the context manager::

        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):
            plt.plot(x, a)

    The 'rc' dictionary takes precedence over the settings loaded from
    'fname'.  Passing a dictionary only is also valid. For example a
    common usage is::

        with mpl.rc_context(rc={'interactive': False}):
            fig, ax = plt.subplots()
            ax.plot(range(3), range(3))
            fig.savefig('A.png', format='png')
            plt.close(fig)
    """
    def __init__(self, rc: Optional[Any] = ..., fname: Optional[Any] = ...):
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_value, exc_tb):
        ...
    


_use_error_msg = """
This call to matplotlib.use() has no effect because the backend has already
been chosen; matplotlib.use() must be called *before* pylab, matplotlib.pyplot,
or matplotlib.backends is imported for the first time.

The backend was *originally* set to {backend!r} by the following code:
{tb}
"""
def use(arg, warn: bool = ..., force: bool = ...):
    """
    Set the matplotlib backend to one of the known backends.

    The argument is case-insensitive. *warn* specifies whether a
    warning should be issued if a backend has already been set up.
    *force* is an **experimental** flag that tells matplotlib to
    attempt to initialize a new backend by reloading the backend
    module.

    .. note::

        This function must be called *before* importing pyplot for
        the first time; or, if you are not using pyplot, it must be called
        before importing matplotlib.backends.  If warn is True, a warning
        is issued if you try and call this after pylab or pyplot have been
        loaded.  In certain black magic use cases, e.g.
        :func:`pyplot.switch_backend`, we are doing the reloading necessary to
        make the backend switch work (in some cases, e.g., pure image
        backends) so one can set warn=False to suppress the warnings.

    To find out which backend is currently set, see
    :func:`matplotlib.get_backend`.

    """
    ...

def get_backend():
    """Return the name of the current backend."""
    ...

def interactive(b):
    """
    Set interactive mode to boolean b.

    If b is True, then draw after every plotting command, e.g., after xlabel
    """
    ...

def is_interactive():
    'Return true if plot mode is interactive'
    ...

def tk_window_focus():
    """Return true if focus maintenance under TkAgg on win32 is on.
     This currently works only for python.exe and IPython.exe.
     Both IDLE and Pythonwin.exe fail badly when tk_window_focus is on."""
    ...

default_test_modules = ['matplotlib.tests', 'matplotlib.sphinxext.tests', 'mpl_toolkits.tests']
def _init_tests():
    ...

def test(verbosity: Optional[Any] = ..., coverage: bool = ..., switch_backend_warn: bool = ..., recursionlimit=..., **kwargs):
    """run the matplotlib test suite"""
    ...

def _replacer(data, key):
    """Either returns data[key] or passes data back. Also
    converts input data to a sequence as needed.
    """
    ...

_DATA_DOC_APPENDIX = """

.. note::
    In addition to the above described arguments, this function can take a
    **data** keyword argument. If such a **data** argument is given, the
    following arguments are replaced by **data[<arg>]**:

    {replaced}
"""
def _add_data_doc(docstring, replace_names, replace_all_args):
    """Add documentation for a *data* field to the given docstring.

    Parameters
    ----------
    docstring : str
        The input docstring.
    replace_names : list of strings or None
        The list of parameter names which arguments should be replaced by
        `data[name]`. If None, all arguments are replaced if they are
        included in `data`.
    replace_all_args : bool
        If True, all arguments in *args get replaced, even if they are not
        in replace_names.

    Returns
    -------
        The augmented docstring.
    """
    ...

def _preprocess_data(replace_names: Optional[Any] = ..., replace_all_args: bool = ..., label_namer: Optional[Any] = ..., positional_parameter_names: Optional[Any] = ...):
    """
    A decorator to add a 'data' kwarg to any a function.  The signature
    of the input function must include the ax argument at the first position ::

       def foo(ax, *args, **kwargs)

    so this is suitable for use with Axes methods.

    Parameters
    ----------
    replace_names : list of strings, optional, default: None
        The list of parameter names which arguments should be replaced by
        `data[name]`. If None, all arguments are replaced if they are
        included in `data`.
    replace_all_args : bool, default: False
        If True, all arguments in *args get replaced, even if they are not
        in replace_names.
    label_namer : string, optional, default: None
        The name of the parameter which argument should be used as label, if
        label is not set. If None, the label keyword argument is not set.
    positional_parameter_names : list of strings or callable, optional
        The full list of positional parameter names (excluding an explicit
        `ax`/'self' argument at the first place and including all possible
        positional parameter in `*args`), in the right order. Can also include
        all other keyword parameter. Only needed if the wrapped function does
        contain `*args` and (replace_names is not None or replace_all_args is
        False). If it is a callable, it will be called with the actual
        tuple of *args and the data and should return a list like
        above.
        NOTE: callables should only be used when the names and order of *args
        can only be determined at runtime. Please use list of names
        when the order and names of *args is clear before runtime!

    .. note:: decorator also converts MappingView input data to list.
    """
    ...

