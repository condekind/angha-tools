"""
This type stub file was generated by pyright.
"""

import six
from typing import Any, Optional

"""
Tick locating and formatting
============================

This module contains classes to support completely configurable tick
locating and formatting. Although the locators know nothing about major
or minor ticks, they are used by the Axis class to support major and
minor tick locating and formatting. Generic tick locators and
formatters are provided, as well as domain specific custom ones.

Default Formatter
-----------------

The default formatter identifies when the x-data being plotted is a
small range on top of a large offset. To reduce the chances that the
ticklabels overlap, the ticks are labeled as deltas from a fixed offset.
For example::

   ax.plot(np.arange(2000, 2010), range(10))

will have tick of 0-9 with an offset of +2e3. If this is not desired
turn off the use of the offset on the default formatter::

   ax.get_xaxis().get_major_formatter().set_useOffset(False)

set the rcParam ``axes.formatter.useoffset=False`` to turn it off
globally, or set a different formatter.

Tick locating
-------------

The Locator class is the base class for all tick locators. The locators
handle autoscaling of the view limits based on the data limits, and the
choosing of tick locations. A useful semi-automatic tick locator is
`MultipleLocator`. It is initialized with a base, e.g., 10, and it picks
axis limits and ticks that are multiples of that base.

The Locator subclasses defined here are

:class:`AutoLocator`
    `MaxNLocator` with simple defaults.  This is the default tick locator for
    most plotting.

:class:`MaxNLocator`
    Finds up to a max number of intervals with ticks at nice locations.

:class:`LinearLocator`
    Space ticks evenly from min to max.

:class:`LogLocator`
    Space ticks logarithmically from min to max.

:class:`MultipleLocator`
    Ticks and range are a multiple of base; either integer or float.

:class:`FixedLocator`
    Tick locations are fixed.

:class:`IndexLocator`
    Locator for index plots (e.g., where ``x = range(len(y))``).

:class:`NullLocator`
    No ticks.

:class:`SymmetricalLogLocator`
    Locator for use with with the symlog norm; works like `LogLocator` for the
    part outside of the threshold and adds 0 if inside the limits.

:class:`LogitLocator`
    Locator for logit scaling.

:class:`OldAutoLocator`
    Choose a `MultipleLocator` and dynamically reassign it for intelligent
    ticking during navigation.

:class:`AutoMinorLocator`
    Locator for minor ticks when the axis is linear and the
    major ticks are uniformly spaced.  Subdivides the major
    tick interval into a specified number of minor intervals,
    defaulting to 4 or 5 depending on the major interval.


There are a number of locators specialized for date locations - see
the `dates` module.

You can define your own locator by deriving from Locator. You must
override the ``__call__`` method, which returns a sequence of locations,
and you will probably want to override the autoscale method to set the
view limits from the data limits.

If you want to override the default locator, use one of the above or a custom
locator and pass it to the x or y axis instance. The relevant methods are::

  ax.xaxis.set_major_locator(xmajor_locator)
  ax.xaxis.set_minor_locator(xminor_locator)
  ax.yaxis.set_major_locator(ymajor_locator)
  ax.yaxis.set_minor_locator(yminor_locator)

The default minor locator is `NullLocator`, i.e., no minor ticks on by default.

Tick formatting
---------------

Tick formatting is controlled by classes derived from Formatter. The formatter
operates on a single tick value and returns a string to the axis.

:class:`NullFormatter`
    No labels on the ticks.

:class:`IndexFormatter`
    Set the strings from a list of labels.

:class:`FixedFormatter`
    Set the strings manually for the labels.

:class:`FuncFormatter`
    User defined function sets the labels.

:class:`StrMethodFormatter`
    Use string `format` method.

:class:`FormatStrFormatter`
    Use an old-style sprintf format string.

:class:`ScalarFormatter`
    Default formatter for scalars: autopick the format string.

:class:`LogFormatter`
    Formatter for log axes.

:class:`LogFormatterExponent`
    Format values for log axis using ``exponent = log_base(value)``.

:class:`LogFormatterMathtext`
    Format values for log axis using ``exponent = log_base(value)``
    using Math text.

:class:`LogFormatterSciNotation`
    Format values for log axis using scientific notation.

:class:`LogitFormatter`
    Probability formatter.

:class:`EngFormatter`
    Format labels in engineering notation

:class:`PercentFormatter`
    Format labels as a percentage

You can derive your own formatter from the Formatter base class by
simply overriding the ``__call__`` method. The formatter class has
access to the axis view and data limits.

To control the major and minor tick label formats, use one of the
following methods::

  ax.xaxis.set_major_formatter(xmajor_formatter)
  ax.xaxis.set_minor_formatter(xminor_formatter)
  ax.yaxis.set_major_formatter(ymajor_formatter)
  ax.yaxis.set_minor_formatter(yminor_formatter)

See :doc:`/gallery/ticks_and_spines/major_minor_demo` for an
example of setting major and minor ticks. See the :mod:`matplotlib.dates`
module for more information and examples of using date locators and formatters.
"""
__all__ = ('TickHelper', 'Formatter', 'FixedFormatter', 'NullFormatter', 'FuncFormatter', 'FormatStrFormatter', 'StrMethodFormatter', 'ScalarFormatter', 'LogFormatter', 'LogFormatterExponent', 'LogFormatterMathtext', 'IndexFormatter', 'LogFormatterSciNotation', 'LogitFormatter', 'EngFormatter', 'PercentFormatter', 'Locator', 'IndexLocator', 'FixedLocator', 'NullLocator', 'LinearLocator', 'LogLocator', 'AutoLocator', 'MultipleLocator', 'MaxNLocator', 'AutoMinorLocator', 'SymmetricalLogLocator', 'LogitLocator')
if six.PY3:
    long = int
def _divmod(x, y):
    ...

def _mathdefault(s):
    ...

class _DummyAxis(object):
    def __init__(self, minpos=...):
        self.dataLim = ...
        self.viewLim = ...
    
    def get_view_interval(self):
        ...
    
    def set_view_interval(self, vmin, vmax):
        ...
    
    def get_minpos(self):
        ...
    
    def get_data_interval(self):
        ...
    
    def set_data_interval(self, vmin, vmax):
        ...
    
    def get_tick_space(self):
        ...
    


class TickHelper(object):
    axis = ...
    def set_axis(self, axis):
        self.axis = ...
    
    def create_dummy_axis(self, **kwargs):
        ...
    
    def set_view_interval(self, vmin, vmax):
        ...
    
    def set_data_interval(self, vmin, vmax):
        ...
    
    def set_bounds(self, vmin, vmax):
        ...
    


class Formatter(TickHelper):
    """
    Create a string based on a tick value and location.
    """
    locs = ...
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the format for tick value *x* at position pos.
        ``pos=None`` indicates an unspecified location.
        """
        ...
    
    def format_data(self, value):
        """
        Returns the full string representation of the value with the
        position unspecified.
        """
        ...
    
    def format_data_short(self, value):
        """
        Return a short string version of the tick value.

        Defaults to the position-independent long value.
        """
        ...
    
    def get_offset(self):
        ...
    
    def set_locs(self, locs):
        self.locs = ...
    
    def fix_minus(self, s):
        """
        Some classes may want to replace a hyphen for minus with the
        proper unicode symbol (U+2212) for typographical correctness.
        The default is to not replace it.

        Note, if you use this method, e.g., in :meth:`format_data` or
        call, you probably don't want to use it for
        :meth:`format_data_short` since the toolbar uses this for
        interactive coord reporting and I doubt we can expect GUIs
        across platforms will handle the unicode correctly.  So for
        now the classes that override :meth:`fix_minus` should have an
        explicit :meth:`format_data_short` method
        """
        ...
    


class IndexFormatter(Formatter):
    """
    Format the position x to the nearest i-th label where i=int(x+0.5)
    """
    def __init__(self, labels):
        self.labels = ...
        self.n = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the format for tick value `x` at position pos.

        The position is ignored and the value is rounded to the nearest
        integer, which is used to look up the label.
        """
        ...
    


class NullFormatter(Formatter):
    """
    Always return the empty string.
    """
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Returns an empty string for all inputs.
        """
        ...
    


class FixedFormatter(Formatter):
    """
    Return fixed strings for tick labels based only on position, not
    value.
    """
    def __init__(self, seq):
        """
        Set the sequence of strings that will be used for labels.
        """
        self.seq = ...
        self.offset_string = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Returns the label that matches the position regardless of the
        value.

        For positions ``pos < len(seq)``, return `seq[i]` regardless of
        `x`. Otherwise return empty string. `seq` is the sequence of
        strings that this object was initialized with.
        """
        ...
    
    def get_offset(self):
        ...
    
    def set_offset_string(self, ofs):
        self.offset_string = ...
    


class FuncFormatter(Formatter):
    """
    Use a user-defined function for formatting.

    The function should take in two inputs (a tick value ``x`` and a
    position ``pos``), and return a string containing the corresponding
    tick label.
    """
    def __init__(self, func):
        self.func = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the value of the user defined function.

        `x` and `pos` are passed through as-is.
        """
        ...
    


class FormatStrFormatter(Formatter):
    """
    Use an old-style ('%' operator) format string to format the tick.

    The format string should have a single variable format (%) in it.
    It will be applied to the value (not the position) of the tick.
    """
    def __init__(self, fmt):
        self.fmt = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the formatted label string.

        Only the value `x` is formatted. The position is ignored.
        """
        ...
    


class StrMethodFormatter(Formatter):
    """
    Use a new-style format string (as used by `str.format()`)
    to format the tick.

    The field used for the value must be labeled `x` and the field used
    for the position must be labeled `pos`.
    """
    def __init__(self, fmt):
        self.fmt = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the formatted label string.

        `x` and `pos` are passed to `str.format` as keyword arguments
        with those exact names.
        """
        ...
    


class OldScalarFormatter(Formatter):
    """
    Tick location is a plain old number.
    """
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the format for tick val `x` based on the width of the
        axis.

        The position `pos` is ignored.
        """
        ...
    
    def pprint_val(self, x, d):
        """
        Formats the value `x` based on the size of the axis range `d`.
        """
        ...
    


class ScalarFormatter(Formatter):
    """
    Format tick values as a number.

    Tick value is interpreted as a plain old number. If
    ``useOffset==True`` and the data range is much smaller than the data
    average, then an offset will be determined such that the tick labels
    are meaningful. Scientific notation is used for ``data < 10^-n`` or
    ``data >= 10^m``, where ``n`` and ``m`` are the power limits set
    using ``set_powerlimits((n,m))``. The defaults for these are
    controlled by the ``axes.formatter.limits`` rc parameter.
    """
    def __init__(self, useOffset: Optional[Any] = ..., useMathText: Optional[Any] = ..., useLocale: Optional[Any] = ...):
        self.orderOfMagnitude = ...
        self.format = ...
    
    def get_useOffset(self):
        ...
    
    def set_useOffset(self, val):
        ...
    
    useOffset = ...
    def get_useLocale(self):
        ...
    
    def set_useLocale(self, val):
        ...
    
    useLocale = ...
    def get_useMathText(self):
        ...
    
    def set_useMathText(self, val):
        ...
    
    useMathText = ...
    def fix_minus(self, s):
        """
        Replace hyphens with a unicode minus.
        """
        ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the format for tick value `x` at position `pos`.
        """
        ...
    
    def set_scientific(self, b):
        """
        Turn scientific notation on or off.

        .. seealso:: Method :meth:`set_powerlimits`
        """
        ...
    
    def set_powerlimits(self, lims):
        """
        Sets size thresholds for scientific notation.

        Parameters
        ----------
        lims : (min_exp, max_exp)
            A tuple containing the powers of 10 that determine the switchover
            threshold. Numbers below ``10**min_exp`` and above ``10**max_exp``
            will be displayed in scientific notation.

            For example, ``formatter.set_powerlimits((-3, 4))`` sets the
            pre-2007 default in which scientific notation is used for
            numbers less than 1e-3 or greater than 1e4.

        .. seealso:: Method :meth:`set_scientific`
        """
        ...
    
    def format_data_short(self, value):
        """
        Return a short formatted string representation of a number.
        """
        ...
    
    def format_data(self, value):
        """
        Return a formatted string representation of a number.
        """
        ...
    
    def get_offset(self):
        """
        Return scientific notation, plus offset.
        """
        ...
    
    def set_locs(self, locs):
        """
        Set the locations of the ticks.
        """
        self.locs = ...
    
    def _compute_offset(self):
        self.offset = ...
    
    def _set_orderOfMagnitude(self, range):
        ...
    
    def _set_format(self, vmin, vmax):
        self.format = ...
    
    def pprint_val(self, x):
        ...
    
    def _formatSciNotation(self, s):
        ...
    


class LogFormatter(Formatter):
    """
    Base class for formatting ticks on a log or symlog scale.

    It may be instantiated directly, or subclassed.

    Parameters
    ----------
    base : float, optional, default: 10.
        Base of the logarithm used in all calculations.

    labelOnlyBase : bool, optional, default: False
        If True, label ticks only at integer powers of base.
        This is normally True for major ticks and False for
        minor ticks.

    minor_thresholds : (subset, all), optional, default: (1, 0.4)
        If labelOnlyBase is False, these two numbers control
        the labeling of ticks that are not at integer powers of
        base; normally these are the minor ticks. The controlling
        parameter is the log of the axis data range.  In the typical
        case where base is 10 it is the number of decades spanned
        by the axis, so we can call it 'numdec'. If ``numdec <= all``,
        all minor ticks will be labeled.  If ``all < numdec <= subset``,
        then only a subset of minor ticks will be labeled, so as to
        avoid crowding. If ``numdec > subset`` then no minor ticks will
        be labeled.

    linthresh : None or float, optional, default: None
        If a symmetric log scale is in use, its ``linthresh``
        parameter must be supplied here.

    Notes
    -----
    The `set_locs` method must be called to enable the subsetting
    logic controlled by the ``minor_thresholds`` parameter.

    In some cases such as the colorbar, there is no distinction between
    major and minor ticks; the tick locations might be set manually,
    or by a locator that puts ticks at integer powers of base and
    at intermediate locations.  For this situation, disable the
    minor_thresholds logic by using ``minor_thresholds=(np.inf, np.inf)``,
    so that all ticks will be labeled.

    To disable labeling of minor ticks when 'labelOnlyBase' is False,
    use ``minor_thresholds=(0, 0)``.  This is the default for the
    "classic" style.

    Examples
    --------
    To label a subset of minor ticks when the view limits span up
    to 2 decades, and all of the ticks when zoomed in to 0.5 decades
    or less, use ``minor_thresholds=(2, 0.5)``.

    To label all minor ticks when the view limits span up to 1.5
    decades, use ``minor_thresholds=(1.5, 1.5)``.

    """
    def __init__(self, base=..., labelOnlyBase: bool = ..., minor_thresholds: Optional[Any] = ..., linthresh: Optional[Any] = ...):
        self.labelOnlyBase = ...
        self.minor_thresholds = ...
    
    def base(self, base):
        """
        Change the *base* for labeling.

        .. warning::
           Should always match the base used for :class:`LogLocator`

        """
        ...
    
    def label_minor(self, labelOnlyBase):
        """
        Switch minor tick labeling on or off.

        Parameters
        ----------
        labelOnlyBase : bool
            If True, label ticks only at integer powers of base.

        """
        self.labelOnlyBase = ...
    
    def set_locs(self, locs: Optional[Any] = ...):
        """
        Use axis view limits to control which ticks are labeled.

        The *locs* parameter is ignored in the present algorithm.

        """
        ...
    
    def _num_to_string(self, x, vmin, vmax):
        ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the format for tick val *x*.
        """
        ...
    
    def format_data(self, value):
        self.labelOnlyBase = ...
        self.labelOnlyBase = ...
    
    def format_data_short(self, value):
        """
        Return a short formatted string representation of a number.
        """
        ...
    
    def pprint_val(self, x, d):
        ...
    


class LogFormatterExponent(LogFormatter):
    """
    Format values for log axis using ``exponent = log_base(value)``.
    """
    def _num_to_string(self, x, vmin, vmax):
        ...
    


class LogFormatterMathtext(LogFormatter):
    """
    Format values for log axis using ``exponent = log_base(value)``.
    """
    def _non_decade_format(self, sign_string, base, fx, usetex):
        'Return string for non-decade locations'
        ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Return the format for tick value *x*.

        The position *pos* is ignored.
        """
        ...
    


class LogFormatterSciNotation(LogFormatterMathtext):
    """
    Format values following scientific notation in a logarithmic axis.
    """
    def _non_decade_format(self, sign_string, base, fx, usetex):
        'Return string for non-decade locations'
        ...
    


class LogitFormatter(Formatter):
    """
    Probability formatter (using Math text).
    """
    def __call__(self, x, pos: Optional[Any] = ...):
        ...
    
    def format_data_short(self, value):
        'return a short formatted string representation of a number'
        ...
    


class EngFormatter(Formatter):
    """
    Formats axis values using engineering prefixes to represent powers
    of 1000, plus a specified unit, e.g., 10 MHz instead of 1e7.
    """
    ENG_PREFIXES = ...
    def __init__(self, unit=..., places: Optional[Any] = ..., sep=...):
        """
        Parameters
        ----------
        unit : str (default: "")
            Unit symbol to use, suitable for use with single-letter
            representations of powers of 1000. For example, 'Hz' or 'm'.

        places : int (default: None)
            Precision with which to display the number, specified in
            digits after the decimal point (there will be between one
            and three digits before the decimal point). If it is None,
            the formatting falls back to the floating point format '%g',
            which displays up to 6 *significant* digits, i.e. the equivalent
            value for *places* varies between 0 and 5 (inclusive).

        sep : str (default: " ")
            Separator used between the value and the prefix/unit. For
            example, one get '3.14 mV' if ``sep`` is " " (default) and
            '3.14mV' if ``sep`` is "". Besides the default behavior, some
            other useful options may be:

            * ``sep=""`` to append directly the prefix/unit to the value;
            * ``sep="\\N{THIN SPACE}"`` (``U+2009``);
            * ``sep="\\N{NARROW NO-BREAK SPACE}"`` (``U+202F``);
            * ``sep="\\N{NO-BREAK SPACE}"`` (``U+00A0``).
        """
        self.unit = ...
        self.places = ...
        self.sep = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        ...
    
    def format_eng(self, num):
        """
        Formats a number in engineering notation, appending a letter
        representing the power of 1000 of the original number.
        Some examples:

        >>> format_eng(0)       # for self.places = 0
        '0'

        >>> format_eng(1000000) # for self.places = 1
        '1.0 M'

        >>> format_eng("-1e-6") # for self.places = 2
        u'-1.00 \N{GREEK SMALL LETTER MU}'

        `num` may be a numeric value or a string that can be converted
        to a numeric value with ``float(num)``.
        """
        ...
    


class PercentFormatter(Formatter):
    """
    Format numbers as a percentage.

    Parameters
    ----------
    xmax : float
        Determines how the number is converted into a percentage.
        *xmax* is the data value that corresponds to 100%.
        Percentages are computed as ``x / xmax * 100``. So if the data is
        already scaled to be percentages, *xmax* will be 100. Another common
        situation is where `xmax` is 1.0.

    decimals : None or int
        The number of decimal places to place after the point.
        If *None* (the default), the number will be computed automatically.

    symbol : string or None
        A string that will be appended to the label. It may be
        *None* or empty to indicate that no symbol should be used. LaTeX
        special characters are escaped in *symbol* whenever latex mode is
        enabled, unless *is_latex* is *True*.

    is_latex : bool
        If *False*, reserved LaTeX characters in *symbol* will be escaped.
    """
    def __init__(self, xmax=..., decimals: Optional[Any] = ..., symbol=..., is_latex: bool = ...):
        self.xmax = ...
        self.decimals = ...
    
    def __call__(self, x, pos: Optional[Any] = ...):
        """
        Formats the tick as a percentage with the appropriate scaling.
        """
        ...
    
    def format_pct(self, x, display_range):
        """
        Formats the number as a percentage number with the correct
        number of decimals and adds the percent symbol, if any.

        If `self.decimals` is `None`, the number of digits after the
        decimal point is set based on the `display_range` of the axis
        as follows:

        +---------------+----------+------------------------+
        | display_range | decimals |          sample        |
        +---------------+----------+------------------------+
        | >50           |     0    | ``x = 34.5`` => 35%    |
        +---------------+----------+------------------------+
        | >5            |     1    | ``x = 34.5`` => 34.5%  |
        +---------------+----------+------------------------+
        | >0.5          |     2    | ``x = 34.5`` => 34.50% |
        +---------------+----------+------------------------+
        |      ...      |    ...   |          ...           |
        +---------------+----------+------------------------+

        This method will not be very good for tiny axis ranges or
        extremely large ones. It assumes that the values on the chart
        are percentages displayed on a reasonable scale.
        """
        ...
    
    def convert_to_pct(self, x):
        ...
    
    @property
    def symbol(self):
        """
        The configured percent symbol as a string.

        If LaTeX is enabled via :rc:`text.usetex`, the special characters
        ``{'#', '$', '%', '&', '~', '_', '^', '\\', '{', '}'}`` are
        automatically escaped in the string.
        """
        ...
    
    @symbol.setter
    def symbol(self, symbol):
        ...
    


class Locator(TickHelper):
    """
    Determine the tick locations;

    Note, you should not use the same locator between different
    :class:`~matplotlib.axis.Axis` because the locator stores references to
    the Axis data and view limits
    """
    MAXTICKS = ...
    def tick_values(self, vmin, vmax):
        """
        Return the values of the located ticks given **vmin** and **vmax**.

        .. note::
            To get tick locations with the vmin and vmax values defined
            automatically for the associated :attr:`axis` simply call
            the Locator instance::

                >>> print((type(loc)))
                <type 'Locator'>
                >>> print((loc()))
                [1, 2, 3, 4]

        """
        ...
    
    def set_params(self, **kwargs):
        """
        Do nothing, and rase a warning. Any locator class not supporting the
        set_params() function will call this.
        """
        ...
    
    def __call__(self):
        """Return the locations of the ticks"""
        ...
    
    def raise_if_exceeds(self, locs):
        """raise a RuntimeError if Locator attempts to create more than
           MAXTICKS locs"""
        ...
    
    def view_limits(self, vmin, vmax):
        """
        select a scale for the range from vmin to vmax

        Normally this method is overridden by subclasses to
        change locator behaviour.
        """
        ...
    
    def autoscale(self):
        """autoscale the view limits"""
        ...
    
    def pan(self, numsteps):
        """Pan numticks (can be positive or negative)"""
        ...
    
    def zoom(self, direction):
        "Zoom in/out on axis; if direction is >0 zoom in, else zoom out"
        ...
    
    def refresh(self):
        """refresh internal information based on current lim"""
        ...
    


class IndexLocator(Locator):
    """
    Place a tick on every multiple of some base number of points
    plotted, e.g., on every 5th point.  It is assumed that you are doing
    index plotting; i.e., the axis is 0, len(data).  This is mainly
    useful for x ticks.
    """
    def __init__(self, base, offset):
        'place ticks on the i-th data points where (i-offset)%base==0'
        self.offset = ...
    
    def set_params(self, base: Optional[Any] = ..., offset: Optional[Any] = ...):
        """Set parameters within this locator"""
        ...
    
    def __call__(self):
        """Return the locations of the ticks"""
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    


class FixedLocator(Locator):
    """
    Tick locations are fixed.  If nbins is not None,
    the array of possible positions will be subsampled to
    keep the number of ticks <= nbins +1.
    The subsampling will be done so as to include the smallest
    absolute value; for example, if zero is included in the
    array of possibilities, then it is guaranteed to be one of
    the chosen ticks.
    """
    def __init__(self, locs, nbins: Optional[Any] = ...):
        self.locs = ...
        self.nbins = ...
    
    def set_params(self, nbins: Optional[Any] = ...):
        """Set parameters within this locator."""
        ...
    
    def __call__(self):
        ...
    
    def tick_values(self, vmin, vmax):
        """"
        Return the locations of the ticks.

        .. note::

            Because the values are fixed, vmin and vmax are not used in this
            method.

        """
        ...
    


class NullLocator(Locator):
    """
    No ticks
    """
    def __call__(self):
        ...
    
    def tick_values(self, vmin, vmax):
        """"
        Return the locations of the ticks.

        .. note::

            Because the values are Null, vmin and vmax are not used in this
            method.
        """
        ...
    


class LinearLocator(Locator):
    """
    Determine the tick locations

    The first time this function is called it will try to set the
    number of ticks to make a nice tick partitioning.  Thereafter the
    number of ticks will be fixed so that interactive navigation will
    be nice

    """
    def __init__(self, numticks: Optional[Any] = ..., presets: Optional[Any] = ...):
        """
        Use presets to set locs based on lom.  A dict mapping vmin, vmax->locs
        """
        self.numticks = ...
    
    def set_params(self, numticks: Optional[Any] = ..., presets: Optional[Any] = ...):
        """Set parameters within this locator."""
        ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def _set_numticks(self):
        self.numticks = ...
    
    def view_limits(self, vmin, vmax):
        'Try to choose the view limits intelligently'
        ...
    


def closeto(x, y):
    ...

class Base(object):
    'this solution has some hacks to deal with floating point inaccuracies'
    def __init__(self, base):
        ...
    
    def lt(self, x):
        'return the largest multiple of base < x'
        ...
    
    def le(self, x):
        'return the largest multiple of base <= x'
        ...
    
    def gt(self, x):
        'return the smallest multiple of base > x'
        ...
    
    def ge(self, x):
        'return the smallest multiple of base >= x'
        ...
    
    def get_base(self):
        ...
    


class MultipleLocator(Locator):
    """
    Set a tick on every integer that is multiple of base in the
    view interval
    """
    def __init__(self, base=...):
        ...
    
    def set_params(self, base):
        """Set parameters within this locator."""
        ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def view_limits(self, dmin, dmax):
        """
        Set the view limits to the nearest multiples of base that
        contain the data
        """
        ...
    


def scale_range(vmin, vmax, n=..., threshold=...):
    ...

class MaxNLocator(Locator):
    """
    Select no more than N intervals at nice locations.
    """
    default_params = ...
    def __init__(self, *args, **kwargs):
        """
        Keyword args:

        *nbins*
            Maximum number of intervals; one less than max number of
            ticks.  If the string `'auto'`, the number of bins will be
            automatically determined based on the length of the axis.

        *steps*
            Sequence of nice numbers starting with 1 and ending with 10;
            e.g., [1, 2, 4, 5, 10], where the values are acceptable
            tick multiples.  i.e. for the example, 20, 40, 60 would be
            an acceptable set of ticks, as would 0.4, 0.6, 0.8, because
            they are multiples of 2.  However, 30, 60, 90 would not
            be allowed because 3 does not appear in the list of steps.

        *integer*
            If True, ticks will take only integer values, provided
            at least `min_n_ticks` integers are found within the
            view limits.

        *symmetric*
            If True, autoscaling will result in a range symmetric
            about zero.

        *prune*
            ['lower' | 'upper' | 'both' | None]
            Remove edge ticks -- useful for stacked or ganged plots where
            the upper tick of one axes overlaps with the lower tick of the
            axes above it, primarily when :rc:`axes.autolimit_mode` is
            ``'round_numbers'``.  If ``prune=='lower'``, the smallest tick will
            be removed.  If ``prune == 'upper'``, the largest tick will be
            removed.  If ``prune == 'both'``, the largest and smallest ticks
            will be removed.  If ``prune == None``, no ticks will be removed.

        *min_n_ticks*
            Relax `nbins` and `integer` constraints if necessary to
            obtain this minimum number of ticks.

        """
        ...
    
    @staticmethod
    def _validate_steps(steps):
        ...
    
    @staticmethod
    def _staircase(steps):
        ...
    
    def set_params(self, **kwargs):
        """Set parameters within this locator."""
        ...
    
    def _raw_ticks(self, vmin, vmax):
        ...
    
    def __call__(self):
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def view_limits(self, dmin, dmax):
        ...
    


def decade_down(x, base=...):
    'floor x to the nearest lower decade'
    ...

def decade_up(x, base=...):
    'ceil x to the nearest higher decade'
    ...

def nearest_long(x):
    ...

def is_decade(x, base=...):
    ...

def is_close_to_int(x):
    ...

class LogLocator(Locator):
    """
    Determine the tick locations for log axes
    """
    def __init__(self, base=..., subs=..., numdecs=..., numticks: Optional[Any] = ...):
        """
        Place ticks on the locations : subs[j] * base**i

        Parameters
        ----------
        subs : None, string, or sequence of float, optional, default (1.0,)
            Gives the multiples of integer powers of the base at which
            to place ticks.  The default places ticks only at
            integer powers of the base.
            The permitted string values are ``'auto'`` and ``'all'``,
            both of which use an algorithm based on the axis view
            limits to determine whether and how to put ticks between
            integer powers of the base.  With ``'auto'``, ticks are
            placed only between integer powers; with ``'all'``, the
            integer powers are included.  A value of None is
            equivalent to ``'auto'``.

        """
        self.numdecs = ...
        self.numticks = ...
    
    def set_params(self, base: Optional[Any] = ..., subs: Optional[Any] = ..., numdecs: Optional[Any] = ..., numticks: Optional[Any] = ...):
        """Set parameters within this locator."""
        ...
    
    def base(self, base):
        """
        set the base of the log scaling (major tick every base**i, i integer)
        """
        ...
    
    def subs(self, subs):
        """
        set the minor ticks for the log scaling every base**i*subs[j]
        """
        ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def view_limits(self, vmin, vmax):
        'Try to choose the view limits intelligently'
        ...
    
    def nonsingular(self, vmin, vmax):
        ...
    


class SymmetricalLogLocator(Locator):
    """
    Determine the tick locations for symmetric log axes
    """
    def __init__(self, transform: Optional[Any] = ..., subs: Optional[Any] = ..., linthresh: Optional[Any] = ..., base: Optional[Any] = ...):
        """
        place ticks on the location= base**i*subs[j]
        """
        self.numticks = ...
    
    def set_params(self, subs: Optional[Any] = ..., numticks: Optional[Any] = ...):
        """Set parameters within this locator."""
        ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def view_limits(self, vmin, vmax):
        'Try to choose the view limits intelligently'
        ...
    


class LogitLocator(Locator):
    """
    Determine the tick locations for logit axes
    """
    def __init__(self, minor: bool = ...):
        """
        place ticks on the logit locations
        """
        self.minor = ...
    
    def set_params(self, minor: Optional[Any] = ...):
        """Set parameters within this locator."""
        ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def nonsingular(self, vmin, vmax):
        ...
    


class AutoLocator(MaxNLocator):
    """
    Dynamically find major tick positions. This is actually a subclass
    of `~matplotlib.ticker.MaxNLocator`, with parameters *nbins = 'auto'*
    and *steps = [1, 2, 2.5, 5, 10]*.
    """
    def __init__(self):
        """
        To know the values of the non-public parameters, please have a
        look to the defaults of `~matplotlib.ticker.MaxNLocator`.
        """
        ...
    


class AutoMinorLocator(Locator):
    """
    Dynamically find minor tick positions based on the positions of
    major ticks. The scale must be linear with major ticks evenly spaced.
    """
    def __init__(self, n: Optional[Any] = ...):
        """
        *n* is the number of subdivisions of the interval between
        major ticks; e.g., n=2 will place a single minor tick midway
        between major ticks.

        If *n* is omitted or None, it will be set to 5 or 4.
        """
        self.ndivs = ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    


class OldAutoLocator(Locator):
    """
    On autoscale this class picks the best MultipleLocator to set the
    view limits and the tick locs.

    """
    def __init__(self):
        ...
    
    def __call__(self):
        'Return the locations of the ticks'
        ...
    
    def tick_values(self, vmin, vmax):
        ...
    
    def refresh(self):
        'refresh internal information based on current lim'
        ...
    
    def view_limits(self, vmin, vmax):
        'Try to choose the view limits intelligently'
        ...
    
    def get_locator(self, d):
        'pick the best locator based on a distance'
        ...
    


