"""
This type stub file was generated by pyright.
"""

import logging
from matplotlib.backend_bases import FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase, _Backend
from typing import Any, Optional

"""
A PostScript backend, which can produce both PostScript .ps and .eps
"""
_log = logging.getLogger(__name__)
backend_version = 'Level II'
debugPS = 0
class PsBackendHelper(object):
    def __init__(self):
        ...
    
    @property
    def gs_exe(self):
        """
        executable name of ghostscript.
        """
        ...
    
    @property
    def gs_version(self):
        """
        version of ghostscript.
        """
        ...
    
    @property
    def supports_ps2write(self):
        """
        True if the installed ghostscript supports ps2write device.
        """
        ...
    


ps_backend_helper = PsBackendHelper()
papersize = { 'letter': (8.5, 11),'legal': (8.5, 14),'ledger': (11, 17),'a0': (33.11, 46.81),'a1': (23.39, 33.11),'a2': (16.54, 23.39),'a3': (11.69, 16.54),'a4': (8.27, 11.69),'a5': (5.83, 8.27),'a6': (4.13, 5.83),'a7': (2.91, 4.13),'a8': (2.07, 2.91),'a9': (1.457, 2.05),'a10': (1.02, 1.457),'b0': (40.55, 57.32),'b1': (28.66, 40.55),'b2': (20.27, 28.66),'b3': (14.33, 20.27),'b4': (10.11, 14.33),'b5': (7.16, 10.11),'b6': (5.04, 7.16),'b7': (3.58, 5.04),'b8': (2.51, 3.58),'b9': (1.76, 2.51),'b10': (1.26, 1.76) }
def _get_papertype(w, h):
    ...

def _num_to_str(val):
    ...

def _nums_to_str(*args):
    ...

def quote_ps_string(s):
    "Quote dangerous characters of S for use in a PostScript string constant."
    ...

def _move_path_to_path_or_stream(src, dst):
    """Move the contents of file at *src* to path-or-filelike *dst*.

    If *dst* is a path, the metadata of *src* are *not* copied.
    """
    ...

class RendererPS(RendererBase):
    """
    The renderer handles all the drawing primitives using a graphics
    context instance that controls the colors/styles.
    """
    afmfontd = ...
    def __init__(self, width, height, pswriter, imagedpi=...):
        """
        Although postscript itself is dpi independent, we need to
        imform the image code about a requested dpi to generate high
        res images and them scale them before embeddin them
        """
        self.width = ...
        self.height = ...
        self.imagedpi = ...
        self.color = ...
        self.linewidth = ...
        self.linejoin = ...
        self.linecap = ...
        self.linedash = ...
        self.fontname = ...
        self.fontsize = ...
        self.image_magnification = ...
        self.used_characters = ...
        self.mathtext_parser = ...
    
    def track_characters(self, font, s):
        """Keeps track of which characters are required from
        each font."""
        ...
    
    def merge_used_characters(self, other):
        ...
    
    def set_color(self, r, g, b, store=...):
        ...
    
    def set_linewidth(self, linewidth, store=...):
        ...
    
    def set_linejoin(self, linejoin, store=...):
        ...
    
    def set_linecap(self, linecap, store=...):
        ...
    
    def set_linedash(self, offset, seq, store=...):
        ...
    
    def set_font(self, fontname, fontsize, store=...):
        ...
    
    def create_hatch(self, hatch):
        ...
    
    def get_canvas_width_height(self):
        'return the canvas width and height in display coords'
        ...
    
    def get_text_width_height_descent(self, s, prop, ismath):
        """
        get the width and height in display coords of the string s
        with FontPropertry prop

        """
        ...
    
    def flipy(self):
        'return true if small y numbers are top for renderer'
        ...
    
    def _get_font_afm(self, prop):
        ...
    
    def _get_font_ttf(self, prop):
        ...
    
    def _rgb(self, rgba):
        ...
    
    def _hex_lines(self, s, chars_per_line=...):
        ...
    
    def get_image_magnification(self):
        """
        Get the factor by which to magnify images passed to draw_image.
        Allows a backend to have images at a different resolution to other
        artists.
        """
        ...
    
    def option_scale_image(self):
        """
        ps backend support arbitrary scaling of image.
        """
        ...
    
    def option_image_nocomposite(self):
        """
        return whether to generate a composite image from multiple images on
        a set of axes
        """
        ...
    
    def _get_image_h_w_bits_command(self, im):
        ...
    
    def draw_image(self, gc, x, y, im, transform: Optional[Any] = ...):
        """
        Draw the Image instance into the current axes; x is the
        distance in pixels from the left hand side of the canvas and y
        is the distance from bottom
        """
        ...
    
    def _convert_path(self, path, transform, clip: bool = ..., simplify: Optional[Any] = ...):
        ...
    
    def _get_clip_path(self, clippath, clippath_transform):
        ...
    
    def draw_path(self, gc, path, transform, rgbFace: Optional[Any] = ...):
        """
        Draws a Path instance using the given affine transform.
        """
        ...
    
    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace: Optional[Any] = ...):
        """
        Draw the markers defined by path at each of the positions in x
        and y.  path coordinates are points, x and y coords will be
        transformed by the transform
        """
        ...
    
    def draw_path_collection(self, gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position):
        ...
    
    def draw_tex(self, gc, x, y, s, prop, angle, ismath=..., mtext: Optional[Any] = ...):
        """
        draw a Text instance
        """
        ...
    
    def draw_text(self, gc, x, y, s, prop, angle, ismath: bool = ..., mtext: Optional[Any] = ...):
        """
        Draw a Text instance.
        """
        ...
    
    def new_gc(self):
        ...
    
    def draw_mathtext(self, gc, x, y, s, prop, angle):
        """
        Draw the math text using matplotlib.mathtext
        """
        ...
    
    def draw_gouraud_triangle(self, gc, points, colors, trans):
        ...
    
    def draw_gouraud_triangles(self, gc, points, colors, trans):
        ...
    
    def _draw_ps(self, ps, gc, rgbFace, fill: bool = ..., stroke: bool = ..., command: Optional[Any] = ...):
        """
        Emit the PostScript sniplet 'ps' with all the attributes from 'gc'
        applied.  'ps' must consist of PostScript commands to construct a path.

        The fill and/or stroke kwargs can be set to False if the
        'ps' string already includes filling and/or stroking, in
        which case _draw_ps is just supplying properties and
        clipping.
        """
        ...
    


class GraphicsContextPS(GraphicsContextBase):
    def get_capstyle(self):
        ...
    
    def get_joinstyle(self):
        ...
    
    def shouldstroke(self):
        ...
    


class FigureCanvasPS(FigureCanvasBase):
    _renderer_class = ...
    fixed_dpi = ...
    def draw(self):
        ...
    
    filetypes = ...
    def get_default_filetype(self):
        ...
    
    def print_ps(self, outfile, *args, **kwargs):
        ...
    
    def print_eps(self, outfile, *args, **kwargs):
        ...
    
    def _print_ps(self, outfile, format, *args, **kwargs):
        ...
    
    def _print_figure(self, outfile, format, dpi=..., facecolor=..., edgecolor=..., orientation=..., isLandscape: bool = ..., papertype: Optional[Any] = ..., metadata: Optional[Any] = ..., **kwargs):
        """
        Render the figure to hardcopy.  Set the figure patch face and
        edge colors.  This is useful because some of the GUIs have a
        gray figure face color background and you'll probably want to
        override this on hardcopy

        If outfile is a string, it is interpreted as a file name.
        If the extension matches .ep* write encapsulated postscript,
        otherwise write a stand-alone PostScript file.

        If outfile is a file object, a stand-alone PostScript file is
        written into this file object.

        metadata must be a dictionary. Currently, only the value for
        the key 'Creator' is used.
        """
        ...
    
    def _print_figure_tex(self, outfile, format, dpi, facecolor, edgecolor, orientation, isLandscape, papertype, metadata: Optional[Any] = ..., **kwargs):
        """
        If text.usetex is True in rc, a temporary pair of tex/eps files
        are created to allow tex to manage the text layout via the PSFrags
        package. These files are processed to yield the final ps or eps file.

        metadata must be a dictionary. Currently, only the value for
        the key 'Creator' is used.
        """
        ...
    


def convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble, paperWidth, paperHeight, orientation):
    """
    When we want to use the LaTeX backend with postscript, we write PSFrag tags
    to a temporary postscript file, each one marking a position for LaTeX to
    render some text. convert_psfrags generates a LaTeX document containing the
    commands to convert those tags to text. LaTeX/dvips produces the postscript
    file that includes the actual text.
    """
    ...

def gs_distill(tmpfile, eps: bool = ..., ptype=..., bbox: Optional[Any] = ..., rotated: bool = ...):
    """
    Use ghostscript's pswrite or epswrite device to distill a file.
    This yields smaller files without illegal encapsulated postscript
    operators. The output is low-level, converting text to outlines.
    """
    ...

def xpdf_distill(tmpfile, eps: bool = ..., ptype=..., bbox: Optional[Any] = ..., rotated: bool = ...):
    """
    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.
    This yields smaller files without illegal encapsulated postscript
    operators. This distiller is preferred, generating high-level postscript
    output that treats text as text.
    """
    ...

def get_bbox_header(lbrt, rotated: bool = ...):
    """
    return a postscript header stringfor the given bbox lbrt=(l, b, r, t).
    Optionally, return rotate command.
    """
    ...

def get_bbox(tmpfile, bbox):
    """
    Use ghostscript's bbox device to find the center of the bounding box.
    Return an appropriately sized bbox centered around that point. A bit of a
    hack.
    """
    ...

def pstoeps(tmpfile, bbox: Optional[Any] = ..., rotated: bool = ...):
    """
    Convert the postscript to encapsulated postscript.  The bbox of
    the eps file will be replaced with the given *bbox* argument. If
    None, original bbox will be used.
    """
    ...

class FigureManagerPS(FigureManagerBase):
    ...


psDefs = ["/m { moveto } bind def", "/l { lineto } bind def", "/r { rlineto } bind def", "/c { curveto } bind def", "/cl { closepath } bind def", """/box {
      m
      1 index 0 r
      0 exch r
      neg 0 r
      cl
    } bind def""", """/clipbox {
      box
      clip
      newpath
    } bind def"""]
@_Backend.export
class _BackendPS(_Backend):
    FigureCanvas = ...
    FigureManager = ...


