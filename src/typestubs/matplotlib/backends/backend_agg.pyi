"""
This type stub file was generated by pyright.
"""

from matplotlib import cbook
from matplotlib.backend_bases import FigureCanvasBase, RendererBase, _Backend
from typing import Any, Optional

"""
An agg http://antigrain.com/ backend

Features that are implemented

 * capstyles and join styles
 * dashes
 * linewidth
 * lines, rectangles, ellipses
 * clipping to a rectangle
 * output to RGBA and PNG, optionally JPEG and TIFF
 * alpha blending
 * DPI scaling properly - everything scales properly (dashes, linewidths, etc)
 * draw polygon
 * freetype2 w/ ft2font

TODO:

  * integrate screen dpi w/ ppi and text

"""
backend_version = 'v2.2'
def get_hinting_flag():
    ...

class RendererAgg(RendererBase):
    """
    The renderer handles all the drawing primitives using a graphics
    context instance that controls the colors/styles
    """
    @property
    @cbook.deprecated("2.2")
    def debug(self):
        ...
    
    lock = ...
    def __init__(self, width, height, dpi):
        self.dpi = ...
        self.width = ...
        self.height = ...
        self.mathtext_parser = ...
        self.bbox = ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        ...
    
    def _get_hinting_flag(self):
        ...
    
    def draw_markers(self, *kl, **kw):
        ...
    
    def draw_path_collection(self, *kl, **kw):
        ...
    
    def _update_methods(self):
        self.draw_quad_mesh = ...
        self.draw_gouraud_triangle = ...
        self.draw_gouraud_triangles = ...
        self.draw_image = ...
        self.copy_from_bbox = ...
        self.get_content_extents = ...
    
    def tostring_rgba_minimized(self):
        ...
    
    def draw_path(self, gc, path, transform, rgbFace: Optional[Any] = ...):
        """
        Draw the path
        """
        ...
    
    def draw_mathtext(self, gc, x, y, s, prop, angle):
        """
        Draw the math text using matplotlib.mathtext
        """
        ...
    
    def draw_text(self, gc, x, y, s, prop, angle, ismath: bool = ..., mtext: Optional[Any] = ...):
        """
        Render the text
        """
        ...
    
    def get_text_width_height_descent(self, s, prop, ismath):
        """
        Get the width, height, and descent (offset from the bottom
        to the baseline), in display coords, of the string *s* with
        :class:`~matplotlib.font_manager.FontProperties` *prop*
        """
        ...
    
    def draw_tex(self, gc, x, y, s, prop, angle, ismath=..., mtext: Optional[Any] = ...):
        ...
    
    def get_canvas_width_height(self):
        'return the canvas width and height in display coords'
        ...
    
    def _get_agg_font(self, prop):
        """
        Get the font for text instance t, cacheing for efficiency
        """
        ...
    
    def points_to_pixels(self, points):
        """
        convert point measures to pixes using dpi and the pixels per
        inch of the display
        """
        ...
    
    def tostring_rgb(self):
        ...
    
    def tostring_argb(self):
        ...
    
    def buffer_rgba(self):
        ...
    
    def clear(self):
        ...
    
    def option_image_nocomposite(self):
        ...
    
    def option_scale_image(self):
        """
        agg backend doesn't support arbitrary scaling of image.
        """
        ...
    
    def restore_region(self, region, bbox: Optional[Any] = ..., xy: Optional[Any] = ...):
        """
        Restore the saved region. If bbox (instance of BboxBase, or
        its extents) is given, only the region specified by the bbox
        will be restored. *xy* (a tuple of two floasts) optionally
        specifies the new position (the LLC of the original region,
        not the LLC of the bbox) where the region will be restored.

        >>> region = renderer.copy_from_bbox()
        >>> x1, y1, x2, y2 = region.get_extents()
        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),
        ...                         xy=(x1-dx, y1))

        """
        ...
    
    def start_filter(self):
        """
        Start filtering. It simply create a new canvas (the old one is saved).
        """
        ...
    
    def stop_filter(self, post_processing):
        """
        Save the plot in the current canvas as a image and apply
        the *post_processing* function.

           def post_processing(image, dpi):
             # ny, nx, depth = image.shape
             # image (numpy array) has RGBA channels and has a depth of 4.
             ...
             # create a new_image (numpy array of 4 channels, size can be
             # different). The resulting image may have offsets from
             # lower-left corner of the original image
             return new_image, offset_x, offset_y

        The saved renderer is restored and the returned image from
        post_processing is plotted (using draw_image) on it.
        """
        ...
    


class FigureCanvasAgg(FigureCanvasBase):
    """
    The canvas the figure renders into.  Calls the draw and print fig
    methods, creates the renderers, etc...

    Attributes
    ----------
    figure : `matplotlib.figure.Figure`
        A high-level Figure instance

    """
    def copy_from_bbox(self, bbox):
        ...
    
    def restore_region(self, region, bbox: Optional[Any] = ..., xy: Optional[Any] = ...):
        ...
    
    def draw(self):
        """
        Draw the figure using the renderer
        """
        self.renderer = ...
    
    def get_renderer(self, cleared: bool = ...):
        ...
    
    def tostring_rgb(self):
        '''Get the image as an RGB byte string

        `draw` must be called at least once before this function will work and
        to update the renderer for any subsequent changes to the Figure.

        Returns
        -------
        bytes
        '''
        ...
    
    def tostring_argb(self):
        '''Get the image as an ARGB byte string

        `draw` must be called at least once before this function will work and
        to update the renderer for any subsequent changes to the Figure.

        Returns
        -------
        bytes

        '''
        ...
    
    def buffer_rgba(self):
        '''Get the image as an RGBA byte string

        `draw` must be called at least once before this function will work and
        to update the renderer for any subsequent changes to the Figure.

        Returns
        -------
        bytes
        '''
        ...
    
    def print_raw(self, filename_or_obj, *args, **kwargs):
        ...
    
    print_rgba = ...
    def print_png(self, filename_or_obj, *args, **kwargs):
        ...
    
    def print_to_buffer(self):
        ...
    
    if _has_pil:
        def print_jpg(self, filename_or_obj, *args, **kwargs):
            """
            Other Parameters
            ----------------
            quality : int
                The image quality, on a scale from 1 (worst) to
                95 (best). The default is 95, if not given in the
                matplotlibrc file in the savefig.jpeg_quality parameter.
                Values above 95 should be avoided; 100 completely
                disables the JPEG quantization stage.

            optimize : bool
                If present, indicates that the encoder should
                make an extra pass over the image in order to select
                optimal encoder settings.

            progressive : bool
                If present, indicates that this image
                should be stored as a progressive JPEG file.
            """
            ...
        
        print_jpeg = ...
        def print_tif(self, filename_or_obj, *args, **kwargs):
            ...
        
        print_tiff = ...


@_Backend.export
class _BackendAgg(_Backend):
    FigureCanvas = ...
    FigureManager = ...


