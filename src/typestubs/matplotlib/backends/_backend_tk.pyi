"""
This type stub file was generated by pyright.
"""

import logging
from six.moves import tkinter as Tk
from matplotlib import backend_tools, cbook
from matplotlib.backend_bases import FigureCanvasBase, FigureManagerBase, NavigationToolbar2, StatusbarBase, TimerBase, ToolContainerBase, _Backend, cursors
from typing import Any, Optional

_log = logging.getLogger(__name__)
backend_version = Tk.TkVersion
PIXELS_PER_INCH = 75
cursord = { cursors.MOVE: "fleur",cursors.HAND: "hand2",cursors.POINTER: "arrow",cursors.SELECT_REGION: "tcross",cursors.WAIT: "watch" }
def raise_msg_to_str(msg):
    """msg is a return arg from a raise.  Join with new lines"""
    ...

def error_msg_tkpaint(msg, parent: Optional[Any] = ...):
    ...

class TimerTk(TimerBase):
    '''
    Subclass of :class:`backend_bases.TimerBase` that uses Tk's timer events.

    Attributes
    ----------
    interval : int
        The time between timer events in milliseconds. Default is 1000 ms.
    single_shot : bool
        Boolean flag indicating whether this timer should operate as single
        shot (run once and then stop). Defaults to False.
    callbacks : list
        Stores list of (func, args) tuples that will be called upon timer
        events. This list can be manipulated directly, or the functions
        `add_callback` and `remove_callback` can be used.

    '''
    def __init__(self, parent, *args, **kwargs):
        self.parent = ...
    
    def _timer_start(self):
        ...
    
    def _timer_stop(self):
        ...
    
    def _on_timer(self):
        ...
    


class FigureCanvasTk(FigureCanvasBase):
    keyvald = ...
    _keycode_lookup = ...
    def __init__(self, figure, master: Optional[Any] = ..., resize_callback: Optional[Any] = ...):
        ...
    
    def resize(self, event):
        ...
    
    def _update_pointer_position(self, guiEvent: Optional[Any] = ...):
        """
        Figure out if we are inside the canvas or not and update the
        canvas enter/leave events
        """
        ...
    
    show = ...
    def draw_idle(self):
        'update drawing area only if idle'
        ...
    
    def get_tk_widget(self):
        """returns the Tk widget used to implement FigureCanvasTkAgg.
        Although the initial implementation uses a Tk canvas,  this routine
        is intended to hide that fact.
        """
        ...
    
    def motion_notify_event(self, event):
        ...
    
    def button_press_event(self, event, dblclick: bool = ...):
        ...
    
    def button_dblclick_event(self, event):
        ...
    
    def button_release_event(self, event):
        ...
    
    def scroll_event(self, event):
        ...
    
    def scroll_event_windows(self, event):
        """MouseWheel event processor"""
        ...
    
    def _get_key(self, event):
        ...
    
    def key_press(self, event):
        ...
    
    def key_release(self, event):
        ...
    
    def new_timer(self, *args, **kwargs):
        """
        Creates a new backend-specific subclass of :class:`backend_bases.Timer`.
        This is useful for getting periodic events through the backend's native
        event loop. Implemented only for backends with GUIs.

        Other Parameters
        ----------------
        interval : scalar
            Timer interval in milliseconds
        callbacks : list
            Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``
            will be executed by the timer every *interval*.

        """
        ...
    
    def flush_events(self):
        ...
    


class FigureManagerTk(FigureManagerBase):
    """
    Attributes
    ----------
    canvas : `FigureCanvas`
        The FigureCanvas instance
    num : int or str
        The Figure number
    toolbar : tk.Toolbar
        The tk.Toolbar
    window : tk.Window
        The tk.Window

    """
    def __init__(self, canvas, num, window):
        self.window = ...
        self.canvas = ...
        self.toolmanager = ...
        self.toolbar = ...
        self.statusbar = ...
    
    def _get_toolbar(self):
        ...
    
    def _get_toolmanager(self):
        ...
    
    def resize(self, width, height: Optional[Any] = ...):
        ...
    
    def show(self):
        """
        this function doesn't segfault but causes the
        PyEval_RestoreThread: NULL state bug on win32
        """
        ...
    
    def destroy(self, *args):
        self.window = ...
    
    def get_window_title(self):
        ...
    
    def set_window_title(self, title):
        ...
    
    def full_screen_toggle(self):
        ...
    


@cbook.deprecated("2.2")
class AxisMenu(object):
    def __init__(self, master, naxes):
        ...
    
    def adjust(self, naxes):
        ...
    
    def get_indices(self):
        ...
    
    def set_active(self):
        ...
    
    def invert_all(self):
        ...
    
    def select_all(self):
        ...
    


class NavigationToolbar2Tk(NavigationToolbar2, Tk.Frame):
    """
    Attributes
    ----------
    canvas : `FigureCanvas`
        the figure canvas on which to operate
    win : tk.Window
        the tk.Window which owns this toolbar

    """
    def __init__(self, canvas, window):
        self.canvas = ...
        self.window = ...
    
    def destroy(self, *args):
        ...
    
    def set_message(self, s):
        ...
    
    def draw_rubberband(self, event, x0, y0, x1, y1):
        self.lastrect = ...
    
    def release(self, event):
        ...
    
    def set_cursor(self, cursor):
        ...
    
    def _Button(self, text, file, command, extension=...):
        ...
    
    def _Spacer(self):
        ...
    
    def _init_toolbar(self):
        self.message = ...
    
    def configure_subplots(self):
        ...
    
    def save_figure(self, *args):
        ...
    
    def set_active(self, ind):
        ...
    
    def update(self):
        ...
    


class ToolTip(object):
    """
    Tooltip recipe from
    http://www.voidspace.org.uk/python/weblog/arch_d7_2006_07_01.shtml#e387
    """
    @staticmethod
    def createToolTip(widget, text):
        ...
    
    def __init__(self, widget):
        self.widget = ...
        self.tipwindow = ...
        self.id = ...
        self.x = ...
    
    def showtip(self, text):
        "Display text in tooltip window"
        self.text = ...
        self.tipwindow = ...
    
    def hidetip(self):
        self.tipwindow = ...
    


class RubberbandTk(backend_tools.RubberbandBase):
    def __init__(self, *args, **kwargs):
        ...
    
    def draw_rubberband(self, x0, y0, x1, y1):
        self.lastrect = ...
    
    def remove_rubberband(self):
        ...
    


class SetCursorTk(backend_tools.SetCursorBase):
    def set_cursor(self, cursor):
        ...
    


class ToolbarTk(ToolContainerBase, Tk.Frame):
    _icon_extension = ...
    def __init__(self, toolmanager, window):
        ...
    
    def add_toolitem(self, name, group, position, image_file, description, toggle):
        ...
    
    def _get_groupframe(self, group):
        ...
    
    def _add_separator(self):
        ...
    
    def _Button(self, text, image_file, toggle, frame):
        ...
    
    def _button_click(self, name):
        ...
    
    def toggle_toolitem(self, name, toggled):
        ...
    
    def remove_toolitem(self, name):
        ...
    


class StatusbarTk(StatusbarBase, Tk.Frame):
    def __init__(self, window, *args, **kwargs):
        ...
    
    def set_message(self, s):
        ...
    


class SaveFigureTk(backend_tools.SaveFigureBase):
    def trigger(self, *args):
        ...
    


class ConfigureSubplotsTk(backend_tools.ConfigureSubplotsBase):
    def __init__(self, *args, **kwargs):
        self.window = ...
    
    def trigger(self, *args):
        ...
    
    def init_window(self):
        self.window = ...
    
    def destroy(self, *args, **kwargs):
        self.window = ...
    


Toolbar = ToolbarTk
@_Backend.export
class _BackendTk(_Backend):
    FigureManager = ...
    @classmethod
    def new_figure_manager_given_figure(cls, num, figure):
        """
        Create a new figure manager instance for the given figure.
        """
        ...
    
    @staticmethod
    def trigger_manager_draw(manager):
        ...
    
    @staticmethod
    def mainloop():
        ...
    


