"""
This type stub file was generated by pyright.
"""

import logging
import os
import sys
import matplotlib
from matplotlib import backend_tools, rcParams
from matplotlib.backend_bases import FigureCanvasBase, FigureManagerBase, NavigationToolbar2, StatusbarBase, TimerBase, ToolContainerBase, _Backend, cursors
from ._gtk3_compat import Gdk, Gtk
from typing import Any, Optional

_log = logging.getLogger(__name__)
backend_version = "%s.%s.%s" % (Gtk.get_major_version(), Gtk.get_micro_version(), Gtk.get_minor_version())
PIXELS_PER_INCH = 96
cursord = { cursors.MOVE: Gdk.Cursor.new(Gdk.CursorType.FLEUR),cursors.HAND: Gdk.Cursor.new(Gdk.CursorType.HAND2),cursors.POINTER: Gdk.Cursor.new(Gdk.CursorType.LEFT_PTR),cursors.SELECT_REGION: Gdk.Cursor.new(Gdk.CursorType.TCROSS),cursors.WAIT: Gdk.Cursor.new(Gdk.CursorType.WATCH) }
class TimerGTK3(TimerBase):
    '''
    Subclass of :class:`backend_bases.TimerBase` using GTK3 for timer events.

    Attributes
    ----------
    interval : int
        The time between timer events in milliseconds. Default is 1000 ms.
    single_shot : bool
        Boolean flag indicating whether this timer should operate as single
        shot (run once and then stop). Defaults to False.
    callbacks : list
        Stores list of (func, args) tuples that will be called upon timer
        events. This list can be manipulated directly, or the functions
        `add_callback` and `remove_callback` can be used.

    '''
    def _timer_start(self):
        ...
    
    def _timer_stop(self):
        ...
    
    def _timer_set_interval(self):
        ...
    
    def _on_timer(self):
        ...
    


class FigureCanvasGTK3(Gtk.DrawingArea, FigureCanvasBase):
    keyvald = ...
    event_mask = ...
    def __init__(self, figure):
        ...
    
    def destroy(self):
        ...
    
    def scroll_event(self, widget, event):
        ...
    
    def button_press_event(self, widget, event):
        ...
    
    def button_release_event(self, widget, event):
        ...
    
    def key_press_event(self, widget, event):
        ...
    
    def key_release_event(self, widget, event):
        ...
    
    def motion_notify_event(self, widget, event):
        ...
    
    def leave_notify_event(self, widget, event):
        ...
    
    def enter_notify_event(self, widget, event):
        ...
    
    def size_allocate(self, widget, allocation):
        ...
    
    def _get_key(self, event):
        ...
    
    def configure_event(self, widget, event):
        ...
    
    def on_draw_event(self, widget, ctx):
        ...
    
    def draw(self):
        ...
    
    def draw_idle(self):
        ...
    
    def new_timer(self, *args, **kwargs):
        """
        Creates a new backend-specific subclass of :class:`backend_bases.Timer`.
        This is useful for getting periodic events through the backend's native
        event loop. Implemented only for backends with GUIs.

        Other Parameters
        ----------------
        interval : scalar
            Timer interval in milliseconds
        callbacks : list
            Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``
            will be executed by the timer every *interval*.
        """
        ...
    
    def flush_events(self):
        ...
    


class FigureManagerGTK3(FigureManagerBase):
    """
    Attributes
    ----------
    canvas : `FigureCanvas`
        The FigureCanvas instance
    num : int or str
        The Figure number
    toolbar : Gtk.Toolbar
        The Gtk.Toolbar  (gtk only)
    vbox : Gtk.VBox
        The Gtk.VBox containing the canvas and toolbar (gtk only)
    window : Gtk.Window
        The Gtk.Window   (gtk only)

    """
    def __init__(self, canvas, num):
        self.window = ...
        self.vbox = ...
        self.toolmanager = ...
        self.toolbar = ...
        self.statusbar = ...
    
    def destroy(self, *args):
        ...
    
    def show(self):
        ...
    
    def full_screen_toggle(self):
        ...
    
    _full_screen_flag = ...
    def _get_toolbar(self):
        ...
    
    def _get_toolmanager(self):
        ...
    
    def get_window_title(self):
        ...
    
    def set_window_title(self, title):
        ...
    
    def resize(self, width, height):
        'set the canvas size in pixels'
        ...
    


class NavigationToolbar2GTK3(NavigationToolbar2, Gtk.Toolbar):
    def __init__(self, canvas, window):
        self.win = ...
        self.ctx = ...
    
    def set_message(self, s):
        ...
    
    def set_cursor(self, cursor):
        ...
    
    def release(self, event):
        ...
    
    def draw_rubberband(self, event, x0, y0, x1, y1):
        'adapted from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/189744'
        self.ctx = ...
    
    def _init_toolbar(self):
        self.message = ...
    
    def get_filechooser(self):
        ...
    
    def save_figure(self, *args):
        ...
    
    def configure_subplots(self, button):
        ...
    
    def _get_canvas(self, fig):
        ...
    


class FileChooserDialog(Gtk.FileChooserDialog):
    """GTK+ file selector which remembers the last file/directory
    selected and presents the user with a menu of supported image formats
    """
    def __init__(self, title=..., parent: Optional[Any] = ..., action=..., buttons=..., path: Optional[Any] = ..., filetypes=..., default_filetype: Optional[Any] = ...):
        self.filetypes = ...
        self.sorted_filetypes = ...
        self.ext = ...
    
    def get_filename_from_user(self):
        ...
    


class RubberbandGTK3(backend_tools.RubberbandBase):
    def __init__(self, *args, **kwargs):
        self.ctx = ...
    
    def draw_rubberband(self, x0, y0, x1, y1):
        self.ctx = ...
    


class ToolbarGTK3(ToolContainerBase, Gtk.Box):
    _icon_extension = ...
    def __init__(self, toolmanager):
        ...
    
    def add_toolitem(self, name, group, position, image_file, description, toggle):
        ...
    
    def _add_button(self, button, group, position):
        ...
    
    def _call_tool(self, btn, name):
        ...
    
    def toggle_toolitem(self, name, toggled):
        ...
    
    def remove_toolitem(self, name):
        ...
    
    def _add_separator(self):
        ...
    


class StatusbarGTK3(StatusbarBase, Gtk.Statusbar):
    def __init__(self, *args, **kwargs):
        ...
    
    def set_message(self, s):
        ...
    


class SaveFigureGTK3(backend_tools.SaveFigureBase):
    def get_filechooser(self):
        ...
    
    def trigger(self, *args, **kwargs):
        ...
    


class SetCursorGTK3(backend_tools.SetCursorBase):
    def set_cursor(self, cursor):
        ...
    


class ConfigureSubplotsGTK3(backend_tools.ConfigureSubplotsBase, Gtk.Window):
    def __init__(self, *args, **kwargs):
        self.window = ...
    
    def init_window(self):
        self.window = ...
        self.vbox = ...
    
    def destroy(self, *args):
        self.window = ...
    
    def _get_canvas(self, fig):
        ...
    
    def trigger(self, sender, event, data: Optional[Any] = ...):
        ...
    


if sys.platform == 'win32':
    ...
else:
    icon_filename = 'matplotlib.svg'
window_icon = os.path.join(matplotlib.rcParams['datapath'], 'images', icon_filename)
def error_msg_gtk(msg, parent: Optional[Any] = ...):
    ...

Toolbar = ToolbarGTK3
@_Backend.export
class _BackendGTK3(_Backend):
    FigureCanvas = ...
    FigureManager = ...
    @staticmethod
    def trigger_manager_draw(manager):
        ...
    
    @staticmethod
    def mainloop():
        ...
    


