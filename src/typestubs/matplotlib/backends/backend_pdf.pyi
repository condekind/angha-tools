"""
This type stub file was generated by pyright.
"""

import six
import logging
import re
from functools import total_ordering
from matplotlib.backend_bases import FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase, _Backend
from matplotlib.cbook import Bunch
from typing import Any, Optional

"""
A PDF matplotlib backend
Author: Jouni K Sepp√§nen <jks@iki.fi>
"""
_log = logging.getLogger(__name__)
def fill(strings, linelen=...):
    """Make one string from sequence of strings, with whitespace
    in between. The whitespace is chosen to form lines of at most
    linelen characters, if possible."""
    ...

_string_escape_regex = re.compile(rb'([\\()\r\n])')
def _string_escape(match):
    ...

def pdfRepr(obj):
    """Map Python objects to PDF syntax."""
    ...

class Reference(object):
    """PDF reference object.
    Use PdfFile.reserveObject() to create References.
    """
    def __init__(self, id):
        self.id = ...
    
    def __repr__(self):
        ...
    
    def pdfRepr(self):
        ...
    
    def write(self, contents, file):
        ...
    


@total_ordering
class Name(object):
    """PDF name object."""
    __slots__ = ...
    _regex = ...
    def __init__(self, name):
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __lt__(self, other):
        ...
    
    def __hash__(self):
        ...
    
    @staticmethod
    def hexify(match):
        ...
    
    def pdfRepr(self):
        ...
    


class Operator(object):
    """PDF operator object."""
    __slots__ = ...
    def __init__(self, op):
        self.op = ...
    
    def __repr__(self):
        ...
    
    def pdfRepr(self):
        ...
    


class Verbatim(object):
    """Store verbatim PDF command content for later inclusion in the
    stream."""
    def __init__(self, x):
        ...
    
    def pdfRepr(self):
        ...
    


_pdfops = dict(close_fill_stroke=b'b', fill_stroke=b'B', fill=b'f', closepath=b'h', close_stroke=b's', stroke=b'S', endpath=b'n', begin_text=b'BT', end_text=b'ET', curveto=b'c', rectangle=b're', lineto=b'l', moveto=b'm', concat_matrix=b'cm', use_xobject=b'Do', setgray_stroke=b'G', setgray_nonstroke=b'g', setrgb_stroke=b'RG', setrgb_nonstroke=b'rg', setcolorspace_stroke=b'CS', setcolorspace_nonstroke=b'cs', setcolor_stroke=b'SCN', setcolor_nonstroke=b'scn', setdash=b'd', setlinejoin=b'j', setlinecap=b'J', setgstate=b'gs', gsave=b'q', grestore=b'Q', textpos=b'Td', selectfont=b'Tf', textmatrix=b'Tm', show=b'Tj', showkern=b'TJ', setlinewidth=b'w', clip=b'W', shading=b'sh')
Op = Bunch(**{ name: Operator(value) for (name, value) in six.iteritems(_pdfops) })
def _paint_path(fill, stroke):
    """Return the PDF operator to paint a path in the following way:
    fill:   fill the path with the fill color
    stroke: stroke the outline of the path with the line color"""
    ...

class Stream(object):
    """PDF stream object.

    This has no pdfRepr method. Instead, call begin(), then output the
    contents of the stream by calling write(), and finally call end().
    """
    __slots__ = ...
    def __init__(self, id, len, file, extra: Optional[Any] = ..., png: Optional[Any] = ...):
        """id: object id of stream; len: an unused Reference object for the
        length of the stream, or None (to use a memory buffer); file:
        a PdfFile; extra: a dictionary of extra key-value pairs to
        include in the stream header; png: if the data is already
        png compressed, the decode parameters"""
        self.id = ...
        self.len = ...
        self.pdfFile = ...
        self.file = ...
        self.compressobj = ...
    
    def _writeHeader(self):
        ...
    
    def end(self):
        """Finalize stream."""
        ...
    
    def write(self, data):
        """Write some data on the stream."""
        ...
    
    def _flush(self):
        """Flush the compression object."""
        ...
    


class PdfFile(object):
    """PDF file object."""
    def __init__(self, filename, metadata: Optional[Any] = ...):
        self.nextObject = ...
        self.xrefTable = ...
        self.passed_in_file_object = ...
        self.original_file_like = ...
        self.tell_base = ...
        self.fh = ...
        self.currentstream = ...
        self.rootObject = ...
        self.pagesObject = ...
        self.pageList = ...
        self.fontObject = ...
        self.alphaStateObject = ...
        self.hatchObject = ...
        self.gouraudObject = ...
        self.XObjectObject = ...
        self.resourceObject = ...
        self.infoDict = ...
        self.infoDict = ...
        self.fontNames = ...
        self.nextFont = ...
        self.dviFontInfo = ...
        self.type1Descriptors = ...
        self.used_characters = ...
        self.alphaStates = ...
        self.nextAlphaState = ...
        self.hatchPatterns = ...
        self.nextHatch = ...
        self.gouraudTriangles = ...
        self.nextImage = ...
        self.markers = ...
        self.multi_byte_charprocs = ...
        self.paths = ...
        self.pageAnnotations = ...
    
    def newPage(self, width, height):
        self.pageAnnotations = ...
    
    def newTextnote(self, text, positionRect=...):
        ...
    
    def finalize(self):
        "Write out the various deferred objects and the pdf end matter."
        ...
    
    def close(self):
        "Flush all buffers and free all resources."
        ...
    
    def write(self, data):
        ...
    
    def output(self, *data):
        ...
    
    def beginStream(self, id, len, extra: Optional[Any] = ..., png: Optional[Any] = ...):
        self.currentstream = ...
    
    def endStream(self):
        ...
    
    def fontName(self, fontprop):
        """
        Select a font based on fontprop and return a name suitable for
        Op.selectfont. If fontprop is a string, it will be interpreted
        as the filename of the font.
        """
        ...
    
    @property
    def texFontMap(self):
        ...
    
    def dviFontName(self, dvifont):
        """
        Given a dvi font object, return a name suitable for Op.selectfont.
        This registers the font information in self.dviFontInfo if not yet
        registered.
        """
        ...
    
    def writeFonts(self):
        ...
    
    def _write_afm_font(self, filename):
        ...
    
    def _embedTeXFont(self, fontinfo):
        ...
    
    def createType1Descriptor(self, t1font, fontfile):
        ...
    
    def _get_xobject_symbol_name(self, filename, symbol_name):
        ...
    
    _identityToUnicodeCMap = ...
    def embedTTF(self, filename, characters):
        """Embed the TTF font from the named file into the document."""
        ...
    
    def alphaState(self, alpha):
        """Return name of an ExtGState that sets alpha to the given value."""
        ...
    
    def hatchPattern(self, hatch_style):
        ...
    
    def writeHatches(self):
        ...
    
    def addGouraudTriangles(self, points, colors):
        ...
    
    def writeGouraudTriangles(self):
        ...
    
    def imageObject(self, image):
        """Return name of an image XObject representing the given image."""
        ...
    
    def _unpack(self, im):
        """
        Unpack the image object im into height, width, data, alpha,
        where data and alpha are HxWx3 (RGB) or HxWx1 (grayscale or alpha)
        arrays, except alpha is None if the image is fully opaque.
        """
        ...
    
    def _writePng(self, data):
        """
        Write the image *data* into the pdf file using png
        predictors with Flate compression.
        """
        ...
    
    def _writeImg(self, data, height, width, grayscale, id, smask: Optional[Any] = ...):
        """
        Write the image *data* of size *height* x *width*, as grayscale
        if *grayscale* is true and RGB otherwise, as pdf object *id*
        and with the soft mask (alpha channel) *smask*, which should be
        either None or a *height* x *width* x 1 array.
        """
        ...
    
    def writeImages(self):
        ...
    
    def markerObject(self, path, trans, fill, stroke, lw, joinstyle, capstyle):
        """Return name of a marker XObject representing the given path."""
        ...
    
    def writeMarkers(self):
        ...
    
    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):
        ...
    
    def writePathCollectionTemplates(self):
        ...
    
    @staticmethod
    def pathOperations(path, transform, clip: Optional[Any] = ..., simplify: Optional[Any] = ..., sketch: Optional[Any] = ...):
        ...
    
    def writePath(self, path, transform, clip: bool = ..., sketch: Optional[Any] = ...):
        ...
    
    def reserveObject(self, name=...):
        """Reserve an ID for an indirect object.
        The name is used for debugging in case we forget to print out
        the object with writeObject.
        """
        ...
    
    def recordXref(self, id):
        ...
    
    def writeObject(self, object, contents):
        ...
    
    def writeXref(self):
        """Write out the xref table."""
        self.startxref = ...
    
    def writeInfoDict(self):
        """Write out the info dictionary, checking it for good form"""
        self.infoObject = ...
    
    def writeTrailer(self):
        """Write out the PDF trailer."""
        ...
    


class RendererPdf(RendererBase):
    afm_font_cache = ...
    def __init__(self, file, image_dpi, height, width):
        self.height = ...
        self.width = ...
        self.file = ...
        self.gc = ...
        self.mathtext_parser = ...
        self.image_dpi = ...
    
    def finalize(self):
        ...
    
    def check_gc(self, gc, fillcolor: Optional[Any] = ...):
        ...
    
    def track_characters(self, font, s):
        """Keeps track of which characters are required from
        each font."""
        ...
    
    def merge_used_characters(self, other):
        ...
    
    def get_image_magnification(self):
        ...
    
    def option_scale_image(self):
        """
        pdf backend support arbitrary scaling of image.
        """
        ...
    
    def option_image_nocomposite(self):
        """
        return whether to generate a composite image from multiple images on
        a set of axes
        """
        ...
    
    def draw_image(self, gc, x, y, im, transform: Optional[Any] = ...):
        ...
    
    def draw_path(self, gc, path, transform, rgbFace: Optional[Any] = ...):
        ...
    
    def draw_path_collection(self, gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position):
        ...
    
    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace: Optional[Any] = ...):
        ...
    
    def draw_gouraud_triangle(self, gc, points, colors, trans):
        ...
    
    def draw_gouraud_triangles(self, gc, points, colors, trans):
        ...
    
    def _setup_textpos(self, x, y, angle, oldx=..., oldy=..., oldangle=...):
        ...
    
    def draw_mathtext(self, gc, x, y, s, prop, angle):
        ...
    
    def draw_tex(self, gc, x, y, s, prop, angle, ismath=..., mtext: Optional[Any] = ...):
        ...
    
    def encode_string(self, s, fonttype):
        ...
    
    def draw_text(self, gc, x, y, s, prop, angle, ismath: bool = ..., mtext: Optional[Any] = ...):
        ...
    
    def get_text_width_height_descent(self, s, prop, ismath):
        ...
    
    def _get_font_afm(self, prop):
        ...
    
    def _get_font_ttf(self, prop):
        ...
    
    def flipy(self):
        ...
    
    def get_canvas_width_height(self):
        ...
    
    def new_gc(self):
        ...
    


class GraphicsContextPdf(GraphicsContextBase):
    def __init__(self, file):
        self.file = ...
        self.parent = ...
    
    def __repr__(self):
        ...
    
    def stroke(self):
        """
        Predicate: does the path need to be stroked (its outline drawn)?
        This tests for the various conditions that disable stroking
        the path, in which case it would presumably be filled.
        """
        ...
    
    def fill(self, *args):
        """
        Predicate: does the path need to be filled?

        An optional argument can be used to specify an alternative
        _fillcolor, as needed by RendererPdf.draw_markers.
        """
        ...
    
    def paint(self):
        """
        Return the appropriate pdf operator to cause the path to be
        stroked, filled, or both.
        """
        ...
    
    capstyles = ...
    joinstyles = ...
    def capstyle_cmd(self, style):
        ...
    
    def joinstyle_cmd(self, style):
        ...
    
    def linewidth_cmd(self, width):
        ...
    
    def dash_cmd(self, dashes):
        ...
    
    def alpha_cmd(self, alpha, forced, effective_alphas):
        ...
    
    def hatch_cmd(self, hatch, hatch_color):
        ...
    
    def rgb_cmd(self, rgb):
        ...
    
    def fillcolor_cmd(self, rgb):
        ...
    
    def push(self):
        self.parent = ...
    
    def pop(self):
        self.parent = ...
    
    def clip_cmd(self, cliprect, clippath):
        """Set clip rectangle. Calls self.pop() and self.push()."""
        ...
    
    commands = ...
    def delta(self, other):
        """
        Copy properties of other into self and return PDF commands
        needed to transform self into other.
        """
        ...
    
    def copy_properties(self, other):
        """
        Copy properties of other into self.
        """
        ...
    
    def finalize(self):
        """
        Make sure every pushed graphics state is popped.
        """
        ...
    


class PdfPages(object):
    """
    A multi-page PDF file.

    Examples
    --------

    >>> import matplotlib.pyplot as plt
    >>> # Initialize:
    >>> with PdfPages('foo.pdf') as pdf:
    ...     # As many times as you like, create a figure fig and save it:
    ...     fig = plt.figure()
    ...     pdf.savefig(fig)
    ...     # When no figure is specified the current figure is saved
    ...     pdf.savefig()

    Notes
    -----

    In reality :class:`PdfPages` is a thin wrapper around :class:`PdfFile`, in
    order to avoid confusion when using :func:`~matplotlib.pyplot.savefig` and
    forgetting the format argument.
    """
    __slots__ = ...
    def __init__(self, filename, keep_empty: bool = ..., metadata: Optional[Any] = ...):
        """
        Create a new PdfPages object.

        Parameters
        ----------

        filename : str
            Plots using :meth:`PdfPages.savefig` will be written to a file at
            this location. The file is opened at once and any older file with
            the same name is overwritten.
        keep_empty : bool, optional
            If set to False, then empty pdf files will be deleted automatically
            when closed.
        metadata : dictionary, optional
            Information dictionary object (see PDF reference section 10.2.1
            'Document Information Dictionary'), e.g.:
            `{'Creator': 'My software', 'Author': 'Me',
            'Title': 'Awesome fig'}`

            The standard keys are `'Title'`, `'Author'`, `'Subject'`,
            `'Keywords'`, `'Creator'`, `'Producer'`, `'CreationDate'`,
            `'ModDate'`, and `'Trapped'`. Values have been predefined
            for `'Creator'`, `'Producer'` and `'CreationDate'`. They
            can be removed by setting them to `None`.

        """
        self.keep_empty = ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        ...
    
    def close(self):
        """
        Finalize this object, making the underlying file a complete
        PDF file.
        """
        ...
    
    def infodict(self):
        """
        Return a modifiable information dictionary object
        (see PDF reference section 10.2.1 'Document Information
        Dictionary').
        """
        ...
    
    def savefig(self, figure: Optional[Any] = ..., **kwargs):
        """
        Saves a :class:`~matplotlib.figure.Figure` to this file as a new page.

        Any other keyword arguments are passed to
        :meth:`~matplotlib.figure.Figure.savefig`.

        Parameters
        ----------

        figure : :class:`~matplotlib.figure.Figure` or int, optional
            Specifies what figure is saved to file. If not specified, the
            active figure is saved. If a :class:`~matplotlib.figure.Figure`
            instance is provided, this figure is saved. If an int is specified,
            the figure instance to save is looked up by number.
        """
        ...
    
    def get_pagecount(self):
        """
        Returns the current number of pages in the multipage pdf file.
        """
        ...
    
    def attach_note(self, text, positionRect=...):
        """
        Add a new text note to the page to be saved next. The optional
        positionRect specifies the position of the new note on the
        page. It is outside the page per default to make sure it is
        invisible on printouts.
        """
        ...
    


class FigureCanvasPdf(FigureCanvasBase):
    """
    The canvas the figure renders into.  Calls the draw and print fig
    methods, creates the renderers, etc...

    Attributes
    ----------
    figure : `matplotlib.figure.Figure`
        A high-level Figure instance

    """
    fixed_dpi = ...
    def draw(self):
        ...
    
    filetypes = ...
    def get_default_filetype(self):
        ...
    
    def print_pdf(self, filename, **kwargs):
        ...
    


class FigureManagerPdf(FigureManagerBase):
    ...


@_Backend.export
class _BackendPdf(_Backend):
    FigureCanvas = ...
    FigureManager = ...


