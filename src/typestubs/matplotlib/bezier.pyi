"""
This type stub file was generated by pyright.
"""

"""
A module providing some utility functions regarding bezier path manipulation.
"""
class NonIntersectingPathException(ValueError):
    ...


def get_intersection(cx1, cy1, cos_t1, sin_t1, cx2, cy2, cos_t2, sin_t2):
    """ return a intersecting point between a line through (cx1, cy1)
    and having angle t1 and a line through (cx2, cy2) and angle t2.
    """
    ...

def get_normal_points(cx, cy, cos_t, sin_t, length):
    """
    For a line passing through (*cx*, *cy*) and having a angle *t*, return
    locations of the two points located along its perpendicular line at the
    distance of *length*.
    """
    ...

def _de_casteljau1(beta, t):
    ...

def split_de_casteljau(beta, t):
    """split a bezier segment defined by its controlpoints *beta*
    into two separate segment divided at *t* and return their control points.

    """
    ...

def find_bezier_t_intersecting_with_closedpath(bezier_point_at_t, inside_closedpath, t0=..., t1=..., tolerence=...):
    """ Find a parameter t0 and t1 of the given bezier path which
    bounds the intersecting points with a provided closed
    path(*inside_closedpath*). Search starts from *t0* and *t1* and it
    uses a simple bisecting algorithm therefore one of the end point
    must be inside the path while the orther doesn't. The search stop
    when |t0-t1| gets smaller than the given tolerence.
    value for

    - bezier_point_at_t : a function which returns x, y coordinates at *t*

    - inside_closedpath : return True if the point is inside the path

    """
    ...

class BezierSegment(object):
    """
    A simple class of a 2-dimensional bezier segment
    """
    _binom_coeff = ...
    def __init__(self, control_points):
        """
        *control_points* : location of contol points. It needs have a
         shpae of n * 2, where n is the order of the bezier line. 1<=
         n <= 3 is supported.
        """
        ...
    
    def point_at_t(self, t):
        "evaluate a point at t"
        ...
    


def split_bezier_intersecting_with_closedpath(bezier, inside_closedpath, tolerence=...):
    """
    bezier : control points of the bezier segment
    inside_closedpath : a function which returns true if the point is inside
                        the path
    """
    ...

def find_r_to_boundary_of_closedpath(inside_closedpath, xy, cos_t, sin_t, rmin=..., rmax=..., tolerence=...):
    """
    Find a radius r (centered at *xy*) between *rmin* and *rmax* at
    which it intersect with the path.

    inside_closedpath : function
    cx, cy : center
    cos_t, sin_t : cosine and sine for the angle
    rmin, rmax :
    """
    ...

def split_path_inout(path, inside, tolerence=..., reorder_inout: bool = ...):
    """ divide a path into two segment at the point where inside(x, y)
    becomes False.
    """
    ...

def inside_circle(cx, cy, r):
    ...

def get_cos_sin(x0, y0, x1, y1):
    ...

def check_if_parallel(dx1, dy1, dx2, dy2, tolerence=...):
    """ returns
       * 1 if two lines are parralel in same direction
       * -1 if two lines are parralel in opposite direction
       * 0 otherwise
    """
    ...

def get_parallels(bezier2, width):
    """
    Given the quadratic bezier control points *bezier2*, returns
    control points of quadratic bezier lines roughly parallel to given
    one separated by *width*.
    """
    ...

def find_control_points(c1x, c1y, mmx, mmy, c2x, c2y):
    """ Find control points of the bezier line through c1, mm, c2. We
    simply assume that c1, mm, c2 which have parametric value 0, 0.5, and 1.
    """
    ...

def make_wedged_bezier2(bezier2, width, w1=..., wm=..., w2=...):
    """
    Being similar to get_parallels, returns control points of two quadrativ
    bezier lines having a width roughly parallel to given one separated by
    *width*.
    """
    ...

def make_path_regular(p):
    """
    fill in the codes if None.
    """
    ...

def concatenate_paths(paths):
    """
    concatenate list of paths into a single path.
    """
    ...

