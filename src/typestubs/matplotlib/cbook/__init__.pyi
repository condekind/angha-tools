"""
This type stub file was generated by pyright.
"""

import six
import collections
import contextlib
import datetime
import errno
import functools
import glob
import gzip
import io
import locale
import numbers
import operator
import os
import re
import sys
import time
import traceback
import types
import warnings
import numpy as np
import matplotlib
from __future__ import absolute_import, division, print_function
from six.moves import xrange, zip
from itertools import repeat
from weakref import WeakKeyDictionary, ref
from .deprecation import MatplotlibDeprecationWarning, deprecated, mplDeprecation, warn_deprecated
from typing import Any, Optional

"""
A collection of utility functions and classes.  Originally, many
(but not all) were from the Python Cookbook -- hence the name cbook.

This module is safe to import from anywhere within matplotlib;
it imports matplotlib only at runtime.
"""
def unicode_safe(s):
    ...

@deprecated('2.1')
class converter(object):
    """
    Base class for handling string -> python type with support for
    missing values
    """
    def __init__(self, missing=..., missingval: Optional[Any] = ...):
        self.missing = ...
        self.missingval = ...
    
    def __call__(self, s):
        ...
    
    def is_missing(self, s):
        ...
    


@deprecated('2.1')
class tostr(converter):
    """convert to string or None"""
    def __init__(self, missing=..., missingval=...):
        ...
    


@deprecated('2.1')
class todatetime(converter):
    """convert to a datetime or None"""
    def __init__(self, fmt=..., missing=..., missingval: Optional[Any] = ...):
        'use a :func:`time.strptime` format string for conversion'
        self.fmt = ...
    
    def __call__(self, s):
        ...
    


@deprecated('2.1')
class todate(converter):
    """convert to a date or None"""
    def __init__(self, fmt=..., missing=..., missingval: Optional[Any] = ...):
        """use a :func:`time.strptime` format string for conversion"""
        self.fmt = ...
    
    def __call__(self, s):
        ...
    


@deprecated('2.1')
class tofloat(converter):
    """convert to a float or None"""
    def __init__(self, missing=..., missingval: Optional[Any] = ...):
        self.missingval = ...
    
    def __call__(self, s):
        ...
    


@deprecated('2.1')
class toint(converter):
    """convert to an int or None"""
    def __init__(self, missing=..., missingval: Optional[Any] = ...):
        ...
    
    def __call__(self, s):
        ...
    


class _BoundMethodProxy(object):
    """
    Our own proxy object which enables weak references to bound and unbound
    methods and arbitrary callables. Pulls information about the function,
    class, and instance out of a bound method. Stores a weak reference to the
    instance to support garbage collection.

    @organization: IBM Corporation
    @copyright: Copyright (c) 2005, 2006 IBM Corporation
    @license: The BSD License

    Minor bugfixes by Michael Droettboom
    """
    def __init__(self, cb):
        ...
    
    def add_destroy_callback(self, callback):
        ...
    
    def _destroy(self, wk):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, statedict):
        self.__dict__ = ...
    
    def __call__(self, *args, **kwargs):
        """
        Proxy for a call to the weak referenced object. Take
        arbitrary params to pass to the callable.

        Raises `ReferenceError`: When the weak reference refers to
        a dead object
        """
        ...
    
    def __eq__(self, other):
        """
        Compare the held function and instance with that held by
        another proxy.
        """
        ...
    
    def __ne__(self, other):
        """
        Inverse of __eq__.
        """
        ...
    
    def __hash__(self):
        ...
    


def _exception_printer(exc):
    ...

class CallbackRegistry(object):
    """Handle registering and disconnecting for a set of signals and callbacks:

        >>> def oneat(x):
        ...    print('eat', x)
        >>> def ondrink(x):
        ...    print('drink', x)

        >>> from matplotlib.cbook import CallbackRegistry
        >>> callbacks = CallbackRegistry()

        >>> id_eat = callbacks.connect('eat', oneat)
        >>> id_drink = callbacks.connect('drink', ondrink)

        >>> callbacks.process('drink', 123)
        drink 123
        >>> callbacks.process('eat', 456)
        eat 456
        >>> callbacks.process('be merry', 456) # nothing will be called
        >>> callbacks.disconnect(id_eat)
        >>> callbacks.process('eat', 456)      # nothing will be called

    In practice, one should always disconnect all callbacks when they
    are no longer needed to avoid dangling references (and thus memory
    leaks).  However, real code in matplotlib rarely does so, and due
    to its design, it is rather difficult to place this kind of code.
    To get around this, and prevent this class of memory leaks, we
    instead store weak references to bound methods only, so when the
    destination object needs to die, the CallbackRegistry won't keep
    it alive.  The Python stdlib weakref module can not create weak
    references to bound methods directly, so we need to create a proxy
    object to handle weak references to bound methods (or regular free
    functions).  This technique was shared by Peter Parente on his
    `"Mindtrove" blog
    <http://mindtrove.info/python-weak-references/>`_.


    Parameters
    ----------
    exception_handler : callable, optional
       If provided must have signature ::

          def handler(exc: Exception) -> None:

       If not None this function will be called with any `Exception`
       subclass raised by the callbacks in `CallbackRegistry.process`.
       The handler may either consume the exception or re-raise.

       The callable must be pickle-able.

       The default handler is ::

          def h(exc):
              traceback.print_exc()

    """
    def __init__(self, exception_handler=...):
        self.exception_handler = ...
        self.callbacks = ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        ...
    
    def connect(self, s, func):
        """Register *func* to be called when signal *s* is generated.
        """
        ...
    
    def _remove_proxy(self, proxy):
        ...
    
    def disconnect(self, cid):
        """Disconnect the callback registered with callback id *cid*.
        """
        ...
    
    def process(self, s, *args, **kwargs):
        """
        Process signal *s*.

        All of the functions registered to receive callbacks on *s* will be
        called with ``*args`` and ``**kwargs``.
        """
        ...
    


class silent_list(list):
    """
    override repr when returning a list of matplotlib artists to
    prevent long, meaningless output.  This is meant to be used for a
    homogeneous list of a given type
    """
    def __init__(self, type, seq: Optional[Any] = ...):
        self.type = ...
    
    def __repr__(self):
        ...
    
    def __str__(self):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        self.type = ...
    


class IgnoredKeywordWarning(UserWarning):
    """
    A class for issuing warnings about keyword arguments that will be ignored
    by matplotlib
    """
    ...


def local_over_kwdict(local_var, kwargs, *keys):
    """
    Enforces the priority of a local variable over potentially conflicting
    argument(s) from a kwargs dict. The following possible output values are
    considered in order of priority:

        local_var > kwargs[keys[0]] > ... > kwargs[keys[-1]]

    The first of these whose value is not None will be returned. If all are
    None then None will be returned. Each key in keys will be removed from the
    kwargs dict in place.

    Parameters
    ----------
        local_var: any object
            The local variable (highest priority)

        kwargs: dict
            Dictionary of keyword arguments; modified in place

        keys: str(s)
            Name(s) of keyword arguments to process, in descending order of
            priority

    Returns
    -------
        out: any object
            Either local_var or one of kwargs[key] for key in keys

    Raises
    ------
        IgnoredKeywordWarning
            For each key in keys that is removed from kwargs but not used as
            the output value

    """
    ...

def strip_math(s):
    """remove latex formatting from mathtext"""
    ...

class Bunch(object):
    """
    Often we want to just collect a bunch of stuff together, naming each
    item of the bunch; a dictionary's OK for that, but a small do- nothing
    class is even handier, and prettier to use.  Whenever you want to
    group a few variables::

      >>> point = Bunch(datum=2, squared=4, coord=12)
      >>> point.datum

      By: Alex Martelli
      From: https://code.activestate.com/recipes/121294/
    """
    def __init__(self, **kwds):
        ...
    
    def __repr__(self):
        ...
    


@deprecated('2.1')
def unique(x):
    """Return a list of unique elements of *x*"""
    ...

def iterable(obj):
    """return true if *obj* is iterable"""
    ...

@deprecated('2.1')
def is_string_like(obj):
    """Return True if *obj* looks like a string"""
    ...

@deprecated('2.1')
def is_sequence_of_strings(obj):
    """Returns true if *obj* is iterable and contains strings"""
    ...

def is_hashable(obj):
    """Returns true if *obj* can be hashed"""
    ...

def is_writable_file_like(obj):
    """return true if *obj* looks like a file object with a *write* method"""
    ...

def file_requires_unicode(x):
    """
    Returns `True` if the given writable file-like object requires Unicode
    to be written to it.
    """
    ...

@deprecated('2.1')
def is_scalar(obj):
    """return true if *obj* is not string like and is not iterable"""
    ...

def is_numlike(obj):
    """return true if *obj* looks like a number"""
    ...

def to_filehandle(fname, flag=..., return_opened: bool = ..., encoding: Optional[Any] = ...):
    """
    *fname* can be an `os.PathLike` or a file handle.  Support for gzipped
    files is automatic, if the filename ends in .gz.  *flag* is a
    read/write flag for :func:`file`
    """
    ...

@contextlib.contextmanager
def open_file_cm(path_or_file, mode=..., encoding: Optional[Any] = ...):
    r"""Pass through file objects and context-manage `.PathLike`\s."""
    ...

def is_scalar_or_string(val):
    """Return whether the given object is a scalar or string like."""
    ...

def _string_to_bool(s):
    """Parses the string argument as a boolean"""
    ...

def get_sample_data(fname, asfileobj: bool = ...):
    """
    Return a sample data file.  *fname* is a path relative to the
    `mpl-data/sample_data` directory.  If *asfileobj* is `True`
    return a file object, otherwise just a file path.

    Set the rc parameter examples.directory to the directory where we should
    look, if sample_data files are stored in a location different than
    default (which is 'mpl-data/sample_data` at the same level of 'matplotlib`
    Python module files).

    If the filename ends in .gz, the file is implicitly ungzipped.
    """
    ...

def flatten(seq, scalarp=...):
    """
    Returns a generator of flattened nested containers

    For example:

        >>> from matplotlib.cbook import flatten
        >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])
        >>> print(list(flatten(l)))
        ['John', 'Hunter', 1, 23, 42, 5, 23]

    By: Composite of Holger Krekel and Luther Blissett
    From: https://code.activestate.com/recipes/121294/
    and Recipe 1.12 in cookbook
    """
    ...

@deprecated('2.1', "sorted(..., key=itemgetter(...))")
class Sorter(object):
    """
    Sort by attribute or item

    Example usage::

      sort = Sorter()

      list = [(1, 2), (4, 8), (0, 3)]
      dict = [{'a': 3, 'b': 4}, {'a': 5, 'b': 2}, {'a': 0, 'b': 0},
              {'a': 9, 'b': 9}]


      sort(list)       # default sort
      sort(list, 1)    # sort by index 1
      sort(dict, 'a')  # sort a list of dicts by key 'a'

    """
    def _helper(self, data, aux, inplace):
        ...
    
    def byItem(self, data, itemindex: Optional[Any] = ..., inplace=...):
        ...
    
    def byAttribute(self, data, attributename, inplace=...):
        ...
    
    sort = ...
    __call__ = ...


@deprecated('2.1')
class Xlator(dict):
    """
    All-in-one multiple-string-substitution class

    Example usage::

      text = "Larry Wall is the creator of Perl"
      adict = {
      "Larry Wall" : "Guido van Rossum",
      "creator" : "Benevolent Dictator for Life",
      "Perl" : "Python",
      }

      print(multiple_replace(adict, text))

      xlat = Xlator(adict)
      print(xlat.xlat(text))
    """
    def _make_regex(self):
        """ Build re object based on the keys of the current dictionary """
        ...
    
    def __call__(self, match):
        """ Handler invoked for each regex *match* """
        ...
    
    def xlat(self, text):
        """ Translate *text*, returns the modified text. """
        ...
    


@deprecated('2.1')
def soundex(name, len=...):
    """ soundex module conforming to Odell-Russell algorithm """
    ...

@deprecated('2.1')
class Null(object):
    """ Null objects always and reliably "do nothing." """
    def __init__(self, *args, **kwargs):
        ...
    
    def __call__(self, *args, **kwargs):
        ...
    
    def __str__(self):
        ...
    
    def __repr__(self):
        ...
    
    if six.PY3:
        def __bool__(self):
            ...
        
    else:
        def __nonzero__(self):
            ...
        
    def __getattr__(self, name):
        ...
    
    def __setattr__(self, name, value):
        ...
    
    def __delattr__(self, name):
        ...
    


def mkdirs(newdir, mode=...):
    """
    make directory *newdir* recursively, and set *mode*.  Equivalent to ::

        > mkdir -p NEWDIR
        > chmod MODE NEWDIR
    """
    ...

class GetRealpathAndStat(object):
    def __init__(self):
        ...
    
    def __call__(self, path):
        ...
    


get_realpath_and_stat = GetRealpathAndStat()
@deprecated('2.1')
def dict_delall(d, keys):
    """delete all of the *keys* from the :class:`dict` *d*"""
    ...

@deprecated('2.1')
class RingBuffer(object):
    """ class that implements a not-yet-full buffer """
    def __init__(self, size_max):
        self.max = ...
        self.data = ...
    
    class __Full:
        """ class that implements a full buffer """
        def append(self, x):
            """ Append an element overwriting the oldest one. """
            self.cur = ...
        
        def get(self):
            """ return list of elements in correct order """
            ...
        
    
    
    def append(self, x):
        """append an element at the end of the buffer"""
        ...
    
    def get(self):
        """ Return a list of elements from the oldest to the newest. """
        ...
    
    def __get_item__(self, i):
        ...
    


@deprecated('2.1')
def get_split_ind(seq, N):
    """
    *seq* is a list of words.  Return the index into seq such that::

        len(' '.join(seq[:ind])<=N

    .
    """
    ...

@deprecated('2.1', alternative='textwrap.TextWrapper')
def wrap(prefix, text, cols):
    """wrap *text* with *prefix* at length *cols*"""
    ...

_find_dedent_regex = re.compile(r"(?:(?:\n\r?)|^)( *)\S")
_dedent_regex = {  }
def dedent(s):
    """
    Remove excess indentation from docstring *s*.

    Discards any leading blank lines, then removes up to n whitespace
    characters from each line, where n is the number of leading
    whitespace characters in the first line. It differs from
    textwrap.dedent in its deletion of leading blank lines and its use
    of the first non-blank line to determine the indentation.

    It is also faster in most cases.
    """
    ...

def listFiles(root, patterns=..., recurse=..., return_folders=...):
    """
    Recursively list files

    from Parmar and Martelli in the Python Cookbook
    """
    ...

@deprecated('2.1')
def get_recursive_filelist(args):
    """
    Recurse all the files and dirs in *args* ignoring symbolic links
    and return the files as a list of strings
    """
    ...

@deprecated('2.1')
def pieces(seq, num=...):
    """Break up the *seq* into *num* tuples"""
    ...

@deprecated('2.1')
def exception_to_str(s: Optional[Any] = ...):
    ...

@deprecated('2.1')
def allequal(seq):
    """
    Return *True* if all elements of *seq* compare equal.  If *seq* is
    0 or 1 length, return *True*
    """
    ...

@deprecated('2.1')
def alltrue(seq):
    """
    Return *True* if all elements of *seq* evaluate to *True*.  If
    *seq* is empty, return *False*.
    """
    ...

@deprecated('2.1')
def onetrue(seq):
    """
    Return *True* if one element of *seq* is *True*.  It *seq* is
    empty, return *False*.
    """
    ...

@deprecated('2.1')
def allpairs(x):
    """
    return all possible pairs in sequence *x*
    """
    ...

class maxdict(dict):
    """
    A dictionary with a maximum size; this doesn't override all the
    relevant methods to constrain the size, just setitem, so use with
    caution
    """
    def __init__(self, maxsize):
        self.maxsize = ...
    
    def __setitem__(self, k, v):
        ...
    


class Stack(object):
    """
    Implement a stack where elements can be pushed on and you can move
    back and forth.  But no pop.  Should mimic home / back / forward
    in a browser
    """
    def __init__(self, default: Optional[Any] = ...):
        ...
    
    def __call__(self):
        """return the current element, or None"""
        ...
    
    def __len__(self):
        ...
    
    def __getitem__(self, ind):
        ...
    
    def forward(self):
        """move the position forward and return the current element"""
        ...
    
    def back(self):
        """move the position back and return the current element"""
        ...
    
    def push(self, o):
        """
        push object onto stack at current position - all elements
        occurring later than the current position are discarded
        """
        ...
    
    def home(self):
        """push the first element onto the top of the stack"""
        ...
    
    def empty(self):
        ...
    
    def clear(self):
        """empty the stack"""
        ...
    
    def bubble(self, o):
        """
        raise *o* to the top of the stack and return *o*.  *o* must be
        in the stack
        """
        ...
    
    def remove(self, o):
        'remove element *o* from the stack'
        ...
    


@deprecated('2.1')
def finddir(o, match, case: bool = ...):
    """
    return all attributes of *o* which match string in match.  if case
    is True require an exact case match.
    """
    ...

@deprecated('2.1')
def reverse_dict(d):
    """reverse the dictionary -- may lose data if values are not unique!"""
    ...

@deprecated('2.1')
def restrict_dict(d, keys):
    """
    Return a dictionary that contains those keys that appear in both
    d and keys, with values from d.
    """
    ...

def report_memory(i=...):
    """return the memory consumed by process"""
    ...

_safezip_msg = 'In safezip, len(args[0])=%d but len(args[%d])=%d'
def safezip(*args):
    """make sure *args* are equal len before zipping"""
    ...

@deprecated('2.1')
def issubclass_safe(x, klass):
    """return issubclass(x, klass) and return False on a TypeError"""
    ...

def safe_masked_invalid(x, copy: bool = ...):
    ...

def print_cycles(objects, outstream=..., show_progress: bool = ...):
    """
    *objects*
        A list of objects to find cycles in.  It is often useful to
        pass in gc.garbage to find the cycles that are preventing some
        objects from being garbage collected.

    *outstream*
        The stream for output.

    *show_progress*
        If True, print the number of objects reached as they are found.
    """
    ...

class Grouper(object):
    """
    This class provides a lightweight way to group arbitrary objects
    together into disjoint sets when a full-blown graph data structure
    would be overkill.

    Objects can be joined using :meth:`join`, tested for connectedness
    using :meth:`joined`, and all disjoint sets can be retrieved by
    using the object as an iterator.

    The objects being joined must be hashable and weak-referenceable.

    For example:

        >>> from matplotlib.cbook import Grouper
        >>> class Foo(object):
        ...     def __init__(self, s):
        ...         self.s = s
        ...     def __repr__(self):
        ...         return self.s
        ...
        >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']
        >>> grp = Grouper()
        >>> grp.join(a, b)
        >>> grp.join(b, c)
        >>> grp.join(d, e)
        >>> sorted(map(tuple, grp))
        [(a, b, c), (d, e)]
        >>> grp.joined(a, b)
        True
        >>> grp.joined(a, c)
        True
        >>> grp.joined(a, d)
        False

    """
    def __init__(self, init=...):
        ...
    
    def __contains__(self, item):
        ...
    
    def clean(self):
        """
        Clean dead weak references from the dictionary
        """
        ...
    
    def join(self, a, *args):
        """
        Join given arguments into the same set.  Accepts one or more
        arguments.
        """
        ...
    
    def joined(self, a, b):
        """
        Returns True if *a* and *b* are members of the same set.
        """
        ...
    
    def remove(self, a):
        ...
    
    def __iter__(self):
        """
        Iterate over each of the disjoint sets as a list.

        The iterator is invalid if interleaved with calls to join().
        """
        ...
    
    def get_siblings(self, a):
        """
        Returns all of the items joined with *a*, including itself.
        """
        ...
    


def simple_linear_interpolation(a, steps):
    """
    Resample an array with ``steps - 1`` points between original point pairs.

    Parameters
    ----------
    a : array, shape (n, ...)
    steps : int

    Returns
    -------
    array, shape ``((n - 1) * steps + 1, ...)``

    Along each column of *a*, ``(steps - 1)`` points are introduced between
    each original values; the values are linearly interpolated.
    """
    ...

@deprecated('2.1', alternative='shutil.rmtree')
def recursive_remove(path):
    ...

def delete_masked_points(*args):
    """
    Find all masked and/or non-finite points in a set of arguments,
    and return the arguments with only the unmasked points remaining.

    Arguments can be in any of 5 categories:

    1) 1-D masked arrays
    2) 1-D ndarrays
    3) ndarrays with more than one dimension
    4) other non-string iterables
    5) anything else

    The first argument must be in one of the first four categories;
    any argument with a length differing from that of the first
    argument (and hence anything in category 5) then will be
    passed through unchanged.

    Masks are obtained from all arguments of the correct length
    in categories 1, 2, and 4; a point is bad if masked in a masked
    array or if it is a nan or inf.  No attempt is made to
    extract a mask from categories 2, 3, and 4 if :meth:`np.isfinite`
    does not yield a Boolean array.

    All input arguments that are not passed unchanged are returned
    as ndarrays after removing the points or rows corresponding to
    masks in any of the arguments.

    A vastly simpler version of this function was originally
    written as a helper for Axes.scatter().

    """
    ...

def boxplot_stats(X, whis=..., bootstrap: Optional[Any] = ..., labels: Optional[Any] = ..., autorange: bool = ...):
    """
    Returns list of dictionaries of statistics used to draw a series
    of box and whisker plots. The `Returns` section enumerates the
    required keys of the dictionary. Users can skip this function and
    pass a user-defined set of dictionaries to the new `axes.bxp` method
    instead of relying on MPL to do the calculations.

    Parameters
    ----------
    X : array-like
        Data that will be represented in the boxplots. Should have 2 or
        fewer dimensions.

    whis : float, string, or sequence (default = 1.5)
        As a float, determines the reach of the whiskers to the beyond the
        first and third quartiles. In other words, where IQR is the
        interquartile range (`Q3-Q1`), the upper whisker will extend to last
        datum less than `Q3 + whis*IQR`). Similarly, the lower whisker will
        extend to the first datum greater than `Q1 - whis*IQR`.
        Beyond the whiskers, data are considered outliers
        and are plotted as individual points. This can be set this to an
        ascending sequence of percentile (e.g., [5, 95]) to set the
        whiskers at specific percentiles of the data. Finally, `whis`
        can be the string ``'range'`` to force the whiskers to the
        minimum and maximum of the data. In the edge case that the 25th
        and 75th percentiles are equivalent, `whis` can be automatically
        set to ``'range'`` via the `autorange` option.

    bootstrap : int, optional
        Number of times the confidence intervals around the median
        should be bootstrapped (percentile method).

    labels : array-like, optional
        Labels for each dataset. Length must be compatible with
        dimensions of `X`.

    autorange : bool, optional (False)
        When `True` and the data are distributed such that the  25th and
        75th percentiles are equal, ``whis`` is set to ``'range'`` such
        that the whisker ends are at the minimum and maximum of the
        data.

    Returns
    -------
    bxpstats : list of dict
        A list of dictionaries containing the results for each column
        of data. Keys of each dictionary are the following:

        ========   ===================================
        Key        Value Description
        ========   ===================================
        label      tick label for the boxplot
        mean       arithemetic mean value
        med        50th percentile
        q1         first quartile (25th percentile)
        q3         third quartile (75th percentile)
        cilo       lower notch around the median
        cihi       upper notch around the median
        whislo     end of the lower whisker
        whishi     end of the upper whisker
        fliers     outliers
        ========   ===================================

    Notes
    -----
    Non-bootstrapping approach to confidence interval uses Gaussian-
    based asymptotic approximation:

    .. math::

        \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}

    General approach from:
    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) "Variations of
    Boxplots", The American Statistician, 32:12-16.

    """
    ...

@deprecated('2.1')
def unmasked_index_ranges(mask, compressed: bool = ...):
    """
    Find index ranges where *mask* is *False*.

    *mask* will be flattened if it is not already 1-D.

    Returns Nx2 :class:`numpy.ndarray` with each row the start and stop
    indices for slices of the compressed :class:`numpy.ndarray`
    corresponding to each of *N* uninterrupted runs of unmasked
    values.  If optional argument *compressed* is *False*, it returns
    the start and stop indices into the original :class:`numpy.ndarray`,
    not the compressed :class:`numpy.ndarray`.  Returns *None* if there
    are no unmasked values.

    Example::

      y = ma.array(np.arange(5), mask = [0,0,1,0,0])
      ii = unmasked_index_ranges(ma.getmaskarray(y))
      # returns array [[0,2,] [2,4,]]

      y.compressed()[ii[1,0]:ii[1,1]]
      # returns array [3,4,]

      ii = unmasked_index_ranges(ma.getmaskarray(y), compressed=False)
      # returns array [[0, 2], [3, 5]]

      y.filled()[ii[1,0]:ii[1,1]]
      # returns array [3,4,]

    Prior to the transforms refactoring, this was used to support
    masked arrays in Line2D.
    """
    ...

ls_mapper = { '-': 'solid','--': 'dashed','-.': 'dashdot',':': 'dotted' }
ls_mapper_r = { v: k for (k, v) in six.iteritems(ls_mapper) }
@deprecated('2.2')
def align_iterators(func, *iterables):
    """
    This generator takes a bunch of iterables that are ordered by func
    It sends out ordered tuples::

       (func(row), [rows from all iterators matching func(row)])

    It is used by :func:`matplotlib.mlab.recs_join` to join record arrays
    """
    class myiter:
        ...
    
    

def contiguous_regions(mask):
    """
    Return a list of (ind0, ind1) such that mask[ind0:ind1].all() is
    True and we cover all such regions
    """
    ...

def is_math_text(s):
    ...

def _to_unmasked_float_array(x):
    """
    Convert a sequence to a float array; if input was a masked array, masked
    values are converted to nans.
    """
    ...

def _check_1d(x):
    '''
    Converts a sequence of less than 1 dimension, to an array of 1
    dimension; leaves everything else untouched.
    '''
    ...

def _reshape_2D(X, name):
    """
    Use Fortran ordering to convert ndarrays and lists of iterables to lists of
    1D arrays.

    Lists of iterables are converted by applying `np.asarray` to each of their
    elements.  1D ndarrays are returned in a singleton list containing them.
    2D ndarrays are converted to the list of their *columns*.

    *name* is used to generate the error message for invalid inputs.
    """
    ...

def violin_stats(X, method, points=...):
    """
    Returns a list of dictionaries of data which can be used to draw a series
    of violin plots. See the `Returns` section below to view the required keys
    of the dictionary. Users can skip this function and pass a user-defined set
    of dictionaries to the `axes.vplot` method instead of using MPL to do the
    calculations.

    Parameters
    ----------
    X : array-like
        Sample data that will be used to produce the gaussian kernel density
        estimates. Must have 2 or fewer dimensions.

    method : callable
        The method used to calculate the kernel density estimate for each
        column of data. When called via `method(v, coords)`, it should
        return a vector of the values of the KDE evaluated at the values
        specified in coords.

    points : scalar, default = 100
        Defines the number of points to evaluate each of the gaussian kernel
        density estimates at.

    Returns
    -------

    A list of dictionaries containing the results for each column of data.
    The dictionaries contain at least the following:

        - coords: A list of scalars containing the coordinates this particular
          kernel density estimate was evaluated at.
        - vals: A list of scalars containing the values of the kernel density
          estimate at each of the coordinates given in `coords`.
        - mean: The mean value for this column of data.
        - median: The median value for this column of data.
        - min: The minimum value for this column of data.
        - max: The maximum value for this column of data.
    """
    ...

class _NestedClassGetter(object):
    """
    When called with the containing class as the first argument,
    and the name of the nested class as the second argument,
    returns an instance of the nested class.
    """
    def __call__(self, containing_class, class_name):
        ...
    


class _InstanceMethodPickler(object):
    """
    Pickle cannot handle instancemethod saving. _InstanceMethodPickler
    provides a solution to this.
    """
    def __init__(self, instancemethod):
        """Takes an instancemethod as its only argument."""
        ...
    
    def get_instancemethod(self):
        ...
    


def pts_to_prestep(x, *args):
    """
    Convert continuous line to pre-steps.

    Given a set of ``N`` points, convert to ``2N - 1`` points, which when
    connected linearly give a step function which changes values at the
    beginning of the intervals.

    Parameters
    ----------
    x : array
        The x location of the steps. May be empty.

    y1, ..., yp : array
        y arrays to be turned into steps; all must be the same length as ``x``.

    Returns
    -------
    out : array
        The x and y values converted to steps in the same order as the input;
        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is
        length ``N``, each of these arrays will be length ``2N + 1``. For
        ``N=0``, the length will be 0.

    Examples
    --------
    >> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)
    """
    ...

def pts_to_poststep(x, *args):
    """
    Convert continuous line to post-steps.

    Given a set of ``N`` points convert to ``2N + 1`` points, which when
    connected linearly give a step function which changes values at the end of
    the intervals.

    Parameters
    ----------
    x : array
        The x location of the steps. May be empty.

    y1, ..., yp : array
        y arrays to be turned into steps; all must be the same length as ``x``.

    Returns
    -------
    out : array
        The x and y values converted to steps in the same order as the input;
        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is
        length ``N``, each of these arrays will be length ``2N + 1``. For
        ``N=0``, the length will be 0.

    Examples
    --------
    >> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)
    """
    ...

def pts_to_midstep(x, *args):
    """
    Convert continuous line to mid-steps.

    Given a set of ``N`` points convert to ``2N`` points which when connected
    linearly give a step function which changes values at the middle of the
    intervals.

    Parameters
    ----------
    x : array
        The x location of the steps. May be empty.

    y1, ..., yp : array
        y arrays to be turned into steps; all must be the same length as ``x``.

    Returns
    -------
    out : array
        The x and y values converted to steps in the same order as the input;
        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is
        length ``N``, each of these arrays will be length ``2N``.

    Examples
    --------
    >> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)
    """
    ...

STEP_LOOKUP_MAP = { 'default': lambda x, y: (x, y),'steps': pts_to_prestep,'steps-pre': pts_to_prestep,'steps-post': pts_to_poststep,'steps-mid': pts_to_midstep }
def index_of(y):
    """
    A helper function to get the index of an input to plot
    against if x values are not explicitly given.

    Tries to get `y.index` (works if this is a pd.Series), if that
    fails, return np.arange(y.shape[0]).

    This will be extended in the future to deal with more types of
    labeled data.

    Parameters
    ----------
    y : scalar or array-like
        The proposed y-value

    Returns
    -------
    x, y : ndarray
       The x and y values to plot.
    """
    ...

def safe_first_element(obj):
    ...

def sanitize_sequence(data):
    """Converts dictview object to list"""
    ...

def normalize_kwargs(kw, alias_mapping: Optional[Any] = ..., required=..., forbidden=..., allowed: Optional[Any] = ...):
    """Helper function to normalize kwarg inputs

    The order they are resolved are:

     1. aliasing
     2. required
     3. forbidden
     4. allowed

    This order means that only the canonical names need appear in
    `allowed`, `forbidden`, `required`

    Parameters
    ----------

    alias_mapping, dict, optional
        A mapping between a canonical name to a list of
        aliases, in order of precedence from lowest to highest.

        If the canonical value is not in the list it is assumed to have
        the highest priority.

    required : iterable, optional
        A tuple of fields that must be in kwargs.

    forbidden : iterable, optional
        A list of keys which may not be in kwargs

    allowed : tuple, optional
        A tuple of allowed fields.  If this not None, then raise if
        `kw` contains any keys not in the union of `required`
        and `allowed`.  To allow only the required fields pass in
        ``()`` for `allowed`

    Raises
    ------
    TypeError
        To match what python raises if invalid args/kwargs are passed to
        a callable.

    """
    ...

def get_label(y, default_name):
    ...

_lockstr = """\
LOCKERROR: matplotlib is trying to acquire the lock
    {!r}
and has failed.  This maybe due to any other process holding this
lock.  If you are sure no other matplotlib process is running try
removing these folders and trying again.
"""
class Locked(object):
    """
    Context manager to handle locks.

    Based on code from conda.

    (c) 2012-2013 Continuum Analytics, Inc. / https://www.continuum.io/
    All Rights Reserved

    conda is distributed under the terms of the BSD 3-clause license.
    Consult LICENSE_CONDA or https://opensource.org/licenses/BSD-3-Clause.
    """
    LOCKFN = ...
    class TimeoutError(RuntimeError):
        ...
    
    
    def __init__(self, path):
        self.path = ...
        self.end = ...
        self.lock_path = ...
        self.pattern = ...
        self.remove = ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_value, traceback):
        ...
    


class _FuncInfo(object):
    """
    Class used to store a function.

    """
    def __init__(self, function, inverse, bounded_0_1: bool = ..., check_params: Optional[Any] = ...):
        """
        Parameters
        ----------

        function : callable
            A callable implementing the function receiving the variable as
            first argument and any additional parameters in a list as second
            argument.
        inverse : callable
            A callable implementing the inverse function receiving the variable
            as first argument and any additional parameters in a list as
            second argument. It must satisfy 'inverse(function(x, p), p) == x'.
        bounded_0_1: bool or callable
            A boolean indicating whether the function is bounded in the [0,1]
            interval, or a callable taking a list of values for the additional
            parameters, and returning a boolean indicating whether the function
            is bounded in the [0,1] interval for that combination of
            parameters. Default True.
        check_params: callable or None
            A callable taking a list of values for the additional parameters
            and returning a boolean indicating whether that combination of
            parameters is valid. It is only required if the function has
            additional parameters and some of them are restricted.
            Default None.

        """
        self.function = ...
        self.inverse = ...
    
    def is_bounded_0_1(self, params: Optional[Any] = ...):
        """
        Returns a boolean indicating if the function is bounded in the [0,1]
        interval for a particular set of additional parameters.

        Parameters
        ----------

        params : list
            The list of additional parameters. Default None.

        Returns
        -------

        out : bool
            True if the function is bounded in the [0,1] interval for
            parameters 'params'. Otherwise False.

        """
        ...
    
    def check_params(self, params: Optional[Any] = ...):
        """
        Returns a boolean indicating if the set of additional parameters is
        valid.

        Parameters
        ----------

        params : list
            The list of additional parameters. Default None.

        Returns
        -------

        out : bool
            True if 'params' is a valid set of additional parameters for the
            function. Otherwise False.

        """
        ...
    


class _StringFuncParser(object):
    """
    A class used to convert predefined strings into
    _FuncInfo objects, or to directly obtain _FuncInfo
    properties.

    """
    _funcs = ...
    def __init__(self, str_func):
        """
        Parameters
        ----------
        str_func : string
            String to be parsed.

        """
        ...
    
    def _parse_func(self):
        """
        Parses the parameters to build a new _FuncInfo object,
        replacing the relevant parameters if necessary in the lambda
        functions.

        """
        ...
    
    @property
    def func_info(self):
        """
        Returns the _FuncInfo object.

        """
        ...
    
    @property
    def function(self):
        """
        Returns the callable for the direct function.

        """
        ...
    
    @property
    def inverse(self):
        """
        Returns the callable for the inverse function.

        """
        ...
    
    @property
    def is_bounded_0_1(self):
        """
        Returns a boolean indicating if the function is bounded
        in the [0-1 interval].

        """
        ...
    
    def _get_key_params(self):
        ...
    


def _topmost_artist(artists, _cached_max=...):
    """Get the topmost artist of a list.

    In case of a tie, return the *last* of the tied artists, as it will be
    drawn on top of the others. `max` returns the first maximum in case of ties
    (on Py2 this is undocumented but true), so we need to iterate over the list
    in reverse order.
    """
    ...

def _str_equal(obj, s):
    """Return whether *obj* is a string equal to string *s*.

    This helper solely exists to handle the case where *obj* is a numpy array,
    because in such cases, a naive ``obj == s`` would yield an array, which
    cannot be used in a boolean context.
    """
    ...

def _str_lower_equal(obj, s):
    """Return whether *obj* is a string equal, when lowercased, to string *s*.

    This helper solely exists to handle the case where *obj* is a numpy array,
    because in such cases, a naive ``obj == s`` would yield an array, which
    cannot be used in a boolean context.
    """
    ...

@contextlib.contextmanager
def _setattr_cm(obj, **kwargs):
    """Temporarily set some attributes; restore original state at context exit.
    """
    ...

