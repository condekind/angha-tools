"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

"""
GUI neutral widgets
===================

Widgets that are designed to work for any of the GUI backends.
All of these widgets require you to predefine a :class:`matplotlib.axes.Axes`
instance and pass that as the first arg.  matplotlib doesn't try to
be too smart with respect to layout -- you will have to figure out how
wide and tall you want your Axes to be to accommodate your widget.
"""
class LockDraw(object):
    """
    Some widgets, like the cursor, draw onto the canvas, and this is not
    desirable under all circumstances, like when the toolbar is in
    zoom-to-rect mode and drawing a rectangle.  The module level "lock"
    allows someone to grab the lock and prevent other widgets from
    drawing.  Use ``matplotlib.widgets.lock(someobj)`` to prevent
    other widgets from drawing while you're interacting with the canvas.
    """
    def __init__(self):
        ...
    
    def __call__(self, o):
        """reserve the lock for *o*"""
        ...
    
    def release(self, o):
        """release the lock"""
        ...
    
    def available(self, o):
        """drawing is available to *o*"""
        ...
    
    def isowner(self, o):
        """Return True if *o* owns this lock"""
        ...
    
    def locked(self):
        """Return True if the lock is currently held by an owner"""
        ...
    


class Widget(object):
    """
    Abstract base class for GUI neutral widgets
    """
    drawon = ...
    eventson = ...
    _active = ...
    def set_active(self, active):
        """Set whether the widget is active.
        """
        ...
    
    def get_active(self):
        """Get whether the widget is active.
        """
        ...
    
    active = ...
    def ignore(self, event):
        """Return True if event should be ignored.

        This method (or a version of it) should be called at the beginning
        of any event callback.
        """
        ...
    


class AxesWidget(Widget):
    """Widget that is connected to a single
    :class:`~matplotlib.axes.Axes`.

    To guarantee that the widget remains responsive and not garbage-collected,
    a reference to the object should be maintained by the user.

    This is necessary because the callback registry
    maintains only weak-refs to the functions, which are member
    functions of the widget.  If there are no references to the widget
    object it may be garbage collected which will disconnect the
    callbacks.

    Attributes:

    *ax* : :class:`~matplotlib.axes.Axes`
        The parent axes for the widget
    *canvas* : :class:`~matplotlib.backend_bases.FigureCanvasBase` subclass
        The parent figure canvas for the widget.
    *active* : bool
        If False, the widget does not respond to events.
    """
    def __init__(self, ax):
        self.ax = ...
        self.canvas = ...
        self.cids = ...
    
    def connect_event(self, event, callback):
        """Connect callback with an event.

        This should be used in lieu of `figure.canvas.mpl_connect` since this
        function stores callback ids for later clean up.
        """
        ...
    
    def disconnect_events(self):
        """Disconnect all events created by this widget."""
        ...
    


class Button(AxesWidget):
    """
    A GUI neutral button.

    For the button to remain responsive you must keep a reference to it.
    Call :meth:`on_clicked` to connect to the button.

    Attributes
    ----------
    ax :
        The :class:`matplotlib.axes.Axes` the button renders into.
    label :
        A :class:`matplotlib.text.Text` instance.
    color :
        The color of the button when not hovering.
    hovercolor :
        The color of the button when hovering.
    """
    def __init__(self, ax, label, image: Optional[Any] = ..., color=..., hovercolor=...):
        """
        Parameters
        ----------
        ax : matplotlib.axes.Axes
            The :class:`matplotlib.axes.Axes` instance the button
            will be placed into.

        label : str
            The button text. Accepts string.

        image : array, mpl image, Pillow Image
            The image to place in the button, if not *None*.
            Can be any legal arg to imshow (numpy array,
            matplotlib Image instance, or Pillow Image).

        color : color
            The color of the button when not activated

        hovercolor : color
            The color of the button when the mouse is over it
        """
        self.label = ...
        self.cnt = ...
        self.observers = ...
        self.color = ...
        self.hovercolor = ...
    
    def _click(self, event):
        ...
    
    def _release(self, event):
        ...
    
    def _motion(self, event):
        ...
    
    def on_clicked(self, func):
        """
        When the button is clicked, call this *func* with event.

        A connection id is returned. It can be used to disconnect
        the button from its callback.
        """
        ...
    
    def disconnect(self, cid):
        """remove the observer with connection id *cid*"""
        ...
    


class Slider(AxesWidget):
    """
    A slider representing a floating point range.

    Create a slider from *valmin* to *valmax* in axes *ax*. For the slider to
    remain responsive you must maintain a reference to it. Call
    :meth:`on_changed` to connect to the slider event.

    Attributes
    ----------
    val : float
        Slider value.
    """
    def __init__(self, ax, label, valmin, valmax, valinit=..., valfmt=..., closedmin: bool = ..., closedmax: bool = ..., slidermin: Optional[Any] = ..., slidermax: Optional[Any] = ..., dragging: bool = ..., valstep: Optional[Any] = ..., **kwargs):
        """
        Parameters
        ----------
        ax : Axes
            The Axes to put the slider in.

        label : str
            Slider label.

        valmin : float
            The minimum value of the slider.

        valmax : float
            The maximum value of the slider.

        valinit : float, optional, default: 0.5
            The slider initial position.

        valfmt : str, optional, default: "%1.2f"
            Used to format the slider value, fprint format string.

        closedmin : bool, optional, default: True
            Indicate whether the slider interval is closed on the bottom.

        closedmax : bool, optional, default: True
            Indicate whether the slider interval is closed on the top.

        slidermin : Slider, optional, default: None
            Do not allow the current slider to have a value less than
            the value of the Slider `slidermin`.

        slidermax : Slider, optional, default: None
            Do not allow the current slider to have a value greater than
            the value of the Slider `slidermax`.

        dragging : bool, optional, default: True
            If True the slider can be dragged by the mouse.

        valstep : float, optional, default: None
            If given, the slider will snap to multiples of `valstep`.

        Notes
        -----
        Additional kwargs are passed on to ``self.poly`` which is the
        :class:`~matplotlib.patches.Rectangle` that draws the slider
        knob.  See the :class:`~matplotlib.patches.Rectangle` documentation for
        valid property names (e.g., `facecolor`, `edgecolor`, `alpha`).
        """
        self.closedmin = ...
        self.closedmax = ...
        self.slidermin = ...
        self.slidermax = ...
        self.drag_active = ...
        self.valmin = ...
        self.valmax = ...
        self.valstep = ...
        self.val = ...
        self.valinit = ...
        self.poly = ...
        self.vline = ...
        self.valfmt = ...
        self.label = ...
        self.valtext = ...
        self.cnt = ...
        self.observers = ...
    
    def _value_in_bounds(self, val):
        """ Makes sure self.val is with given bounds."""
        ...
    
    def _update(self, event):
        """update the slider position"""
        ...
    
    def set_val(self, val):
        """
        Set slider value to *val*

        Parameters
        ----------
        val : float
        """
        self.val = ...
    
    def on_changed(self, func):
        """
        When the slider value is changed call *func* with the new
        slider value

        Parameters
        ----------
        func : callable
            Function to call when slider is changed.
            The function must accept a single float as its arguments.

        Returns
        -------
        cid : int
            Connection id (which can be used to disconnect *func*)
        """
        ...
    
    def disconnect(self, cid):
        """
        Remove the observer with connection id *cid*

        Parameters
        ----------
        cid : int
            Connection id of the observer to be removed
        """
        ...
    
    def reset(self):
        """Reset the slider to the initial value"""
        ...
    


class CheckButtons(AxesWidget):
    """
    A GUI neutral set of check buttons.

    For the check buttons to remain responsive you must keep a
    reference to this object.

    The following attributes are exposed

     *ax*
        The :class:`matplotlib.axes.Axes` instance the buttons are
        located in

     *labels*
        List of :class:`matplotlib.text.Text` instances

     *lines*
        List of (line1, line2) tuples for the x's in the check boxes.
        These lines exist for each box, but have ``set_visible(False)``
        when its box is not checked.

     *rectangles*
        List of :class:`matplotlib.patches.Rectangle` instances

    Connect to the CheckButtons with the :meth:`on_clicked` method
    """
    def __init__(self, ax, labels, actives):
        """
        Add check buttons to :class:`matplotlib.axes.Axes` instance *ax*

        *labels*
            A len(buttons) list of labels as strings

        *actives*
            A len(buttons) list of booleans indicating whether
             the button is active
        """
        self.labels = ...
        self.lines = ...
        self.rectangles = ...
        self.cnt = ...
        self.observers = ...
    
    def _clicked(self, event):
        ...
    
    def set_active(self, index):
        """
        Directly (de)activate a check button by index.

        *index* is an index into the original label list
            that this object was constructed with.
            Raises ValueError if *index* is invalid.

        Callbacks will be triggered if :attr:`eventson` is True.

        """
        ...
    
    def get_status(self):
        """
        returns a tuple of the status (True/False) of all of the check buttons
        """
        ...
    
    def on_clicked(self, func):
        """
        When the button is clicked, call *func* with button label

        A connection id is returned which can be used to disconnect
        """
        ...
    
    def disconnect(self, cid):
        """remove the observer with connection id *cid*"""
        ...
    


class TextBox(AxesWidget):
    """
    A GUI neutral text input box.

    For the text box to remain responsive you must keep a reference to it.

    The following attributes are accessible:

      *ax*
        The :class:`matplotlib.axes.Axes` the button renders into.

      *label*
        A :class:`matplotlib.text.Text` instance.

      *color*
        The color of the text box when not hovering.

      *hovercolor*
        The color of the text box when hovering.

    Call :meth:`on_text_change` to be updated whenever the text changes.

    Call :meth:`on_submit` to be updated whenever the user hits enter or
    leaves the text entry field.
    """
    def __init__(self, ax, label, initial=..., color=..., hovercolor=..., label_pad=...):
        """
        Parameters
        ----------
        ax : matplotlib.axes.Axes
            The :class:`matplotlib.axes.Axes` instance the button
            will be placed into.

        label : str
            Label for this text box. Accepts string.

        initial : str
            Initial value in the text box

        color : color
            The color of the box

        hovercolor : color
            The color of the box when the mouse is over it

        label_pad : float
            the distance between the label and the right side of the textbox
        """
        self.DIST_FROM_LEFT = ...
        self.params_to_disable = ...
        self.text = ...
        self.label = ...
        self.text_disp = ...
        self.cnt = ...
        self.change_observers = ...
        self.submit_observers = ...
        self.cursor_index = ...
        self.cursor = ...
        self.color = ...
        self.hovercolor = ...
        self.capturekeystrokes = ...
    
    def _make_text_disp(self, string):
        ...
    
    def _rendercursor(self):
        self.cursor = ...
    
    def _notify_submit_observers(self):
        ...
    
    def _release(self, event):
        ...
    
    def _keypress(self, event):
        ...
    
    def set_val(self, val):
        self.text = ...
        self.text_disp = ...
    
    def _notify_change_observers(self):
        ...
    
    def begin_typing(self, x):
        self.capturekeystrokes = ...
        self.reset_params = ...
    
    def stop_typing(self):
        self.capturekeystrokes = ...
    
    def position_cursor(self, x):
        ...
    
    def _click(self, event):
        ...
    
    def _resize(self, event):
        ...
    
    def _motion(self, event):
        ...
    
    def on_text_change(self, func):
        """
        When the text changes, call this *func* with event.

        A connection id is returned which can be used to disconnect.
        """
        ...
    
    def on_submit(self, func):
        """
        When the user hits enter or leaves the submision box, call this
        *func* with event.

        A connection id is returned which can be used to disconnect.
        """
        ...
    
    def disconnect(self, cid):
        """remove the observer with connection id *cid*"""
        ...
    


class RadioButtons(AxesWidget):
    """
    A GUI neutral radio button.

    For the buttons to remain responsive
    you must keep a reference to this object.

    The following attributes are exposed:

     *ax*
        The :class:`matplotlib.axes.Axes` instance the buttons are in

     *activecolor*
        The color of the button when clicked

     *labels*
        A list of :class:`matplotlib.text.Text` instances

     *circles*
        A list of :class:`matplotlib.patches.Circle` instances

     *value_selected*
        A string listing the current value selected

    Connect to the RadioButtons with the :meth:`on_clicked` method
    """
    def __init__(self, ax, labels, active=..., activecolor=...):
        """
        Add radio buttons to :class:`matplotlib.axes.Axes` instance *ax*

        *labels*
            A len(buttons) list of labels as strings

        *active*
            The index into labels for the button that is active

        *activecolor*
            The color of the button when clicked
        """
        self.activecolor = ...
        self.value_selected = ...
        self.labels = ...
        self.circles = ...
        self.cnt = ...
        self.observers = ...
    
    def _clicked(self, event):
        ...
    
    def set_active(self, index):
        """
        Trigger which radio button to make active.

        *index* is an index into the original label list
            that this object was constructed with.
            Raise ValueError if the index is invalid.

        Callbacks will be triggered if :attr:`eventson` is True.

        """
        self.value_selected = ...
    
    def on_clicked(self, func):
        """
        When the button is clicked, call *func* with button label

        A connection id is returned which can be used to disconnect
        """
        ...
    
    def disconnect(self, cid):
        """remove the observer with connection id *cid*"""
        ...
    


class SubplotTool(Widget):
    """
    A tool to adjust the subplot params of a :class:`matplotlib.figure.Figure`.
    """
    def __init__(self, targetfig, toolfig):
        """
        *targetfig*
            The figure instance to adjust.

        *toolfig*
            The figure instance to embed the subplot tool into. If
            *None*, a default figure will be created. If you are using
            this from the GUI
        """
        self.targetfig = ...
        class toolbarfmt:
            ...
        
        
        self.axleft = ...
        self.sliderleft = ...
        self.axbottom = ...
        self.sliderbottom = ...
        self.axright = ...
        self.sliderright = ...
        self.axtop = ...
        self.slidertop = ...
        self.axwspace = ...
        self.sliderwspace = ...
        self.axhspace = ...
        self.sliderhspace = ...
        self.buttonreset = ...
    
    def funcleft(self, val):
        ...
    
    def funcright(self, val):
        ...
    
    def funcbottom(self, val):
        ...
    
    def functop(self, val):
        ...
    
    def funcwspace(self, val):
        ...
    
    def funchspace(self, val):
        ...
    


class Cursor(AxesWidget):
    """
    A horizontal and vertical line that spans the axes and moves with
    the pointer.  You can turn off the hline or vline respectively with
    the following attributes:

      *horizOn*
        Controls the visibility of the horizontal line

      *vertOn*
        Controls the visibility of the horizontal line

    and the visibility of the cursor itself with the *visible* attribute.

    For the cursor to remain responsive you must keep a reference to
    it.
    """
    def __init__(self, ax, horizOn: bool = ..., vertOn: bool = ..., useblit: bool = ..., **lineprops):
        """
        Add a cursor to *ax*.  If ``useblit=True``, use the backend-dependent
        blitting features for faster updates.  *lineprops* is a dictionary of
        line properties.
        """
        self.visible = ...
        self.horizOn = ...
        self.vertOn = ...
        self.useblit = ...
        self.lineh = ...
        self.linev = ...
        self.background = ...
        self.needclear = ...
    
    def clear(self, event):
        """clear the cursor"""
        ...
    
    def onmove(self, event):
        """on mouse motion draw the cursor if visible"""
        self.needclear = ...
    
    def _update(self):
        ...
    


class MultiCursor(Widget):
    """
    Provide a vertical (default) and/or horizontal line cursor shared between
    multiple axes.

    For the cursor to remain responsive you must keep a reference to
    it.

    Example usage::

        from matplotlib.widgets import MultiCursor
        from pylab import figure, show, np

        t = np.arange(0.0, 2.0, 0.01)
        s1 = np.sin(2*np.pi*t)
        s2 = np.sin(4*np.pi*t)
        fig = figure()
        ax1 = fig.add_subplot(211)
        ax1.plot(t, s1)


        ax2 = fig.add_subplot(212, sharex=ax1)
        ax2.plot(t, s2)

        multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1,
                            horizOn=False, vertOn=True)
        show()

    """
    def __init__(self, canvas, axes, useblit: bool = ..., horizOn: bool = ..., vertOn: bool = ..., **lineprops):
        self.canvas = ...
        self.axes = ...
        self.horizOn = ...
        self.vertOn = ...
        self.visible = ...
        self.useblit = ...
        self.background = ...
        self.needclear = ...
    
    def connect(self):
        """connect events"""
        ...
    
    def disconnect(self):
        """disconnect events"""
        ...
    
    def clear(self, event):
        """clear the cursor"""
        ...
    
    def onmove(self, event):
        self.needclear = ...
    
    def _update(self):
        ...
    


class _SelectorWidget(AxesWidget):
    def __init__(self, ax, onselect, useblit: bool = ..., button: Optional[Any] = ..., state_modifier_keys: Optional[Any] = ...):
        self.visible = ...
        self.onselect = ...
        self.useblit = ...
        self.state_modifier_keys = ...
        self.background = ...
        self.artists = ...
        self.eventpress = ...
        self.eventrelease = ...
        self.state = ...
    
    def set_active(self, active):
        ...
    
    def update_background(self, event):
        """force an update of the background"""
        ...
    
    def connect_default_events(self):
        """Connect the major canvas events to methods."""
        ...
    
    def ignore(self, event):
        """return *True* if *event* should be ignored"""
        ...
    
    def update(self):
        """draw using newfangled blit or oldfangled draw depending on
        useblit

        """
        ...
    
    def _get_data(self, event):
        """Get the xdata and ydata for event, with limits"""
        ...
    
    def _clean_event(self, event):
        """Clean up an event

        Use prev event if there is no xdata
        Limit the xdata and ydata to the axes limits
        Set the prev event
        """
        ...
    
    def press(self, event):
        """Button press handler and validator"""
        ...
    
    def _press(self, event):
        """Button press handler"""
        ...
    
    def release(self, event):
        """Button release event handler and validator"""
        ...
    
    def _release(self, event):
        """Button release event handler"""
        ...
    
    def onmove(self, event):
        """Cursor move event handler and validator"""
        ...
    
    def _onmove(self, event):
        """Cursor move event handler"""
        ...
    
    def on_scroll(self, event):
        """Mouse scroll event handler and validator"""
        ...
    
    def _on_scroll(self, event):
        """Mouse scroll event handler"""
        ...
    
    def on_key_press(self, event):
        """Key press event handler and validator for all selection widgets"""
        ...
    
    def _on_key_press(self, event):
        """Key press event handler - use for widget-specific key press actions.
        """
        ...
    
    def on_key_release(self, event):
        """Key release event handler and validator"""
        ...
    
    def _on_key_release(self, event):
        """Key release event handler"""
        ...
    
    def set_visible(self, visible):
        """ Set the visibility of our artists """
        self.visible = ...
    


class SpanSelector(_SelectorWidget):
    """
    Visually select a min/max range on a single axis and call a function with
    those values.

    To guarantee that the selector remains responsive, keep a reference to it.

    In order to turn off the SpanSelector, set `span_selector.active=False`. To
    turn it back on, set `span_selector.active=True`.

    Parameters
    ----------
    ax :  :class:`matplotlib.axes.Axes` object

    onselect : func(min, max), min/max are floats

    direction : "horizontal" or "vertical"
      The axis along which to draw the span selector

    minspan : float, default is None
     If selection is less than *minspan*, do not call *onselect*

    useblit : bool, default is False
      If True, use the backend-dependent blitting features for faster
      canvas updates.

    rectprops : dict, default is None
      Dictionary of :class:`matplotlib.patches.Patch` properties

    onmove_callback : func(min, max), min/max are floats, default is None
      Called on mouse move while the span is being selected

    span_stays : bool, default is False
      If True, the span stays visible after the mouse is released

    button : int or list of ints
      Determines which mouse buttons activate the span selector
        1 = left mouse button\n
        2 = center mouse button (scroll wheel)\n
        3 = right mouse button\n

    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> import matplotlib.widgets as mwidgets
    >>> fig, ax = plt.subplots()
    >>> ax.plot([1, 2, 3], [10, 50, 100])
    >>> def onselect(vmin, vmax):
            print(vmin, vmax)
    >>> rectprops = dict(facecolor='blue', alpha=0.5)
    >>> span = mwidgets.SpanSelector(ax, onselect, 'horizontal',
                                     rectprops=rectprops)
    >>> fig.show()

    See also: :doc:`/gallery/widgets/span_selector`

    """
    def __init__(self, ax, onselect, direction, minspan: Optional[Any] = ..., useblit: bool = ..., rectprops: Optional[Any] = ..., onmove_callback: Optional[Any] = ..., span_stays: bool = ..., button: Optional[Any] = ...):
        self.direction = ...
        self.rect = ...
        self.pressv = ...
        self.rectprops = ...
        self.onmove_callback = ...
        self.minspan = ...
        self.span_stays = ...
        self.prev = ...
        self.canvas = ...
    
    def new_axes(self, ax):
        """Set SpanSelector to operate on a new Axes"""
        self.ax = ...
        self.rect = ...
        self.artists = ...
    
    def ignore(self, event):
        """return *True* if *event* should be ignored"""
        ...
    
    def _press(self, event):
        """on button press event"""
        ...
    
    def _release(self, event):
        """on button release event"""
        self.buttonDown = ...
        self.pressv = ...
    
    def _onmove(self, event):
        """on motion notify event"""
        self.prev = ...
    


class ToolHandles(object):
    """Control handles for canvas tools.

    Parameters
    ----------
    ax : :class:`matplotlib.axes.Axes`
        Matplotlib axes where tool handles are displayed.
    x, y : 1D arrays
        Coordinates of control handles.
    marker : str
        Shape of marker used to display handle. See `matplotlib.pyplot.plot`.
    marker_props : dict
        Additional marker properties. See :class:`matplotlib.lines.Line2D`.
    """
    def __init__(self, ax, x, y, marker=..., marker_props: Optional[Any] = ..., useblit: bool = ...):
        self.ax = ...
        self.artist = ...
    
    @property
    def x(self):
        ...
    
    @property
    def y(self):
        ...
    
    def set_data(self, pts, y: Optional[Any] = ...):
        """Set x and y positions of handles"""
        ...
    
    def set_visible(self, val):
        ...
    
    def set_animated(self, val):
        ...
    
    def closest(self, x, y):
        """Return index and pixel distance to closest index."""
        ...
    


class RectangleSelector(_SelectorWidget):
    """
    Select a rectangular region of an axes.

    For the cursor to remain responsive you must keep a reference to
    it.

    Example usage::

        from matplotlib.widgets import  RectangleSelector
        from pylab import *

        def onselect(eclick, erelease):
          'eclick and erelease are matplotlib events at press and release'
          print(' startposition : (%f, %f)' % (eclick.xdata, eclick.ydata))
          print(' endposition   : (%f, %f)' % (erelease.xdata, erelease.ydata))
          print(' used button   : ', eclick.button)

        def toggle_selector(event):
            print(' Key pressed.')
            if event.key in ['Q', 'q'] and toggle_selector.RS.active:
                print(' RectangleSelector deactivated.')
                toggle_selector.RS.set_active(False)
            if event.key in ['A', 'a'] and not toggle_selector.RS.active:
                print(' RectangleSelector activated.')
                toggle_selector.RS.set_active(True)

        x = arange(100)/(99.0)
        y = sin(x)
        fig = figure
        ax = subplot(111)
        ax.plot(x,y)

        toggle_selector.RS = RectangleSelector(ax, onselect, drawtype='line')
        connect('key_press_event', toggle_selector)
        show()
    """
    _shape_klass = ...
    def __init__(self, ax, onselect, drawtype=..., minspanx: Optional[Any] = ..., minspany: Optional[Any] = ..., useblit: bool = ..., lineprops: Optional[Any] = ..., rectprops: Optional[Any] = ..., spancoords=..., button: Optional[Any] = ..., maxdist=..., marker_props: Optional[Any] = ..., interactive: bool = ..., state_modifier_keys: Optional[Any] = ...):
        """
        Create a selector in *ax*.  When a selection is made, clear
        the span and call onselect with::

          onselect(pos_1, pos_2)

        and clear the drawn box/line. The ``pos_1`` and ``pos_2`` are
        arrays of length 2 containing the x- and y-coordinate.

        If *minspanx* is not *None* then events smaller than *minspanx*
        in x direction are ignored (it's the same for y).

        The rectangle is drawn with *rectprops*; default::

          rectprops = dict(facecolor='red', edgecolor = 'black',
                           alpha=0.2, fill=True)

        The line is drawn with *lineprops*; default::

          lineprops = dict(color='black', linestyle='-',
                           linewidth = 2, alpha=0.5)

        Use *drawtype* if you want the mouse to draw a line,
        a box or nothing between click and actual position by setting

        ``drawtype = 'line'``, ``drawtype='box'`` or ``drawtype = 'none'``.
        Drawing a line would result in a line from vertex A to vertex C in
        a rectangle ABCD.

        *spancoords* is one of 'data' or 'pixels'.  If 'data', *minspanx*
        and *minspanx* will be interpreted in the same coordinates as
        the x and y axis. If 'pixels', they are in pixels.

        *button* is a list of integers indicating which mouse buttons should
        be used for rectangle selection.  You can also specify a single
        integer if only a single button is desired.  Default is *None*,
        which does not limit which button can be used.

        Note, typically:
         1 = left mouse button
         2 = center mouse button (scroll wheel)
         3 = right mouse button

        *interactive* will draw a set of handles and allow you interact
        with the widget after it is drawn.

        *state_modifier_keys* are keyboard modifiers that affect the behavior
        of the widget.

        The defaults are:
        dict(move=' ', clear='escape', square='shift', center='ctrl')

        Keyboard modifiers, which:
        'move': Move the existing shape.
        'clear': Clear the current shape.
        'square': Makes the shape square.
        'center': Make the initial point the center of the shape.
        'square' and 'center' can be combined.
        """
        self.to_draw = ...
        self.visible = ...
        self.interactive = ...
        self.minspanx = ...
        self.minspany = ...
        self.spancoords = ...
        self.drawtype = ...
        self.maxdist = ...
        self.active_handle = ...
        self.artists = ...
    
    def _press(self, event):
        """on button press event"""
        ...
    
    def _release(self, event):
        """on button release event"""
        ...
    
    def _onmove(self, event):
        """on motion notify event if box/line is wanted"""
        self.extents = ...
    
    @property
    def _rect_bbox(self):
        ...
    
    @property
    def corners(self):
        """Corners of rectangle from lower left, moving clockwise."""
        ...
    
    @property
    def edge_centers(self):
        """Midpoint of rectangle edges from left, moving clockwise."""
        ...
    
    @property
    def center(self):
        """Center of rectangle"""
        ...
    
    @property
    def extents(self):
        """Return (xmin, xmax, ymin, ymax)."""
        ...
    
    @extents.setter
    def extents(self, extents):
        ...
    
    def draw_shape(self, extents):
        ...
    
    def _set_active_handle(self, event):
        """Set active handle based on the location of the mouse event"""
        ...
    
    @property
    def geometry(self):
        """
        Returns numpy.ndarray of shape (2,5) containing
        x (``RectangleSelector.geometry[1,:]``) and
        y (``RectangleSelector.geometry[0,:]``)
        coordinates of the four corners of the rectangle starting
        and ending in the top left corner.
        """
        ...
    


class EllipseSelector(RectangleSelector):
    """
    Select an elliptical region of an axes.

    For the cursor to remain responsive you must keep a reference to
    it.

    Example usage::

        from matplotlib.widgets import  EllipseSelector
        from pylab import *

        def onselect(eclick, erelease):
          'eclick and erelease are matplotlib events at press and release'
          print(' startposition : (%f, %f)' % (eclick.xdata, eclick.ydata))
          print(' endposition   : (%f, %f)' % (erelease.xdata, erelease.ydata))
          print(' used button   : ', eclick.button)

        def toggle_selector(event):
            print(' Key pressed.')
            if event.key in ['Q', 'q'] and toggle_selector.ES.active:
                print(' EllipseSelector deactivated.')
                toggle_selector.RS.set_active(False)
            if event.key in ['A', 'a'] and not toggle_selector.ES.active:
                print(' EllipseSelector activated.')
                toggle_selector.ES.set_active(True)

        x = arange(100)/(99.0)
        y = sin(x)
        fig = figure
        ax = subplot(111)
        ax.plot(x,y)

        toggle_selector.ES = EllipseSelector(ax, onselect, drawtype='line')
        connect('key_press_event', toggle_selector)
        show()
    """
    _shape_klass = ...
    def draw_shape(self, extents):
        ...
    
    @property
    def _rect_bbox(self):
        ...
    


class LassoSelector(_SelectorWidget):
    """
    Selection curve of an arbitrary shape.

    For the selector to remain responsive you must keep a reference to it.

    The selected path can be used in conjunction with `~.Path.contains_point`
    to select data points from an image.

    In contrast to `Lasso`, `LassoSelector` is written with an interface
    similar to `RectangleSelector` and `SpanSelector`, and will continue to
    interact with the axes until disconnected.

    Example usage::

        ax = subplot(111)
        ax.plot(x,y)

        def onselect(verts):
            print(verts)
        lasso = LassoSelector(ax, onselect)

    Parameters
    ----------
    ax : :class:`~matplotlib.axes.Axes`
        The parent axes for the widget.
    onselect : function
        Whenever the lasso is released, the *onselect* function is called and
        passed the vertices of the selected path.
    button : List[Int], optional
        A list of integers indicating which mouse buttons should be used for
        rectangle selection. You can also specify a single integer if only a
        single button is desired.  Default is ``None``, which does not limit
        which button can be used.

        Note, typically:

        - 1 = left mouse button
        - 2 = center mouse button (scroll wheel)
        - 3 = right mouse button

    """
    def __init__(self, ax, onselect: Optional[Any] = ..., useblit: bool = ..., lineprops: Optional[Any] = ..., button: Optional[Any] = ...):
        self.verts = ...
        self.line = ...
        self.artists = ...
    
    def onpress(self, event):
        ...
    
    def _press(self, event):
        self.verts = ...
    
    def onrelease(self, event):
        ...
    
    def _release(self, event):
        self.verts = ...
    
    def _onmove(self, event):
        ...
    


class PolygonSelector(_SelectorWidget):
    """Select a polygon region of an axes.

    Place vertices with each mouse click, and make the selection by completing
    the polygon (clicking on the first vertex). Hold the *ctrl* key and click
    and drag a vertex to reposition it (the *ctrl* key is not necessary if the
    polygon has already been completed). Hold the *shift* key and click and
    drag anywhere in the axes to move all vertices. Press the *esc* key to
    start a new polygon.

    For the selector to remain responsive you must keep a reference to
    it.

    Parameters
    ----------
    ax : :class:`~matplotlib.axes.Axes`
        The parent axes for the widget.
    onselect : function
        When a polygon is completed or modified after completion,
        the `onselect` function is called and passed a list of the vertices as
        ``(xdata, ydata)`` tuples.
    useblit : bool, optional
    lineprops : dict, optional
        The line for the sides of the polygon is drawn with the properties
        given by `lineprops`. The default is ``dict(color='k', linestyle='-',
        linewidth=2, alpha=0.5)``.
    markerprops : dict, optional
        The markers for the vertices of the polygon are drawn with the
        properties given by `markerprops`. The default is ``dict(marker='o',
        markersize=7, mec='k', mfc='k', alpha=0.5)``.
    vertex_select_radius : float, optional
        A vertex is selected (to complete the polygon or to move a vertex)
        if the mouse click is within `vertex_select_radius` pixels of the
        vertex. The default radius is 15 pixels.

    Examples
    --------
    :doc:`/gallery/widgets/polygon_selector_demo`
    """
    def __init__(self, ax, onselect, useblit: bool = ..., lineprops: Optional[Any] = ..., markerprops: Optional[Any] = ..., vertex_select_radius=...):
        self.line = ...
        self.vertex_select_radius = ...
        self.artists = ...
    
    def _press(self, event):
        """Button press event handler"""
        ...
    
    def _release(self, event):
        """Button release event handler"""
        ...
    
    def onmove(self, event):
        """Cursor move event handler and validator"""
        ...
    
    def _onmove(self, event):
        """Cursor move event handler"""
        ...
    
    def _on_key_press(self, event):
        """Key press event handler"""
        ...
    
    def _on_key_release(self, event):
        """Key release event handler"""
        ...
    
    def _draw_polygon(self):
        """Redraw the polygon based on the new vertex positions."""
        ...
    
    @property
    def verts(self):
        """Get the polygon vertices.

        Returns
        -------
        list
            A list of the vertices of the polygon as ``(xdata, ydata)`` tuples.
        """
        ...
    


class Lasso(AxesWidget):
    """Selection curve of an arbitrary shape.

    The selected path can be used in conjunction with
    :func:`~matplotlib.path.Path.contains_point` to select data points
    from an image.

    Unlike :class:`LassoSelector`, this must be initialized with a starting
    point `xy`, and the `Lasso` events are destroyed upon release.

    Parameters
    ----------
    ax : `~matplotlib.axes.Axes`
        The parent axes for the widget.
    xy : array
        Coordinates of the start of the lasso.
    callback : callable
        Whenever the lasso is released, the `callback` function is called and
        passed the vertices of the selected path.
    """
    def __init__(self, ax, xy, callback: Optional[Any] = ..., useblit: bool = ...):
        self.useblit = ...
        self.verts = ...
        self.line = ...
        self.callback = ...
    
    def onrelease(self, event):
        self.verts = ...
    
    def onmove(self, event):
        ...
    


