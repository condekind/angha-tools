"""
This type stub file was generated by pyright.
"""

from matplotlib.transforms import Transform

class ScaleBase(object):
    """
    The base class for all scales.

    Scales are separable transformations, working on a single dimension.

    Any subclasses will want to override:

      - :attr:`name`
      - :meth:`get_transform`
      - :meth:`set_default_locators_and_formatters`

    And optionally:
      - :meth:`limit_range_for_scale`
    """
    def get_transform(self):
        """
        Return the :class:`~matplotlib.transforms.Transform` object
        associated with this scale.
        """
        ...
    
    def set_default_locators_and_formatters(self, axis):
        """
        Set the :class:`~matplotlib.ticker.Locator` and
        :class:`~matplotlib.ticker.Formatter` objects on the given
        axis to match this scale.
        """
        ...
    
    def limit_range_for_scale(self, vmin, vmax, minpos):
        """
        Returns the range *vmin*, *vmax*, possibly limited to the
        domain supported by this scale.

        *minpos* should be the minimum positive value in the data.
         This is used by log scales to determine a minimum value.
        """
        ...
    


class LinearScale(ScaleBase):
    """
    The default linear scale.
    """
    name = ...
    def __init__(self, axis, **kwargs):
        ...
    
    def set_default_locators_and_formatters(self, axis):
        """
        Set the locators and formatters to reasonable defaults for
        linear scaling.
        """
        ...
    
    def get_transform(self):
        """
        The transform for linear scaling is just the
        :class:`~matplotlib.transforms.IdentityTransform`.
        """
        ...
    


class LogTransformBase(Transform):
    input_dims = ...
    output_dims = ...
    is_separable = ...
    has_inverse = ...
    def __init__(self, nonpos=...):
        ...
    
    def transform_non_affine(self, a):
        ...
    
    def __str__(self):
        ...
    


class InvertedLogTransformBase(Transform):
    input_dims = ...
    output_dims = ...
    is_separable = ...
    has_inverse = ...
    def transform_non_affine(self, a):
        ...
    
    def __str__(self):
        ...
    


class Log10Transform(LogTransformBase):
    base = ...
    def inverted(self):
        ...
    


class InvertedLog10Transform(InvertedLogTransformBase):
    base = ...
    def inverted(self):
        ...
    


class Log2Transform(LogTransformBase):
    base = ...
    def inverted(self):
        ...
    


class InvertedLog2Transform(InvertedLogTransformBase):
    base = ...
    def inverted(self):
        ...
    


class NaturalLogTransform(LogTransformBase):
    base = ...
    def inverted(self):
        ...
    


class InvertedNaturalLogTransform(InvertedLogTransformBase):
    base = ...
    def inverted(self):
        ...
    


class LogTransform(LogTransformBase):
    def __init__(self, base, nonpos=...):
        self.base = ...
    
    def inverted(self):
        ...
    


class InvertedLogTransform(InvertedLogTransformBase):
    def __init__(self, base):
        self.base = ...
    
    def inverted(self):
        ...
    


class LogScale(ScaleBase):
    """
    A standard logarithmic scale.  Care is taken so non-positive
    values are not plotted.

    For computational efficiency (to push as much as possible to Numpy
    C code in the common cases), this scale provides different
    transforms depending on the base of the logarithm:

       - base 10 (:class:`Log10Transform`)
       - base 2 (:class:`Log2Transform`)
       - base e (:class:`NaturalLogTransform`)
       - arbitrary base (:class:`LogTransform`)
    """
    name = ...
    LogTransformBase = ...
    Log10Transform = ...
    InvertedLog10Transform = ...
    Log2Transform = ...
    InvertedLog2Transform = ...
    NaturalLogTransform = ...
    InvertedNaturalLogTransform = ...
    LogTransform = ...
    InvertedLogTransform = ...
    def __init__(self, axis, **kwargs):
        """
        *basex*/*basey*:
           The base of the logarithm

        *nonposx*/*nonposy*: ['mask' | 'clip' ]
          non-positive values in *x* or *y* can be masked as
          invalid, or clipped to a very small positive number

        *subsx*/*subsy*:
           Where to place the subticks between each major tick.
           Should be a sequence of integers.  For example, in a log10
           scale: ``[2, 3, 4, 5, 6, 7, 8, 9]``

           will place 8 logarithmically spaced minor ticks between
           each major tick.
        """
        self.base = ...
        self.subs = ...
    
    def set_default_locators_and_formatters(self, axis):
        """
        Set the locators and formatters to specialized versions for
        log scaling.
        """
        ...
    
    def get_transform(self):
        """
        Return a :class:`~matplotlib.transforms.Transform` instance
        appropriate for the given logarithm base.
        """
        ...
    
    def limit_range_for_scale(self, vmin, vmax, minpos):
        """
        Limit the domain to positive values.
        """
        ...
    


class SymmetricalLogTransform(Transform):
    input_dims = ...
    output_dims = ...
    is_separable = ...
    has_inverse = ...
    def __init__(self, base, linthresh, linscale):
        self.base = ...
        self.linthresh = ...
        self.linscale = ...
    
    def transform_non_affine(self, a):
        ...
    
    def inverted(self):
        ...
    


class InvertedSymmetricalLogTransform(Transform):
    input_dims = ...
    output_dims = ...
    is_separable = ...
    has_inverse = ...
    def __init__(self, base, linthresh, linscale):
        self.base = ...
        self.linthresh = ...
        self.invlinthresh = ...
        self.linscale = ...
    
    def transform_non_affine(self, a):
        ...
    
    def inverted(self):
        ...
    


class SymmetricalLogScale(ScaleBase):
    """
    The symmetrical logarithmic scale is logarithmic in both the
    positive and negative directions from the origin.

    Since the values close to zero tend toward infinity, there is a
    need to have a range around zero that is linear.  The parameter
    *linthresh* allows the user to specify the size of this range
    (-*linthresh*, *linthresh*).
    """
    name = ...
    SymmetricalLogTransform = ...
    InvertedSymmetricalLogTransform = ...
    def __init__(self, axis, **kwargs):
        """
        *basex*/*basey*:
           The base of the logarithm

        *linthreshx*/*linthreshy*:
          A single float which defines the range (-*x*, *x*), within
          which the plot is linear. This avoids having the plot go to
          infinity around zero.

        *subsx*/*subsy*:
           Where to place the subticks between each major tick.
           Should be a sequence of integers.  For example, in a log10
           scale: ``[2, 3, 4, 5, 6, 7, 8, 9]``

           will place 8 logarithmically spaced minor ticks between
           each major tick.

        *linscalex*/*linscaley*:
           This allows the linear range (-*linthresh* to *linthresh*)
           to be stretched relative to the logarithmic range.  Its
           value is the number of decades to use for each half of the
           linear range.  For example, when *linscale* == 1.0 (the
           default), the space used for the positive and negative
           halves of the linear range will be equal to one decade in
           the logarithmic range.
        """
        self.base = ...
        self.linthresh = ...
        self.linscale = ...
        self.subs = ...
    
    def set_default_locators_and_formatters(self, axis):
        """
        Set the locators and formatters to specialized versions for
        symmetrical log scaling.
        """
        ...
    
    def get_transform(self):
        """
        Return a :class:`SymmetricalLogTransform` instance.
        """
        ...
    


class LogitTransform(Transform):
    input_dims = ...
    output_dims = ...
    is_separable = ...
    has_inverse = ...
    def __init__(self, nonpos=...):
        ...
    
    def transform_non_affine(self, a):
        """logit transform (base 10), masked or clipped"""
        ...
    
    def inverted(self):
        ...
    
    def __str__(self):
        ...
    


class LogisticTransform(Transform):
    input_dims = ...
    output_dims = ...
    is_separable = ...
    has_inverse = ...
    def __init__(self, nonpos=...):
        ...
    
    def transform_non_affine(self, a):
        """logistic transform (base 10)"""
        ...
    
    def inverted(self):
        ...
    
    def __str__(self):
        ...
    


class LogitScale(ScaleBase):
    """
    Logit scale for data between zero and one, both excluded.

    This scale is similar to a log scale close to zero and to one, and almost
    linear around 0.5. It maps the interval ]0, 1[ onto ]-infty, +infty[.
    """
    name = ...
    def __init__(self, axis, nonpos=...):
        """
        *nonpos*: ['mask' | 'clip' ]
          values beyond ]0, 1[ can be masked as invalid, or clipped to a number
          very close to 0 or 1
        """
        ...
    
    def get_transform(self):
        """
        Return a :class:`LogitTransform` instance.
        """
        ...
    
    def set_default_locators_and_formatters(self, axis):
        ...
    
    def limit_range_for_scale(self, vmin, vmax, minpos):
        """
        Limit the domain to values between 0 and 1 (excluded).
        """
        ...
    


_scale_mapping = { 'linear': LinearScale,'log': LogScale,'symlog': SymmetricalLogScale,'logit': LogitScale }
def get_scale_names():
    ...

def scale_factory(scale, axis, **kwargs):
    """
    Return a scale class by name.

    ACCEPTS: [ %(names)s ]
    """
    ...

def register_scale(scale_class):
    """
    Register a new kind of scale.

    *scale_class* must be a subclass of :class:`ScaleBase`.
    """
    ...

def get_scale_docs():
    """
    Helper function for generating docstrings related to scales.
    """
    ...

