"""
This type stub file was generated by pyright.
"""

import six
from typing import Any, Optional

"""
matplotlib includes a framework for arbitrary geometric
transformations that is used determine the final position of all
elements drawn on the canvas.

Transforms are composed into trees of :class:`TransformNode` objects
whose actual value depends on their children.  When the contents of
children change, their parents are automatically invalidated.  The
next time an invalidated transform is accessed, it is recomputed to
reflect those changes.  This invalidation/caching approach prevents
unnecessary recomputations of transforms, and contributes to better
interactive performance.

For example, here is a graph of the transform tree used to plot data
to the graph:

.. image:: ../_static/transforms.png

The framework can be used for both affine and non-affine
transformations.  However, for speed, we want use the backend
renderers to perform affine transformations whenever possible.
Therefore, it is possible to perform just the affine or non-affine
part of a transformation on a set of data.  The affine is always
assumed to occur after the non-affine.  For any transform::

  full transform == non-affine part + affine part

The backends are not expected to handle non-affine transformations
themselves.
"""
DEBUG = False
def _indent_str(obj):
    ...

class TransformNode(object):
    """
    :class:`TransformNode` is the base class for anything that
    participates in the transform tree and needs to invalidate its
    parents or be invalidated.  This includes classes that are not
    really transforms, such as bounding boxes, since some transforms
    depend on bounding boxes to compute their values.
    """
    _gid = ...
    INVALID_NON_AFFINE = ...
    INVALID_AFFINE = ...
    INVALID = ...
    is_affine = ...
    is_bbox = ...
    pass_through = ...
    def __init__(self, shorthand_name: Optional[Any] = ...):
        """
        Creates a new :class:`TransformNode`.

        Parameters
        ----------
        shorthand_name : str
            A string representing the "name" of the transform. The name carries
            no significance other than to improve the readability of
            ``str(transform)`` when DEBUG=True.
        """
        ...
    
    if DEBUG:
        def __str__(self):
            ...
        
    def __getstate__(self):
        ...
    
    def __setstate__(self, data_dict):
        self.__dict__ = ...
    
    def __copy__(self, *args):
        ...
    
    __deepcopy__ = ...
    def invalidate(self):
        """
        Invalidate this :class:`TransformNode` and triggers an
        invalidation of its ancestors.  Should be called any
        time the transform changes.
        """
        ...
    
    def _invalidate_internal(self, value, invalidating_node):
        """
        Called by :meth:`invalidate` and subsequently ascends the transform
        stack calling each TransformNode's _invalidate_internal method.
        """
        ...
    
    def set_children(self, *children):
        """
        Set the children of the transform, to let the invalidation
        system know which transforms can invalidate this transform.
        Should be called from the constructor of any transforms that
        depend on other transforms.
        """
        ...
    
    if DEBUG:
        _set_children = ...
        def set_children(self, *children):
            ...
        
    def frozen(self):
        """
        Returns a frozen copy of this transform node.  The frozen copy
        will not update when its children change.  Useful for storing
        a previously known state of a transform where
        ``copy.deepcopy()`` might normally be used.
        """
        ...
    
    if DEBUG:
        def write_graphviz(self, fobj, highlight=...):
            """
            For debugging purposes.

            Writes the transform tree rooted at 'self' to a graphviz "dot"
            format file.  This file can be run through the "dot" utility
            to produce a graph of the transform tree.

            Affine transforms are marked in blue.  Bounding boxes are
            marked in yellow.

            *fobj*: A Python file-like object

            Once the "dot" file has been created, it can be turned into a
            png easily with::

                $> dot -Tpng -o $OUTPUT_FILE $DOT_FILE

            """
            ...
        


class BboxBase(TransformNode):
    """
    This is the base class of all bounding boxes, and provides
    read-only access to its data.  A mutable bounding box is provided
    by the :class:`Bbox` class.

    The canonical representation is as two points, with no
    restrictions on their ordering.  Convenience properties are
    provided to get the left, bottom, right and top edges and width
    and height, but these are not stored explicitly.
    """
    is_bbox = ...
    is_affine = ...
    if DEBUG:
        def _check(points):
            ...
        
        _check = ...
    def frozen(self):
        ...
    
    def __array__(self, *args, **kwargs):
        ...
    
    def is_unit(self):
        """
        Returns True if the :class:`Bbox` is the unit bounding box
        from (0, 0) to (1, 1).
        """
        ...
    
    @property
    def x0(self):
        """
        :attr:`x0` is the first of the pair of *x* coordinates that
        define the bounding box. :attr:`x0` is not guaranteed to be less than
        :attr:`x1`.  If you require that, use :attr:`xmin`.
        """
        ...
    
    @property
    def y0(self):
        """
        :attr:`y0` is the first of the pair of *y* coordinates that
        define the bounding box. :attr:`y0` is not guaranteed to be less than
        :attr:`y1`.  If you require that, use :attr:`ymin`.
        """
        ...
    
    @property
    def x1(self):
        """
        :attr:`x1` is the second of the pair of *x* coordinates that
        define the bounding box. :attr:`x1` is not guaranteed to be greater
        than :attr:`x0`.  If you require that, use :attr:`xmax`.
        """
        ...
    
    @property
    def y1(self):
        """
        :attr:`y1` is the second of the pair of *y* coordinates that
        define the bounding box. :attr:`y1` is not guaranteed to be greater
        than :attr:`y0`.  If you require that, use :attr:`ymax`.
        """
        ...
    
    @property
    def p0(self):
        """
        :attr:`p0` is the first pair of (*x*, *y*) coordinates that
        define the bounding box.  It is not guaranteed to be the bottom-left
        corner.  For that, use :attr:`min`.
        """
        ...
    
    @property
    def p1(self):
        """
        :attr:`p1` is the second pair of (*x*, *y*) coordinates that
        define the bounding box.  It is not guaranteed to be the top-right
        corner.  For that, use :attr:`max`.
        """
        ...
    
    @property
    def xmin(self):
        """
        :attr:`xmin` is the left edge of the bounding box.
        """
        ...
    
    @property
    def ymin(self):
        """
        :attr:`ymin` is the bottom edge of the bounding box.
        """
        ...
    
    @property
    def xmax(self):
        """
        :attr:`xmax` is the right edge of the bounding box.
        """
        ...
    
    @property
    def ymax(self):
        """
        :attr:`ymax` is the top edge of the bounding box.
        """
        ...
    
    @property
    def min(self):
        """
        :attr:`min` is the bottom-left corner of the bounding box.
        """
        ...
    
    @property
    def max(self):
        """
        :attr:`max` is the top-right corner of the bounding box.
        """
        ...
    
    @property
    def intervalx(self):
        """
        :attr:`intervalx` is the pair of *x* coordinates that define
        the bounding box. It is not guaranteed to be sorted from left to right.
        """
        ...
    
    @property
    def intervaly(self):
        """
        :attr:`intervaly` is the pair of *y* coordinates that define
        the bounding box.  It is not guaranteed to be sorted from bottom to
        top.
        """
        ...
    
    @property
    def width(self):
        """
        The width of the bounding box.  It may be negative if
        :attr:`x1` < :attr:`x0`.
        """
        ...
    
    @property
    def height(self):
        """
        The height of the bounding box.  It may be negative if
        :attr:`y1` < :attr:`y0`.
        """
        ...
    
    @property
    def size(self):
        """
        The width and height of the bounding box.  May be negative,
        in the same way as :attr:`width` and :attr:`height`.
        """
        ...
    
    @property
    def bounds(self):
        """
        Returns (:attr:`x0`, :attr:`y0`, :attr:`width`,
        :attr:`height`).
        """
        ...
    
    @property
    def extents(self):
        """
        Returns (:attr:`x0`, :attr:`y0`, :attr:`x1`,
        :attr:`y1`).
        """
        ...
    
    def get_points(self):
        ...
    
    def containsx(self, x):
        """
        Returns whether *x* is in the closed (:attr:`x0`, :attr:`x1`) interval.
        """
        ...
    
    def containsy(self, y):
        """
        Returns whether *y* is in the closed (:attr:`y0`, :attr:`y1`) interval.
        """
        ...
    
    def contains(self, x, y):
        """
        Returns whether ``(x, y)`` is in the bounding box or on its edge.
        """
        ...
    
    def overlaps(self, other):
        """
        Returns whether this bounding box overlaps with the other bounding box.

        Parameters
        ----------
        other : BboxBase
        """
        ...
    
    def fully_containsx(self, x):
        """
        Returns whether *x* is in the open (:attr:`x0`, :attr:`x1`) interval.
        """
        ...
    
    def fully_containsy(self, y):
        """
        Returns whether *y* is in the open (:attr:`y0`, :attr:`y1`) interval.
        """
        ...
    
    def fully_contains(self, x, y):
        """
        Returns whether ``x, y`` is in the bounding box, but not on its edge.
        """
        ...
    
    def fully_overlaps(self, other):
        """
        Returns whether this bounding box overlaps with the other bounding box,
        not including the edges.

        Parameters
        ----------
        other : BboxBase
        """
        ...
    
    def transformed(self, transform):
        """
        Return a new :class:`Bbox` object, statically transformed by
        the given transform.
        """
        ...
    
    def inverse_transformed(self, transform):
        """
        Return a new :class:`Bbox` object, statically transformed by
        the inverse of the given transform.
        """
        ...
    
    coefs = ...
    def anchored(self, c, container: Optional[Any] = ...):
        """
        Return a copy of the :class:`Bbox`, shifted to position *c*
        within a container.

        Parameters
        ----------
        c :
            May be either:

            * A sequence (*cx*, *cy*) where *cx* and *cy* range from 0
              to 1, where 0 is left or bottom and 1 is right or top

            * a string:
              - 'C' for centered
              - 'S' for bottom-center
              - 'SE' for bottom-left
              - 'E' for left
              - etc.

        container : Bbox, optional
            The box within which the :class:`Bbox` is positioned; it defaults
            to the initial :class:`Bbox`.
        """
        ...
    
    def shrunk(self, mx, my):
        """
        Return a copy of the :class:`Bbox`, shrunk by the factor *mx*
        in the *x* direction and the factor *my* in the *y* direction.
        The lower left corner of the box remains unchanged.  Normally
        *mx* and *my* will be less than 1, but this is not enforced.
        """
        ...
    
    def shrunk_to_aspect(self, box_aspect, container: Optional[Any] = ..., fig_aspect=...):
        """
        Return a copy of the :class:`Bbox`, shrunk so that it is as
        large as it can be while having the desired aspect ratio,
        *box_aspect*.  If the box coordinates are relative---that
        is, fractions of a larger box such as a figure---then the
        physical aspect ratio of that figure is specified with
        *fig_aspect*, so that *box_aspect* can also be given as a
        ratio of the absolute dimensions, not the relative dimensions.
        """
        ...
    
    def splitx(self, *args):
        """
        e.g., ``bbox.splitx(f1, f2, ...)``

        Returns a list of new :class:`Bbox` objects formed by
        splitting the original one with vertical lines at fractional
        positions *f1*, *f2*, ...
        """
        ...
    
    def splity(self, *args):
        """
        e.g., ``bbox.splitx(f1, f2, ...)``

        Returns a list of new :class:`Bbox` objects formed by
        splitting the original one with horizontal lines at fractional
        positions *f1*, *f2*, ...
        """
        ...
    
    def count_contains(self, vertices):
        """
        Count the number of vertices contained in the :class:`Bbox`.
        Any vertices with a non-finite x or y value are ignored.

        Parameters
        ----------
        vertices : Nx2 Numpy array.
        """
        ...
    
    def count_overlaps(self, bboxes):
        """
        Count the number of bounding boxes that overlap this one.

        Parameters
        ----------
        bboxes : sequence of :class:`BboxBase` objects
        """
        ...
    
    def expanded(self, sw, sh):
        """
        Return a new :class:`Bbox` which is this :class:`Bbox`
        expanded around its center by the given factors *sw* and
        *sh*.
        """
        ...
    
    def padded(self, p):
        """
        Return a new :class:`Bbox` that is padded on all four sides by
        the given value.
        """
        ...
    
    def translated(self, tx, ty):
        """
        Return a copy of the :class:`Bbox`, statically translated by
        *tx* and *ty*.
        """
        ...
    
    def corners(self):
        """
        Return an array of points which are the four corners of this
        rectangle.  For example, if this :class:`Bbox` is defined by
        the points (*a*, *b*) and (*c*, *d*), :meth:`corners` returns
        (*a*, *b*), (*a*, *d*), (*c*, *b*) and (*c*, *d*).
        """
        ...
    
    def rotated(self, radians):
        """
        Return a new bounding box that bounds a rotated version of
        this bounding box by the given radians.  The new bounding box
        is still aligned with the axes, of course.
        """
        ...
    
    @staticmethod
    def union(bboxes):
        """
        Return a :class:`Bbox` that contains all of the given bboxes.
        """
        ...
    
    @staticmethod
    def intersection(bbox1, bbox2):
        """
        Return the intersection of the two bboxes or None
        if they do not intersect.
        """
        ...
    


class Bbox(BboxBase):
    """
    A mutable bounding box.
    """
    def __init__(self, points, **kwargs):
        """
        Parameters
        ----------
        points : ndarray
            A 2x2 numpy array of the form ``[[x0, y0], [x1, y1]]``.

        Notes
        -----
        If you need to create a :class:`Bbox` object from another form
        of data, consider the static methods :meth:`unit`,
        :meth:`from_bounds` and :meth:`from_extents`.
        """
        ...
    
    if DEBUG:
        ___init__ = ...
        def __init__(self, points, **kwargs):
            ...
        
        def invalidate(self):
            ...
        
    @staticmethod
    def unit():
        """
        (staticmethod) Create a new unit :class:`Bbox` from (0, 0) to
        (1, 1).
        """
        ...
    
    @staticmethod
    def null():
        """
        (staticmethod) Create a new null :class:`Bbox` from (inf, inf) to
        (-inf, -inf).
        """
        ...
    
    @staticmethod
    def from_bounds(x0, y0, width, height):
        """
        (staticmethod) Create a new :class:`Bbox` from *x0*, *y0*,
        *width* and *height*.

        *width* and *height* may be negative.
        """
        ...
    
    @staticmethod
    def from_extents(*args):
        """
        (staticmethod) Create a new Bbox from *left*, *bottom*,
        *right* and *top*.

        The *y*-axis increases upwards.
        """
        ...
    
    def __format__(self, fmt):
        ...
    
    def __str__(self):
        ...
    
    def __repr__(self):
        ...
    
    def ignore(self, value):
        """
        Set whether the existing bounds of the box should be ignored
        by subsequent calls to :meth:`update_from_data_xy`.

        value : bool
           - When ``True``, subsequent calls to :meth:`update_from_data_xy`
             will ignore the existing bounds of the :class:`Bbox`.

           - When ``False``, subsequent calls to :meth:`update_from_data_xy`
             will include the existing bounds of the :class:`Bbox`.
        """
        ...
    
    def update_from_path(self, path, ignore: Optional[Any] = ..., updatex: bool = ..., updatey: bool = ...):
        """
        Update the bounds of the :class:`Bbox` based on the passed in
        data.  After updating, the bounds will have positive *width*
        and *height*; *x0* and *y0* will be the minimal values.

        Parameters
        ----------
        path : :class:`~matplotlib.path.Path`

        ignore : bool, optional
           - when ``True``, ignore the existing bounds of the :class:`Bbox`.
           - when ``False``, include the existing bounds of the :class:`Bbox`.
           - when ``None``, use the last value passed to :meth:`ignore`.

        updatex, updatey : bool, optional
            When ``True``, update the x/y values.
        """
        ...
    
    def update_from_data_xy(self, xy, ignore: Optional[Any] = ..., updatex: bool = ..., updatey: bool = ...):
        """
        Update the bounds of the :class:`Bbox` based on the passed in
        data.  After updating, the bounds will have positive *width*
        and *height*; *x0* and *y0* will be the minimal values.

        Parameters
        ----------
        xy : ndarray
            A numpy array of 2D points.

        ignore : bool, optional
           - When ``True``, ignore the existing bounds of the :class:`Bbox`.
           - When ``False``, include the existing bounds of the :class:`Bbox`.
           - When ``None``, use the last value passed to :meth:`ignore`.

        updatex, updatey : bool, optional
            When ``True``, update the x/y values.
        """
        ...
    
    @BboxBase.x0.setter
    def x0(self, val):
        ...
    
    @BboxBase.y0.setter
    def y0(self, val):
        ...
    
    @BboxBase.x1.setter
    def x1(self, val):
        ...
    
    @BboxBase.y1.setter
    def y1(self, val):
        ...
    
    @BboxBase.p0.setter
    def p0(self, val):
        ...
    
    @BboxBase.p1.setter
    def p1(self, val):
        ...
    
    @BboxBase.intervalx.setter
    def intervalx(self, interval):
        ...
    
    @BboxBase.intervaly.setter
    def intervaly(self, interval):
        ...
    
    @BboxBase.bounds.setter
    def bounds(self, bounds):
        ...
    
    @property
    def minpos(self):
        ...
    
    @property
    def minposx(self):
        ...
    
    @property
    def minposy(self):
        ...
    
    def get_points(self):
        """
        Get the points of the bounding box directly as a numpy array
        of the form: ``[[x0, y0], [x1, y1]]``.
        """
        ...
    
    def set_points(self, points):
        """
        Set the points of the bounding box directly from a numpy array
        of the form: ``[[x0, y0], [x1, y1]]``.  No error checking is
        performed, as this method is mainly for internal use.
        """
        ...
    
    def set(self, other):
        """
        Set this bounding box from the "frozen" bounds of another
        :class:`Bbox`.
        """
        ...
    
    def mutated(self):
        'Return whether the bbox has changed since init.'
        ...
    
    def mutatedx(self):
        'Return whether the x-limits have changed since init.'
        ...
    
    def mutatedy(self):
        'Return whether the y-limits have changed since init.'
        ...
    


class TransformedBbox(BboxBase):
    """
    A :class:`Bbox` that is automatically transformed by a given
    transform.  When either the child bounding box or transform
    changes, the bounds of this bbox will update accordingly.
    """
    def __init__(self, bbox, transform, **kwargs):
        """
        Parameters
        ----------
        bbox : :class:`Bbox`

        transform : :class:`Transform`
        """
        ...
    
    def __str__(self):
        ...
    
    def get_points(self):
        ...
    
    if DEBUG:
        _get_points = ...
        def get_points(self):
            ...
        


class LockableBbox(BboxBase):
    """
    A :class:`Bbox` where some elements may be locked at certain values.

    When the child bounding box changes, the bounds of this bbox will update
    accordingly with the exception of the locked elements.
    """
    def __init__(self, bbox, x0: Optional[Any] = ..., y0: Optional[Any] = ..., x1: Optional[Any] = ..., y1: Optional[Any] = ..., **kwargs):
        """
        Parameters
        ----------
        bbox : Bbox
            The child bounding box to wrap.

        x0 : float or None
            The locked value for x0, or None to leave unlocked.

        y0 : float or None
            The locked value for y0, or None to leave unlocked.

        x1 : float or None
            The locked value for x1, or None to leave unlocked.

        y1 : float or None
            The locked value for y1, or None to leave unlocked.

        """
        ...
    
    def __str__(self):
        ...
    
    def get_points(self):
        ...
    
    if DEBUG:
        _get_points = ...
        def get_points(self):
            ...
        
    @property
    def locked_x0(self):
        """
        float or None: The value used for the locked x0.
        """
        ...
    
    @locked_x0.setter
    def locked_x0(self, x0):
        ...
    
    @property
    def locked_y0(self):
        """
        float or None: The value used for the locked y0.
        """
        ...
    
    @locked_y0.setter
    def locked_y0(self, y0):
        ...
    
    @property
    def locked_x1(self):
        """
        float or None: The value used for the locked x1.
        """
        ...
    
    @locked_x1.setter
    def locked_x1(self, x1):
        ...
    
    @property
    def locked_y1(self):
        """
        float or None: The value used for the locked y1.
        """
        ...
    
    @locked_y1.setter
    def locked_y1(self, y1):
        ...
    


class Transform(TransformNode):
    """
    The base class of all :class:`TransformNode` instances that
    actually perform a transformation.

    All non-affine transformations should be subclasses of this class.
    New affine transformations should be subclasses of
    :class:`Affine2D`.

    Subclasses of this class should override the following members (at
    minimum):

      - :attr:`input_dims`
      - :attr:`output_dims`
      - :meth:`transform`
      - :attr:`is_separable`
      - :attr:`has_inverse`
      - :meth:`inverted` (if :attr:`has_inverse` is True)

    If the transform needs to do something non-standard with
    :class:`matplotlib.path.Path` objects, such as adding curves
    where there were once line segments, it should override:

      - :meth:`transform_path`
    """
    input_dims = ...
    output_dims = ...
    has_inverse = ...
    is_separable = ...
    def __add__(self, other):
        """
        Composes two transforms together such that *self* is followed
        by *other*.
        """
        ...
    
    def __radd__(self, other):
        """
        Composes two transforms together such that *self* is followed
        by *other*.
        """
        ...
    
    if six.PY2:
        def __ne__(self, other):
            ...
        
    def _iter_break_from_left_to_right(self):
        """
        Returns an iterator breaking down this transform stack from left to
        right recursively. If self == ((A, N), A) then the result will be an
        iterator which yields I : ((A, N), A), followed by A : (N, A),
        followed by (A, N) : (A), but not ((A, N), A) : I.

        This is equivalent to flattening the stack then yielding
        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).

        """
        ...
    
    @property
    def depth(self):
        """
        Returns the number of transforms which have been chained
        together to form this Transform instance.

        .. note::

            For the special case of a Composite transform, the maximum depth
            of the two is returned.

        """
        ...
    
    def contains_branch(self, other):
        """
        Return whether the given transform is a sub-tree of this transform.

        This routine uses transform equality to identify sub-trees, therefore
        in many situations it is object id which will be used.

        For the case where the given transform represents the whole
        of this transform, returns True.

        """
        ...
    
    def contains_branch_seperately(self, other_transform):
        """
        Returns whether the given branch is a sub-tree of this transform on
        each separate dimension.

        A common use for this method is to identify if a transform is a blended
        transform containing an axes' data transform. e.g.::

            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)

        """
        ...
    
    def __sub__(self, other):
        """
        Returns a transform stack which goes all the way down self's transform
        stack, and then ascends back up other's stack. If it can, this is
        optimised::

            # normally
            A - B == a + b.inverted()

            # sometimes, when A contains the tree B there is no need to
            # descend all the way down to the base of A (via B), instead we
            # can just stop at B.

            (A + B) - (B)^-1 == A

            # similarly, when B contains tree A, we can avoid decending A at
            # all, basically:
            A - (A + B) == ((B + A) - A).inverted() or B^-1

        For clarity, the result of ``(A + B) - B + B == (A + B)``.

        """
        ...
    
    def __array__(self, *args, **kwargs):
        """
        Array interface to get at this Transform's affine matrix.
        """
        ...
    
    def transform(self, values):
        """
        Performs the transformation on the given array of values.

        Accepts a numpy array of shape (N x :attr:`input_dims`) and
        returns a numpy array of shape (N x :attr:`output_dims`).

        Alternatively, accepts a numpy array of length :attr:`input_dims`
        and returns a numpy array of length :attr:`output_dims`.
        """
        ...
    
    def transform_affine(self, values):
        """
        Performs only the affine part of this transformation on the
        given array of values.

        ``transform(values)`` is always equivalent to
        ``transform_affine(transform_non_affine(values))``.

        In non-affine transformations, this is generally a no-op.  In
        affine transformations, this is equivalent to
        ``transform(values)``.

        Accepts a numpy array of shape (N x :attr:`input_dims`) and
        returns a numpy array of shape (N x :attr:`output_dims`).

        Alternatively, accepts a numpy array of length :attr:`input_dims`
        and returns a numpy array of length :attr:`output_dims`.
        """
        ...
    
    def transform_non_affine(self, values):
        """
        Performs only the non-affine part of the transformation.

        ``transform(values)`` is always equivalent to
        ``transform_affine(transform_non_affine(values))``.

        In non-affine transformations, this is generally equivalent to
        ``transform(values)``.  In affine transformations, this is
        always a no-op.

        Accepts a numpy array of shape (N x :attr:`input_dims`) and
        returns a numpy array of shape (N x :attr:`output_dims`).

        Alternatively, accepts a numpy array of length :attr:`input_dims`
        and returns a numpy array of length :attr:`output_dims`.
        """
        ...
    
    def transform_bbox(self, bbox):
        """
        Transform the given bounding box.

        Note, for smarter transforms including caching (a common
        requirement for matplotlib figures), see :class:`TransformedBbox`.
        """
        ...
    
    def get_affine(self):
        """
        Get the affine part of this transform.
        """
        ...
    
    def get_matrix(self):
        """
        Get the Affine transformation array for the affine part
        of this transform.

        """
        ...
    
    def transform_point(self, point):
        """
        A convenience function that returns the transformed copy of a
        single point.

        The point is given as a sequence of length :attr:`input_dims`.
        The transformed point is returned as a sequence of length
        :attr:`output_dims`.
        """
        ...
    
    def transform_path(self, path):
        """
        Returns a transformed path.

        *path*: a :class:`~matplotlib.path.Path` instance.

        In some cases, this transform may insert curves into the path
        that began as line segments.
        """
        ...
    
    def transform_path_affine(self, path):
        """
        Returns a path, transformed only by the affine part of
        this transform.

        *path*: a :class:`~matplotlib.path.Path` instance.

        ``transform_path(path)`` is equivalent to
        ``transform_path_affine(transform_path_non_affine(values))``.
        """
        ...
    
    def transform_path_non_affine(self, path):
        """
        Returns a path, transformed only by the non-affine
        part of this transform.

        *path*: a :class:`~matplotlib.path.Path` instance.

        ``transform_path(path)`` is equivalent to
        ``transform_path_affine(transform_path_non_affine(values))``.
        """
        ...
    
    def transform_angles(self, angles, pts, radians: bool = ..., pushoff=...):
        """
        Performs transformation on a set of angles anchored at
        specific locations.

        The *angles* must be a column vector (i.e., numpy array).

        The *pts* must be a two-column numpy array of x,y positions
        (angle transforms currently only work in 2D).  This array must
        have the same number of rows as *angles*.

        *radians* indicates whether or not input angles are given in
         radians (True) or degrees (False; the default).

        *pushoff* is the distance to move away from *pts* for
         determining transformed angles (see discussion of method
         below).

        The transformed angles are returned in an array with the same
        size as *angles*.

        The generic version of this method uses a very generic
        algorithm that transforms *pts*, as well as locations very
        close to *pts*, to find the angle in the transformed system.
        """
        ...
    
    def inverted(self):
        """
        Return the corresponding inverse transformation.

        The return value of this method should be treated as
        temporary.  An update to *self* does not cause a corresponding
        update to its inverted copy.

        ``x === self.inverted().transform(self.transform(x))``
        """
        ...
    


class TransformWrapper(Transform):
    """
    A helper class that holds a single child transform and acts
    equivalently to it.

    This is useful if a node of the transform tree must be replaced at
    run time with a transform of a different type.  This class allows
    that replacement to correctly trigger invalidation.

    Note that :class:`TransformWrapper` instances must have the same
    input and output dimensions during their entire lifetime, so the
    child transform may only be replaced with another child transform
    of the same dimensions.
    """
    pass_through = ...
    def __init__(self, child):
        """
        *child*: A class:`Transform` instance.  This child may later
        be replaced with :meth:`set`.
        """
        ...
    
    def _init(self, child):
        self.input_dims = ...
        self.output_dims = ...
    
    def __eq__(self, other):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        self.input_dims = ...
        self.output_dims = ...
    
    def __str__(self):
        ...
    
    def frozen(self):
        ...
    
    def _set(self, child):
        self.transform = ...
        self.transform_affine = ...
        self.transform_non_affine = ...
        self.transform_path = ...
        self.transform_path_affine = ...
        self.transform_path_non_affine = ...
        self.get_affine = ...
        self.inverted = ...
        self.get_matrix = ...
    
    def set(self, child):
        """
        Replace the current child of this transform with another one.

        The new child must have the same number of input and output
        dimensions as the current child.
        """
        ...
    
    def _get_is_affine(self):
        ...
    
    is_affine = ...
    def _get_is_separable(self):
        ...
    
    is_separable = ...
    def _get_has_inverse(self):
        ...
    
    has_inverse = ...


class AffineBase(Transform):
    """
    The base class of all affine transformations of any number of
    dimensions.
    """
    is_affine = ...
    def __init__(self, *args, **kwargs):
        ...
    
    def __array__(self, *args, **kwargs):
        ...
    
    @staticmethod
    def _concat(a, b):
        """
        Concatenates two transformation matrices (represented as numpy
        arrays) together.
        """
        ...
    
    def __eq__(self, other):
        ...
    
    def transform(self, values):
        ...
    
    def transform_affine(self, values):
        ...
    
    def transform_non_affine(self, points):
        ...
    
    def transform_path(self, path):
        ...
    
    def transform_path_affine(self, path):
        ...
    
    def transform_path_non_affine(self, path):
        ...
    
    def get_affine(self):
        ...
    


class Affine2DBase(AffineBase):
    """
    The base class of all 2D affine transformations.

    2D affine transformations are performed using a 3x3 numpy array::

        a c e
        b d f
        0 0 1

    This class provides the read-only interface.  For a mutable 2D
    affine transformation, use :class:`Affine2D`.

    Subclasses of this class will generally only need to override a
    constructor and :meth:`get_matrix` that generates a custom 3x3 matrix.
    """
    has_inverse = ...
    input_dims = ...
    output_dims = ...
    def frozen(self):
        ...
    
    def _get_is_separable(self):
        ...
    
    is_separable = ...
    def to_values(self):
        """
        Return the values of the matrix as a sequence (a,b,c,d,e,f)
        """
        ...
    
    @staticmethod
    def matrix_from_values(a, b, c, d, e, f):
        """
        (staticmethod) Create a new transformation matrix as a 3x3
        numpy array of the form::

          a c e
          b d f
          0 0 1
        """
        ...
    
    def transform_affine(self, points):
        ...
    
    def transform_point(self, point):
        ...
    
    if DEBUG:
        _transform_affine = ...
        def transform_affine(self, points):
            ...
        
    def inverted(self):
        ...
    


class Affine2D(Affine2DBase):
    """
    A mutable 2D affine transformation.
    """
    def __init__(self, matrix: Optional[Any] = ..., **kwargs):
        """
        Initialize an Affine transform from a 3x3 numpy float array::

          a c e
          b d f
          0 0 1

        If *matrix* is None, initialize with the identity transform.
        """
        ...
    
    def __str__(self):
        ...
    
    @staticmethod
    def from_values(a, b, c, d, e, f):
        """
        (staticmethod) Create a new Affine2D instance from the given
        values::

          a c e
          b d f
          0 0 1

        .
        """
        ...
    
    def get_matrix(self):
        """
        Get the underlying transformation matrix as a 3x3 numpy array::

          a c e
          b d f
          0 0 1

        .
        """
        ...
    
    def set_matrix(self, mtx):
        """
        Set the underlying transformation matrix from a 3x3 numpy array::

          a c e
          b d f
          0 0 1

        .
        """
        ...
    
    def set(self, other):
        """
        Set this transformation from the frozen copy of another
        :class:`Affine2DBase` object.
        """
        ...
    
    @staticmethod
    def identity():
        """
        (staticmethod) Return a new :class:`Affine2D` object that is
        the identity transform.

        Unless this transform will be mutated later on, consider using
        the faster :class:`IdentityTransform` class instead.
        """
        ...
    
    def clear(self):
        """
        Reset the underlying matrix to the identity transform.
        """
        ...
    
    def rotate(self, theta):
        """
        Add a rotation (in radians) to this transform in place.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def rotate_deg(self, degrees):
        """
        Add a rotation (in degrees) to this transform in place.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def rotate_around(self, x, y, theta):
        """
        Add a rotation (in radians) around the point (x, y) in place.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def rotate_deg_around(self, x, y, degrees):
        """
        Add a rotation (in degrees) around the point (x, y) in place.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def translate(self, tx, ty):
        """
        Adds a translation in place.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def scale(self, sx, sy: Optional[Any] = ...):
        """
        Adds a scale in place.

        If *sy* is None, the same scale is applied in both the *x*- and
        *y*-directions.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def skew(self, xShear, yShear):
        """
        Adds a skew in place.

        *xShear* and *yShear* are the shear angles along the *x*- and
        *y*-axes, respectively, in radians.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def skew_deg(self, xShear, yShear):
        """
        Adds a skew in place.

        *xShear* and *yShear* are the shear angles along the *x*- and
        *y*-axes, respectively, in degrees.

        Returns *self*, so this method can easily be chained with more
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`
        and :meth:`scale`.
        """
        ...
    
    def _get_is_separable(self):
        ...
    
    is_separable = ...


class IdentityTransform(Affine2DBase):
    """
    A special class that does one thing, the identity transform, in a
    fast way.
    """
    _mtx = ...
    def frozen(self):
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    
    def transform(self, points):
        ...
    
    transform_affine = ...
    transform_non_affine = ...
    def transform_path(self, path):
        ...
    
    transform_path_affine = ...
    transform_path_non_affine = ...
    def get_affine(self):
        ...
    
    inverted = ...


class BlendedGenericTransform(Transform):
    """
    A "blended" transform uses one transform for the *x*-direction, and
    another transform for the *y*-direction.

    This "generic" version can handle any given child transform in the
    *x*- and *y*-directions.
    """
    input_dims = ...
    output_dims = ...
    is_separable = ...
    pass_through = ...
    def __init__(self, x_transform, y_transform, **kwargs):
        """
        Create a new "blended" transform using *x_transform* to
        transform the *x*-axis and *y_transform* to transform the
        *y*-axis.

        You will generally not call this constructor directly but use
        the :func:`blended_transform_factory` function instead, which
        can determine automatically which kind of blended transform to
        create.
        """
        ...
    
    def __eq__(self, other):
        ...
    
    def contains_branch_seperately(self, transform):
        ...
    
    @property
    def depth(self):
        ...
    
    def contains_branch(self, other):
        ...
    
    def _get_is_affine(self):
        ...
    
    is_affine = ...
    def _get_has_inverse(self):
        ...
    
    has_inverse = ...
    def frozen(self):
        ...
    
    def __str__(self):
        ...
    
    def transform_non_affine(self, points):
        ...
    
    def inverted(self):
        ...
    
    def get_affine(self):
        ...
    


class BlendedAffine2D(Affine2DBase):
    """
    A "blended" transform uses one transform for the *x*-direction, and
    another transform for the *y*-direction.

    This version is an optimization for the case where both child
    transforms are of type :class:`Affine2DBase`.
    """
    is_separable = ...
    def __init__(self, x_transform, y_transform, **kwargs):
        """
        Create a new "blended" transform using *x_transform* to
        transform the *x*-axis and *y_transform* to transform the
        *y*-axis.

        Both *x_transform* and *y_transform* must be 2D affine
        transforms.

        You will generally not call this constructor directly but use
        the :func:`blended_transform_factory` function instead, which
        can determine automatically which kind of blended transform to
        create.
        """
        ...
    
    def __eq__(self, other):
        ...
    
    def contains_branch_seperately(self, transform):
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


def blended_transform_factory(x_transform, y_transform):
    """
    Create a new "blended" transform using *x_transform* to transform
    the *x*-axis and *y_transform* to transform the *y*-axis.

    A faster version of the blended transform is returned for the case
    where both child transforms are affine.
    """
    ...

class CompositeGenericTransform(Transform):
    """
    A composite transform formed by applying transform *a* then
    transform *b*.

    This "generic" version can handle any two arbitrary
    transformations.
    """
    pass_through = ...
    def __init__(self, a, b, **kwargs):
        """
        Create a new composite transform that is the result of
        applying transform *a* then transform *b*.

        You will generally not call this constructor directly but use
        the :func:`composite_transform_factory` function instead,
        which can automatically choose the best kind of composite
        transform instance to create.
        """
        self.input_dims = ...
        self.output_dims = ...
    
    is_affine = ...
    def frozen(self):
        ...
    
    def _invalidate_internal(self, value, invalidating_node):
        ...
    
    def __eq__(self, other):
        ...
    
    def _iter_break_from_left_to_right(self):
        ...
    
    @property
    def depth(self):
        ...
    
    def _get_is_affine(self):
        ...
    
    is_affine = ...
    def _get_is_separable(self):
        ...
    
    is_separable = ...
    def __str__(self):
        ...
    
    def transform_affine(self, points):
        ...
    
    def transform_non_affine(self, points):
        ...
    
    def transform_path_non_affine(self, path):
        ...
    
    def get_affine(self):
        ...
    
    def inverted(self):
        ...
    
    def _get_has_inverse(self):
        ...
    
    has_inverse = ...


class CompositeAffine2D(Affine2DBase):
    """
    A composite transform formed by applying transform *a* then transform *b*.

    This version is an optimization that handles the case where both *a*
    and *b* are 2D affines.
    """
    def __init__(self, a, b, **kwargs):
        """
        Create a new composite transform that is the result of
        applying transform *a* then transform *b*.

        Both *a* and *b* must be instances of :class:`Affine2DBase`.

        You will generally not call this constructor directly but use
        the :func:`composite_transform_factory` function instead,
        which can automatically choose the best kind of composite
        transform instance to create.
        """
        self.input_dims = ...
        self.output_dims = ...
    
    @property
    def depth(self):
        ...
    
    def _iter_break_from_left_to_right(self):
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


def composite_transform_factory(a, b):
    """
    Create a new composite transform that is the result of applying
    transform a then transform b.

    Shortcut versions of the blended transform are provided for the
    case where both child transforms are affine, or one or the other
    is the identity transform.

    Composite transforms may also be created using the '+' operator,
    e.g.::

      c = a + b
    """
    ...

class BboxTransform(Affine2DBase):
    """
    :class:`BboxTransform` linearly transforms points from one
    :class:`Bbox` to another :class:`Bbox`.
    """
    is_separable = ...
    def __init__(self, boxin, boxout, **kwargs):
        """
        Create a new :class:`BboxTransform` that linearly transforms
        points from *boxin* to *boxout*.
        """
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


class BboxTransformTo(Affine2DBase):
    """
    :class:`BboxTransformTo` is a transformation that linearly
    transforms points from the unit bounding box to a given
    :class:`Bbox`.
    """
    is_separable = ...
    def __init__(self, boxout, **kwargs):
        """
        Create a new :class:`BboxTransformTo` that linearly transforms
        points from the unit bounding box to *boxout*.
        """
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


class BboxTransformToMaxOnly(BboxTransformTo):
    """
    :class:`BboxTransformTo` is a transformation that linearly
    transforms points from the unit bounding box to a given
    :class:`Bbox` with a fixed upper left of (0, 0).
    """
    def get_matrix(self):
        ...
    


class BboxTransformFrom(Affine2DBase):
    """
    :class:`BboxTransformFrom` linearly transforms points from a given
    :class:`Bbox` to the unit bounding box.
    """
    is_separable = ...
    def __init__(self, boxin, **kwargs):
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


class ScaledTranslation(Affine2DBase):
    """
    A transformation that translates by *xt* and *yt*, after *xt* and *yt*
    have been transformad by the given transform *scale_trans*.
    """
    def __init__(self, xt, yt, scale_trans, **kwargs):
        ...
    
    def __str__(self):
        ...
    
    def get_matrix(self):
        ...
    


class TransformedPath(TransformNode):
    """
    A :class:`TransformedPath` caches a non-affine transformed copy of
    the :class:`~matplotlib.path.Path`.  This cached copy is
    automatically updated when the non-affine part of the transform
    changes.

    .. note::

        Paths are considered immutable by this class. Any update to the
        path's vertices/codes will not trigger a transform recomputation.

    """
    def __init__(self, path, transform):
        """
        Create a new :class:`TransformedPath` from the given
        :class:`~matplotlib.path.Path` and :class:`Transform`.
        """
        ...
    
    def _revalidate(self):
        ...
    
    def get_transformed_points_and_affine(self):
        """
        Return a copy of the child path, with the non-affine part of
        the transform already applied, along with the affine part of
        the path necessary to complete the transformation.  Unlike
        :meth:`get_transformed_path_and_affine`, no interpolation will
        be performed.
        """
        ...
    
    def get_transformed_path_and_affine(self):
        """
        Return a copy of the child path, with the non-affine part of
        the transform already applied, along with the affine part of
        the path necessary to complete the transformation.
        """
        ...
    
    def get_fully_transformed_path(self):
        """
        Return a fully-transformed copy of the child path.
        """
        ...
    
    def get_affine(self):
        ...
    


class TransformedPatchPath(TransformedPath):
    """
    A :class:`TransformedPatchPath` caches a non-affine transformed copy of
    the :class:`~matplotlib.path.Patch`. This cached copy is automatically
    updated when the non-affine part of the transform or the patch changes.
    """
    def __init__(self, patch):
        """
        Create a new :class:`TransformedPatchPath` from the given
        :class:`~matplotlib.path.Patch`.
        """
        ...
    
    def _revalidate(self):
        ...
    


def nonsingular(vmin, vmax, expander=..., tiny=..., increasing: bool = ...):
    """
    Modify the endpoints of a range as needed to avoid singularities.

    Parameters
    ----------
    vmin, vmax : float
        The initial endpoints.
    expander : float, optional, default: 0.001
        Fractional amount by which *vmin* and *vmax* are expanded if
        the original interval is too small, based on *tiny*.
    tiny : float, optional, default: 1e-15
        Threshold for the ratio of the interval to the maximum absolute
        value of its endpoints.  If the interval is smaller than
        this, it will be expanded.  This value should be around
        1e-15 or larger; otherwise the interval will be approaching
        the double precision resolution limit.
    increasing : bool, optional, default: True
        If True, swap *vmin*, *vmax* if *vmin* > *vmax*.

    Returns
    -------
    vmin, vmax : float
        Endpoints, expanded and/or swapped if necessary.
        If either input is inf or NaN, or if both inputs are 0 or very
        close to zero, it returns -*expander*, *expander*.
    """
    ...

def interval_contains(interval, val):
    """
    Check, inclusively, whether an interval includes a given value.

    Parameters
    ----------
    interval : sequence of scalar
        A 2-length sequence, endpoints that define the interval.
    val : scalar
        Value to check is within interval.

    Returns
    -------
    bool
        Returns true if given val is within the interval.
    """
    ...

def interval_contains_open(interval, val):
    """
    Check, excluding endpoints, whether an interval includes a given value.

    Parameters
    ----------
    interval : sequence of scalar
        A 2-length sequence, endpoints that define the interval.
    val : scalar
        Value to check is within interval.

    Returns
    -------
    bool
        Returns true if given val is within the interval.
    """
    ...

def offset_copy(trans, fig: Optional[Any] = ..., x=..., y=..., units=...):
    """
    Return a new transform with an added offset.

    Parameters
    ----------
    trans : :class:`Transform` instance
        Any transform, to which offset will be applied.
    fig : :class:`~matplotlib.figure.Figure`, optional, default: None
        Current figure. It can be None if *units* are 'dots'.
    x, y : float, optional, default: 0.0
        Specifies the offset to apply.
    units : {'inches', 'points', 'dots'}, optional
        Units of the offset.

    Returns
    -------
    trans : :class:`Transform` instance
        Transform with applied offset.
    """
    ...

