"""
This type stub file was generated by pyright.
"""

import numpy as np
from . import artist, cm, docstring
from typing import Any, Optional

"""
Classes for the efficient drawing of large collections of objects that
share most properties, e.g., a large number of line segments or
polygons.

The classes are not meant to be as flexible as their single element
counterparts (e.g., you may not be able to select all line styles) but
they are meant to be fast for common use cases (e.g., a large set of solid
line segemnts)
"""
CIRCLE_AREA_FACTOR = 1 / np.sqrt(np.pi)
_color_aliases = { 'facecolors': ['facecolor'],'edgecolors': ['edgecolor'] }
class Collection(artist.Artist, cm.ScalarMappable):
    """
    Base class for Collections.  Must be subclassed to be usable.

    All properties in a collection must be sequences or scalars;
    if scalars, they will be converted to sequences.  The
    property of the ith element of the collection is::

      prop[i % len(props)]

    Exceptions are *capstyle* and *joinstyle* properties, these can
    only be set globally for the whole collection.

    Keyword arguments and default values:

        * *edgecolors*: None
        * *facecolors*: None
        * *linewidths*: None
        * *capstyle*:   None
        * *joinstyle*:  None
        * *antialiaseds*: None
        * *offsets*: None
        * *transOffset*: transforms.IdentityTransform()
        * *offset_position*: 'screen' (default) or 'data'
        * *norm*: None (optional for
          :class:`matplotlib.cm.ScalarMappable`)
        * *cmap*: None (optional for
          :class:`matplotlib.cm.ScalarMappable`)
        * *hatch*: None
        * *zorder*: 1


    *offsets* and *transOffset* are used to translate the patch after
    rendering (default no offsets).  If offset_position is 'screen'
    (default) the offset is applied after the master transform has
    been applied, that is, the offsets are in screen coordinates.  If
    offset_position is 'data', the offset is applied before the master
    transform, i.e., the offsets are in data coordinates.

    If any of *edgecolors*, *facecolors*, *linewidths*, *antialiaseds*
    are None, they default to their :data:`matplotlib.rcParams` patch
    setting, in sequence form.

    The use of :class:`~matplotlib.cm.ScalarMappable` is optional.  If
    the :class:`~matplotlib.cm.ScalarMappable` matrix _A is not None
    (i.e., a call to set_array has been made), at draw time a call to
    scalar mappable will be made to set the face colors.
    """
    _offsets = ...
    _transOffset = ...
    _transforms = ...
    _edge_default = ...
    def __init__(self, edgecolors: Optional[Any] = ..., facecolors: Optional[Any] = ..., linewidths: Optional[Any] = ..., linestyles=..., capstyle: Optional[Any] = ..., joinstyle: Optional[Any] = ..., antialiaseds: Optional[Any] = ..., offsets: Optional[Any] = ..., transOffset: Optional[Any] = ..., norm: Optional[Any] = ..., cmap: Optional[Any] = ..., pickradius=..., hatch: Optional[Any] = ..., urls: Optional[Any] = ..., offset_position=..., zorder=..., **kwargs):
        """
        Create a Collection

        %(Collection)s
        """
        ...
    
    def get_paths(self):
        ...
    
    def set_paths(self):
        ...
    
    def get_transforms(self):
        ...
    
    def get_offset_transform(self):
        ...
    
    def get_datalim(self, transData):
        ...
    
    def get_window_extent(self, renderer):
        ...
    
    def _prepare_points(self):
        """Point prep for drawing and hit testing"""
        ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        self.stale = ...
    
    def set_pickradius(self, pr):
        """Set the pick radius used for containment tests.

        .. ACCEPTS: float distance in points

        Parameters
        ----------
        d : float
            Pick radius, in points.
        """
        ...
    
    def get_pickradius(self):
        ...
    
    def contains(self, mouseevent):
        """
        Test whether the mouse event occurred in the collection.

        Returns True | False, ``dict(ind=itemlist)``, where every
        item in itemlist contains the event.
        """
        ...
    
    def set_urls(self, urls):
        """
        Parameters
        ----------
        urls : List[str] or None
            .. ACCEPTS: List[str] or None
        """
        self.stale = ...
    
    def get_urls(self):
        ...
    
    def set_hatch(self, hatch):
        r"""
        Set the hatching pattern

        *hatch* can be one of::

          /   - diagonal hatching
          \   - back diagonal
          |   - vertical
          -   - horizontal
          +   - crossed
          x   - crossed diagonal
          o   - small circle
          O   - large circle
          .   - dots
          *   - stars

        Letters can be combined, in which case all the specified
        hatchings are done.  If same letter repeats, it increases the
        density of hatching of that pattern.

        Hatching is supported in the PostScript, PDF, SVG and Agg
        backends only.

        Unlike other properties such as linewidth and colors, hatching
        can only be specified for the collection as a whole, not separately
        for each member.

        ACCEPTS: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]
        """
        self.stale = ...
    
    def get_hatch(self):
        """Return the current hatching pattern."""
        ...
    
    def set_offsets(self, offsets):
        """
        Set the offsets for the collection.  *offsets* can be a scalar
        or a sequence.

        ACCEPTS: float or sequence of floats
        """
        self.stale = ...
    
    def get_offsets(self):
        """Return the offsets for the collection."""
        ...
    
    def set_offset_position(self, offset_position):
        """
        Set how offsets are applied.  If *offset_position* is 'screen'
        (default) the offset is applied after the master transform has
        been applied, that is, the offsets are in screen coordinates.
        If offset_position is 'data', the offset is applied before the
        master transform, i.e., the offsets are in data coordinates.

        .. ACCEPTS: [ 'screen' | 'data' ]
        """
        self.stale = ...
    
    def get_offset_position(self):
        """
        Returns how offsets are applied for the collection.  If
        *offset_position* is 'screen', the offset is applied after the
        master transform has been applied, that is, the offsets are in
        screen coordinates.  If offset_position is 'data', the offset
        is applied before the master transform, i.e., the offsets are
        in data coordinates.
        """
        ...
    
    def set_linewidth(self, lw):
        """
        Set the linewidth(s) for the collection.  *lw* can be a scalar
        or a sequence; if it is a sequence the patches will cycle
        through the sequence

        ACCEPTS: float or sequence of floats
        """
        self.stale = ...
    
    def set_linewidths(self, lw):
        """alias for set_linewidth"""
        ...
    
    def set_lw(self, lw):
        """alias for set_linewidth"""
        ...
    
    def set_linestyle(self, ls):
        """
        Set the linestyle(s) for the collection.

        ===========================   =================
        linestyle                     description
        ===========================   =================
        ``'-'`` or ``'solid'``        solid line
        ``'--'`` or  ``'dashed'``     dashed line
        ``'-.'`` or  ``'dashdot'``    dash-dotted line
        ``':'`` or ``'dotted'``       dotted line
        ===========================   =================

        Alternatively a dash tuple of the following form can be provided::

            (offset, onoffseq),

        where ``onoffseq`` is an even length tuple of on and off ink
        in points.

        ACCEPTS: ['solid' | 'dashed', 'dashdot', 'dotted' |
                   (offset, on-off-dash-seq) |
                   ``'-'`` | ``'--'`` | ``'-.'`` | ``':'`` | ``'None'`` |
                   ``' '`` | ``''``]

        Parameters
        ----------
        ls : { '-',  '--', '-.', ':'} and more see description
            The line style.
        """
        ...
    
    def set_capstyle(self, cs):
        """
        Set the capstyle for the collection. The capstyle can
        only be set globally for all elements in the collection

        Parameters
        ----------
        cs : ['butt' | 'round' | 'projecting']
            The capstyle
        """
        ...
    
    def get_capstyle(self):
        ...
    
    def set_joinstyle(self, js):
        """
        Set the joinstyle for the collection. The joinstyle can only be
        set globally for all elements in the collection.

        Parameters
        ----------
        js : ['miter' | 'round' | 'bevel']
            The joinstyle
        """
        ...
    
    def get_joinstyle(self):
        ...
    
    @staticmethod
    def _bcast_lwls(linewidths, dashes):
        '''Internal helper function to broadcast + scale ls/lw

        In the collection drawing code the linewidth and linestyle are
        cycled through as circular buffers (via v[i % len(v)]).  Thus,
        if we are going to scale the dash pattern at set time (not
        draw time) we need to do the broadcasting now and expand both
        lists to be the same length.

        Parameters
        ----------
        linewidths : list
            line widths of collection

        dashes : list
            dash specification (offset, (dash pattern tuple))

        Returns
        -------
        linewidths, dashes : list
             Will be the same length, dashes are scaled by paired linewidth

        '''
        ...
    
    def set_linestyles(self, ls):
        """alias for set_linestyle"""
        ...
    
    def set_dashes(self, ls):
        """alias for set_linestyle"""
        ...
    
    def set_antialiased(self, aa):
        """
        Set the antialiasing state for rendering.

        ACCEPTS: Boolean or sequence of booleans
        """
        self.stale = ...
    
    def set_antialiaseds(self, aa):
        """alias for set_antialiased"""
        ...
    
    def set_color(self, c):
        """
        Set both the edgecolor and the facecolor.

        ACCEPTS: matplotlib color arg or sequence of rgba tuples

        .. seealso::

            :meth:`set_facecolor`, :meth:`set_edgecolor`
               For setting the edge or face color individually.
        """
        ...
    
    def _set_facecolor(self, c):
        self.stale = ...
    
    def set_facecolor(self, c):
        """
        Set the facecolor(s) of the collection.  *c* can be a
        matplotlib color spec (all patches have same color), or a
        sequence of specs; if it is a sequence the patches will
        cycle through the sequence.

        If *c* is 'none', the patch will not be filled.

        ACCEPTS: matplotlib color spec or sequence of specs
        """
        ...
    
    def set_facecolors(self, c):
        """alias for set_facecolor"""
        ...
    
    def get_facecolor(self):
        ...
    
    get_facecolors = ...
    def get_edgecolor(self):
        ...
    
    get_edgecolors = ...
    def _set_edgecolor(self, c):
        self.stale = ...
    
    def set_edgecolor(self, c):
        """
        Set the edgecolor(s) of the collection. *c* can be a
        matplotlib color spec (all patches have same color), or a
        sequence of specs; if it is a sequence the patches will
        cycle through the sequence.

        If *c* is 'face', the edge color will always be the same as
        the face color.  If it is 'none', the patch boundary will not
        be drawn.

        ACCEPTS: matplotlib color spec or sequence of specs
        """
        ...
    
    def set_edgecolors(self, c):
        """alias for set_edgecolor"""
        ...
    
    def set_alpha(self, alpha):
        """
        Set the alpha tranparencies of the collection.  *alpha* must be
        a float or *None*.

        ACCEPTS: float or None
        """
        ...
    
    def get_linewidths(self):
        ...
    
    get_linewidth = ...
    def get_linestyles(self):
        ...
    
    get_dashes = ...
    def update_scalarmappable(self):
        """
        If the scalar mappable array is not none, update colors
        from scalar data
        """
        self.stale = ...
    
    def get_fill(self):
        'return whether fill is set'
        ...
    
    def update_from(self, other):
        'copy properties from other to self'
        self.norm = ...
        self.cmap = ...
        self.stale = ...
    


class _CollectionWithSizes(Collection):
    """
    Base class for collections that have an array of sizes.
    """
    _factor = ...
    def get_sizes(self):
        """
        Returns the sizes of the elements in the collection.  The
        value represents the 'area' of the element.

        Returns
        -------
        sizes : array
            The 'area' of each element.
        """
        ...
    
    def set_sizes(self, sizes, dpi=...):
        """
        Set the sizes of each member of the collection.

        Parameters
        ----------
        sizes : ndarray or None
            The size to set for each element of the collection.  The
            value is the 'area' of the element.

        dpi : float
            The dpi of the canvas. Defaults to 72.0.
        """
        self.stale = ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        ...
    


class PathCollection(_CollectionWithSizes):
    """
    This is the most basic :class:`Collection` subclass.
    """
    @docstring.dedent_interpd
    def __init__(self, paths, sizes: Optional[Any] = ..., **kwargs):
        """
        *paths* is a sequence of :class:`matplotlib.path.Path`
        instances.

        %(Collection)s
        """
        self.stale = ...
    
    def set_paths(self, paths):
        self.stale = ...
    
    def get_paths(self):
        ...
    


class PolyCollection(_CollectionWithSizes):
    @docstring.dedent_interpd
    def __init__(self, verts, sizes: Optional[Any] = ..., closed: bool = ..., **kwargs):
        """
        *verts* is a sequence of ( *verts0*, *verts1*, ...) where
        *verts_i* is a sequence of *xy* tuples of vertices, or an
        equivalent :mod:`numpy` array of shape (*nv*, 2).

        *sizes* is *None* (default) or a sequence of floats that
        scale the corresponding *verts_i*.  The scaling is applied
        before the Artist master transform; if the latter is an identity
        transform, then the overall scaling is such that if
        *verts_i* specify a unit square, then *sizes_i* is the area
        of that square in points^2.
        If len(*sizes*) < *nv*, the additional values will be
        taken cyclically from the array.

        *closed*, when *True*, will explicitly close the polygon.

        %(Collection)s
        """
        self.stale = ...
    
    def set_verts(self, verts, closed: bool = ...):
        '''This allows one to delay initialization of the vertices.'''
        self.stale = ...
    
    set_paths = ...
    def set_verts_and_codes(self, verts, codes):
        '''This allows one to initialize vertices with path codes.'''
        self.stale = ...
    


class BrokenBarHCollection(PolyCollection):
    """
    A collection of horizontal bars spanning *yrange* with a sequence of
    *xranges*.
    """
    @docstring.dedent_interpd
    def __init__(self, xranges, yrange, **kwargs):
        """
        *xranges*
            sequence of (*xmin*, *xwidth*)

        *yrange*
            *ymin*, *ywidth*

        %(Collection)s
        """
        ...
    
    @staticmethod
    def span_where(x, ymin, ymax, where, **kwargs):
        """
        Create a BrokenBarHCollection to plot horizontal bars from
        over the regions in *x* where *where* is True.  The bars range
        on the y-axis from *ymin* to *ymax*

        A :class:`BrokenBarHCollection` is returned.  *kwargs* are
        passed on to the collection.
        """
        ...
    


class RegularPolyCollection(_CollectionWithSizes):
    """Draw a collection of regular polygons with *numsides*."""
    _path_generator = ...
    _factor = ...
    @docstring.dedent_interpd
    def __init__(self, numsides, rotation=..., sizes=..., **kwargs):
        """
        *numsides*
            the number of sides of the polygon

        *rotation*
            the rotation of the polygon in radians

        *sizes*
            gives the area of the circle circumscribing the
            regular polygon in points^2

        %(Collection)s

        Example: see :file:`examples/dynamic_collection.py` for
        complete example::

            offsets = np.random.rand(20,2)
            facecolors = [cm.jet(x) for x in np.random.rand(20)]
            black = (0,0,0,1)

            collection = RegularPolyCollection(
                numsides=5, # a pentagon
                rotation=0, sizes=(50,),
                facecolors = facecolors,
                edgecolors = (black,),
                linewidths = (1,),
                offsets = offsets,
                transOffset = ax.transData,
                )
        """
        ...
    
    def get_numsides(self):
        ...
    
    def get_rotation(self):
        ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        ...
    


class StarPolygonCollection(RegularPolyCollection):
    """
    Draw a collection of regular stars with *numsides* points."""
    _path_generator = ...


class AsteriskPolygonCollection(RegularPolyCollection):
    """
    Draw a collection of regular asterisks with *numsides* points."""
    _path_generator = ...


class LineCollection(Collection):
    """
    All parameters must be sequences or scalars; if scalars, they will
    be converted to sequences.  The property of the ith line
    segment is::

       prop[i % len(props)]

    i.e., the properties cycle if the ``len`` of props is less than the
    number of segments.
    """
    _edge_default = ...
    def __init__(self, segments, linewidths: Optional[Any] = ..., colors: Optional[Any] = ..., antialiaseds: Optional[Any] = ..., linestyles=..., offsets: Optional[Any] = ..., transOffset: Optional[Any] = ..., norm: Optional[Any] = ..., cmap: Optional[Any] = ..., pickradius=..., zorder=..., facecolors=..., **kwargs):
        """
        Parameters
        ----------
        segments :
            A sequence of (*line0*, *line1*, *line2*), where::

                linen = (x0, y0), (x1, y1), ... (xm, ym)

            or the equivalent numpy array with two columns. Each line
            can be a different length.

        colors : sequence, optional
            A sequence of RGBA tuples (e.g., arbitrary color
            strings, etc, not allowed).

        antialiaseds : sequence, optional
            A sequence of ones or zeros.

        linestyles : string, tuple, optional
            Either one of [ 'solid' | 'dashed' | 'dashdot' | 'dotted' ], or
            a dash tuple. The dash tuple is::

                (offset, onoffseq)

            where ``onoffseq`` is an even length tuple of on and off ink
            in points.

        norm : Normalize, optional
            `~.colors.Normalize` instance.

        cmap : string or Colormap, optional
            Colormap name or `~.colors.Colormap` instance.

        pickradius : float, optional
            The tolerance in points for mouse clicks picking a line.
            Default is 5 pt.

        zorder : int, optional
           zorder of the LineCollection. Default is 2.

        facecolors : optional
           The facecolors of the LineCollection. Default is 'none'.
           Setting to a value other than 'none' will lead to a filled
           polygon being drawn between points on each line.

        Notes
        -----
        If *linewidths*, *colors*, or *antialiaseds* is None, they
        default to their rcParams setting, in sequence form.

        If *offsets* and *transOffset* are not None, then
        *offsets* are transformed by *transOffset* and applied after
        the segments have been transformed to display coordinates.

        If *offsets* is not None but *transOffset* is None, then the
        *offsets* are added to the segments before any transformation.
        In this case, a single offset can be specified as::

            offsets=(xo,yo)

        and this value will be added cumulatively to each successive
        segment, so as to produce a set of successively offset curves.

        The use of :class:`~matplotlib.cm.ScalarMappable` is optional.
        If the :class:`~matplotlib.cm.ScalarMappable` array
        :attr:`~matplotlib.cm.ScalarMappable._A` is not None (i.e., a call to
        :meth:`~matplotlib.cm.ScalarMappable.set_array` has been made), at
        draw time a call to scalar mappable will be made to set the colors.
        """
        ...
    
    def set_segments(self, segments):
        self.stale = ...
    
    set_verts = ...
    set_paths = ...
    def get_segments(self):
        """
        Returns
        -------
        segments : list
            List of segments in the LineCollection. Each list item contains an
            array of vertices.
        """
        ...
    
    def _add_offsets(self, segs):
        ...
    
    def set_color(self, c):
        """
        Set the color(s) of the LineCollection.

        Parameters
        ----------
        c :
            Matplotlib color argument (all patches have same color), or a
            sequence or rgba tuples; if it is a sequence the patches will
            cycle through the sequence.
        """
        self.stale = ...
    
    def get_color(self):
        ...
    
    get_colors = ...


class EventCollection(LineCollection):
    '''
    A collection of discrete events.

    The events are given by a 1-dimensional array, usually the position of
    something along an axis, such as time or length.  They do not have an
    amplitude and are displayed as vertical or horizontal parallel bars.
    '''
    _edge_default = ...
    def __init__(self, positions, orientation: Optional[Any] = ..., lineoffset=..., linelength=..., linewidth: Optional[Any] = ..., color: Optional[Any] = ..., linestyle=..., antialiased: Optional[Any] = ..., **kwargs):
        """
        Parameters
        ----------
        positions : 1D array-like object
            Each value is an event.

        orientation : {None, 'horizontal', 'vertical'}, optional
            The orientation of the **collection** (the event bars are along
            the orthogonal direction). Defaults to 'horizontal' if not
            specified or None.

        lineoffset : scalar, optional, default: 0
            The offset of the center of the markers from the origin, in the
            direction orthogonal to *orientation*.

        linelength : scalar, optional, default: 1
            The total height of the marker (i.e. the marker stretches from
            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).

        linewidth : scalar or None, optional, default: None
            If it is None, defaults to its rcParams setting, in sequence form.

        color : color, sequence of colors or None, optional, default: None
            If it is None, defaults to its rcParams setting, in sequence form.

        linestyle : str or tuple, optional, default: 'solid'
            Valid strings are ['solid', 'dashed', 'dashdot', 'dotted',
            '-', '--', '-.', ':']. Dash tuples should be of the form::

                (offset, onoffseq),

            where *onoffseq* is an even length tuple of on and off ink
            in points.

        antialiased : {None, 1, 2}, optional
            If it is None, defaults to its rcParams setting, in sequence form.

        **kwargs : optional
            Other keyword arguments are line collection properties.  See
            :class:`~matplotlib.collections.LineCollection` for a list of
            the valid properties.

        Examples
        --------

        .. plot:: gallery/lines_bars_and_markers/eventcollection_demo.py
        """
        ...
    
    def get_positions(self):
        '''
        return an array containing the floating-point values of the positions
        '''
        ...
    
    def set_positions(self, positions):
        '''
        set the positions of the events to the specified value
        '''
        ...
    
    def add_positions(self, position):
        '''
        add one or more events at the specified positions
        '''
        ...
    
    extend_positions = ...
    def is_horizontal(self):
        '''
        True if the eventcollection is horizontal, False if vertical
        '''
        ...
    
    def get_orientation(self):
        '''
        get the orientation of the event line, may be:
        [ 'horizontal' | 'vertical' ]
        '''
        ...
    
    def switch_orientation(self):
        '''
        switch the orientation of the event line, either from vertical to
        horizontal or vice versus
        '''
        self.stale = ...
    
    def set_orientation(self, orientation: Optional[Any] = ...):
        '''
        set the orientation of the event line
        [ 'horizontal' | 'vertical' | None ]
        defaults to 'horizontal' if not specified or None
        '''
        ...
    
    def get_linelength(self):
        '''
        get the length of the lines used to mark each event
        '''
        ...
    
    def set_linelength(self, linelength):
        '''
        set the length of the lines used to mark each event
        '''
        ...
    
    def get_lineoffset(self):
        '''
        get the offset of the lines used to mark each event
        '''
        ...
    
    def set_lineoffset(self, lineoffset):
        '''
        set the offset of the lines used to mark each event
        '''
        ...
    
    def get_linewidth(self):
        '''
        get the width of the lines used to mark each event
        '''
        ...
    
    def get_linestyle(self):
        '''
        get the style of the lines used to mark each event
        [ 'solid' | 'dashed' | 'dashdot' | 'dotted' ]
        '''
        ...
    
    def get_color(self):
        '''
        get the color of the lines used to mark each event
        '''
        ...
    


class CircleCollection(_CollectionWithSizes):
    """
    A collection of circles, drawn using splines.
    """
    _factor = ...
    @docstring.dedent_interpd
    def __init__(self, sizes, **kwargs):
        """
        *sizes*
            Gives the area of the circle in points^2

        %(Collection)s
        """
        ...
    


class EllipseCollection(Collection):
    """
    A collection of ellipses, drawn using splines.
    """
    @docstring.dedent_interpd
    def __init__(self, widths, heights, angles, units=..., **kwargs):
        """
        *widths*: sequence
            lengths of first axes (e.g., major axis lengths)

        *heights*: sequence
            lengths of second axes

        *angles*: sequence
            angles of first axes, degrees CCW from the X-axis

        *units*: ['points' | 'inches' | 'dots' | 'width' | 'height'
        | 'x' | 'y' | 'xy']

            units in which majors and minors are given; 'width' and
            'height' refer to the dimensions of the axes, while 'x'
            and 'y' refer to the *offsets* data units. 'xy' differs
            from all others in that the angle as plotted varies with
            the aspect ratio, and equals the specified angle only when
            the aspect ratio is unity.  Hence it behaves the same as
            the :class:`~matplotlib.patches.Ellipse` with
            axes.transData as its transform.

        Additional kwargs inherited from the base :class:`Collection`:

        %(Collection)s
        """
        ...
    
    def _set_transforms(self):
        """
        Calculate transforms immediately before drawing.
        """
        ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        ...
    


class PatchCollection(Collection):
    """
    A generic collection of patches.

    This makes it easier to assign a color map to a heterogeneous
    collection of patches.

    This also may improve plotting speed, since PatchCollection will
    draw faster than a large number of patches.
    """
    def __init__(self, patches, match_original: bool = ..., **kwargs):
        """
        *patches*
            a sequence of Patch objects.  This list may include
            a heterogeneous assortment of different patch types.

        *match_original*
            If True, use the colors and linewidths of the original
            patches.  If False, new colors may be assigned by
            providing the standard collection arguments, facecolor,
            edgecolor, linewidths, norm or cmap.

        If any of *edgecolors*, *facecolors*, *linewidths*,
        *antialiaseds* are None, they default to their
        :data:`matplotlib.rcParams` patch setting, in sequence form.

        The use of :class:`~matplotlib.cm.ScalarMappable` is optional.
        If the :class:`~matplotlib.cm.ScalarMappable` matrix _A is not
        None (i.e., a call to set_array has been made), at draw time a
        call to scalar mappable will be made to set the face colors.
        """
        ...
    
    def set_paths(self, patches):
        ...
    


class TriMesh(Collection):
    """
    Class for the efficient drawing of a triangular mesh using
    Gouraud shading.

    A triangular mesh is a :class:`~matplotlib.tri.Triangulation`
    object.
    """
    def __init__(self, triangulation, **kwargs):
        ...
    
    def get_paths(self):
        ...
    
    def set_paths(self):
        ...
    
    @staticmethod
    def convert_mesh_to_paths(tri):
        """
        Converts a given mesh into a sequence of
        :class:`matplotlib.path.Path` objects for easier rendering by
        backends that do not directly support meshes.

        This function is primarily of use to backend implementers.
        """
        ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        ...
    


class QuadMesh(Collection):
    """
    Class for the efficient drawing of a quadrilateral mesh.

    A quadrilateral mesh consists of a grid of vertices. The
    dimensions of this array are (*meshWidth* + 1, *meshHeight* +
    1). Each vertex in the mesh has a different set of "mesh
    coordinates" representing its position in the topology of the
    mesh. For any values (*m*, *n*) such that 0 <= *m* <= *meshWidth*
    and 0 <= *n* <= *meshHeight*, the vertices at mesh coordinates
    (*m*, *n*), (*m*, *n* + 1), (*m* + 1, *n* + 1), and (*m* + 1, *n*)
    form one of the quadrilaterals in the mesh. There are thus
    (*meshWidth* * *meshHeight*) quadrilaterals in the mesh.  The mesh
    need not be regular and the polygons need not be convex.

    A quadrilateral mesh is represented by a (2 x ((*meshWidth* + 1) *
    (*meshHeight* + 1))) numpy array *coordinates*, where each row is
    the *x* and *y* coordinates of one of the vertices.  To define the
    function that maps from a data point to its corresponding color,
    use the :meth:`set_cmap` method.  Each of these arrays is indexed in
    row-major order by the mesh coordinates of the vertex (or the mesh
    coordinates of the lower left vertex, in the case of the
    colors).

    For example, the first entry in *coordinates* is the
    coordinates of the vertex at mesh coordinates (0, 0), then the one
    at (0, 1), then at (0, 2) .. (0, meshWidth), (1, 0), (1, 1), and
    so on.

    *shading* may be 'flat', or 'gouraud'
    """
    def __init__(self, meshWidth, meshHeight, coordinates, antialiased: bool = ..., shading=..., **kwargs):
        ...
    
    def get_paths(self):
        ...
    
    def set_paths(self):
        self.stale = ...
    
    def get_datalim(self, transData):
        ...
    
    @staticmethod
    def convert_mesh_to_paths(meshWidth, meshHeight, coordinates):
        """
        Converts a given mesh into a sequence of
        :class:`matplotlib.path.Path` objects for easier rendering by
        backends that do not directly support quadmeshes.

        This function is primarily of use to backend implementers.
        """
        ...
    
    def convert_mesh_to_triangles(self, meshWidth, meshHeight, coordinates):
        """
        Converts a given mesh into a sequence of triangles, each point
        with its own color.  This is useful for experiments using
        `draw_qouraud_triangle`.
        """
        ...
    
    @artist.allow_rasterization
    def draw(self, renderer):
        self.stale = ...
    


patchstr = artist.kwdoc(Collection)
