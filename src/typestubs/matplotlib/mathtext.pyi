"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

r"""
:mod:`~matplotlib.mathtext` is a module for parsing a subset of the
TeX math syntax and drawing them to a matplotlib backend.

For a tutorial of its usage see :doc:`/tutorials/text/mathtext`.  This
document is primarily concerned with implementation details.

The module uses pyparsing_ to parse the TeX expression.

.. _pyparsing: http://pyparsing.wikispaces.com/

The Bakoma distribution of the TeX Computer Modern fonts, and STIX
fonts are supported.  There is experimental support for using
arbitrary fonts, but results may vary without proper tweaking and
metrics for those fonts.
"""
def get_unicode_index(symbol, math: bool = ...):
    """get_unicode_index(symbol, [bool]) -> integer

Return the integer index (from the Unicode table) of symbol.  *symbol*
can be a single unicode character, a TeX command (i.e. r'\\pi'), or a
Type1 symbol name (i.e. 'phi').
If math is False, the current symbol should be treated as a non-math symbol.
"""
    ...

def unichr_safe(index):
    """Return the Unicode character corresponding to the index,
or the replacement character if this is a narrow build of Python
and the requested character is outside the BMP."""
    ...

class MathtextBackend(object):
    """
    The base class for the mathtext backend-specific code.  The
    purpose of :class:`MathtextBackend` subclasses is to interface
    between mathtext and a specific matplotlib graphics backend.

    Subclasses need to override the following:

      - :meth:`render_glyph`
      - :meth:`render_rect_filled`
      - :meth:`get_results`

    And optionally, if you need to use a FreeType hinting style:

      - :meth:`get_hinting_type`
    """
    def __init__(self):
        self.width = ...
        self.height = ...
        self.depth = ...
    
    def set_canvas_size(self, w, h, d):
        'Dimension the drawing canvas'
        self.width = ...
        self.height = ...
        self.depth = ...
    
    def render_glyph(self, ox, oy, info):
        """
        Draw a glyph described by *info* to the reference point (*ox*,
        *oy*).
        """
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        """
        Draw a filled black rectangle from (*x1*, *y1*) to (*x2*, *y2*).
        """
        ...
    
    def get_results(self, box):
        """
        Return a backend-specific tuple to return to the backend after
        all processing is done.
        """
        ...
    
    def get_hinting_type(self):
        """
        Get the FreeType hinting type to use with this particular
        backend.
        """
        ...
    


class MathtextBackendAgg(MathtextBackend):
    """
    Render glyphs and rectangles to an FTImage buffer, which is later
    transferred to the Agg image by the Agg backend.
    """
    def __init__(self):
        self.ox = ...
        self.oy = ...
        self.image = ...
        self.mode = ...
        self.bbox = ...
    
    def _update_bbox(self, x1, y1, x2, y2):
        self.bbox = ...
    
    def set_canvas_size(self, w, h, d):
        ...
    
    def render_glyph(self, ox, oy, info):
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        ...
    
    def get_results(self, box, used_characters):
        self.mode = ...
        self.mode = ...
        self.image = ...
    
    def get_hinting_type(self):
        ...
    


class MathtextBackendBitmap(MathtextBackendAgg):
    def get_results(self, box, used_characters):
        ...
    


class MathtextBackendPs(MathtextBackend):
    """
    Store information to write a mathtext rendering to the PostScript
    backend.
    """
    def __init__(self):
        self.pswriter = ...
        self.lastfont = ...
    
    def render_glyph(self, ox, oy, info):
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        ...
    
    def get_results(self, box, used_characters):
        ...
    


class MathtextBackendPdf(MathtextBackend):
    """
    Store information to write a mathtext rendering to the PDF
    backend.
    """
    def __init__(self):
        self.glyphs = ...
        self.rects = ...
    
    def render_glyph(self, ox, oy, info):
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        ...
    
    def get_results(self, box, used_characters):
        ...
    


class MathtextBackendSvg(MathtextBackend):
    """
    Store information to write a mathtext rendering to the SVG
    backend.
    """
    def __init__(self):
        self.svg_glyphs = ...
        self.svg_rects = ...
    
    def render_glyph(self, ox, oy, info):
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        ...
    
    def get_results(self, box, used_characters):
        ...
    


class MathtextBackendPath(MathtextBackend):
    """
    Store information to write a mathtext rendering to the text path
    machinery.
    """
    def __init__(self):
        self.glyphs = ...
        self.rects = ...
    
    def render_glyph(self, ox, oy, info):
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        ...
    
    def get_results(self, box, used_characters):
        ...
    


class MathtextBackendCairo(MathtextBackend):
    """
    Store information to write a mathtext rendering to the Cairo
    backend.
    """
    def __init__(self):
        self.glyphs = ...
        self.rects = ...
    
    def render_glyph(self, ox, oy, info):
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        ...
    
    def get_results(self, box, used_characters):
        ...
    


class Fonts(object):
    """
    An abstract base class for a system of fonts to use for mathtext.

    The class must be able to take symbol keys and font file names and
    return the character metrics.  It also delegates to a backend class
    to do the actual drawing.
    """
    def __init__(self, default_font_prop, mathtext_backend):
        """
        *default_font_prop*: A
        :class:`~matplotlib.font_manager.FontProperties` object to use
        for the default non-math font, or the base font for Unicode
        (generic) font rendering.

        *mathtext_backend*: A subclass of :class:`MathTextBackend`
        used to delegate the actual rendering.
        """
        self.default_font_prop = ...
        self.mathtext_backend = ...
        self.used_characters = ...
    
    def destroy(self):
        """
        Fix any cyclical references before the object is about
        to be destroyed.
        """
        self.used_characters = ...
    
    def get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi):
        """
        Get the kerning distance for font between *sym1* and *sym2*.

        *fontX*: one of the TeX font names::

          tt, it, rm, cal, sf, bf or default/regular (non-math)

        *fontclassX*: TODO

        *symX*: a symbol in raw TeX form. e.g., '1', 'x' or '\\sigma'

        *fontsizeX*: the fontsize in points

        *dpi*: the current dots-per-inch
        """
        ...
    
    def get_metrics(self, font, font_class, sym, fontsize, dpi, math: bool = ...):
        """
        *font*: one of the TeX font names::

          tt, it, rm, cal, sf, bf or default/regular (non-math)

        *font_class*: TODO

        *sym*:  a symbol in raw TeX form. e.g., '1', 'x' or '\\sigma'

        *fontsize*: font size in points

        *dpi*: current dots-per-inch

        *math*: whether sym is a math character

        Returns an object with the following attributes:

          - *advance*: The advance distance (in points) of the glyph.

          - *height*: The height of the glyph in points.

          - *width*: The width of the glyph in points.

          - *xmin*, *xmax*, *ymin*, *ymax* - the ink rectangle of the glyph

          - *iceberg* - the distance from the baseline to the top of
            the glyph.  This corresponds to TeX's definition of
            "height".
        """
        ...
    
    def set_canvas_size(self, w, h, d):
        """
        Set the size of the buffer used to render the math expression.
        Only really necessary for the bitmap backends.
        """
        ...
    
    def render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi):
        """
        Draw a glyph at

          - *ox*, *oy*: position

          - *facename*: One of the TeX face names

          - *font_class*:

          - *sym*: TeX symbol name or single character

          - *fontsize*: fontsize in points

          - *dpi*: The dpi to draw at.
        """
        ...
    
    def render_rect_filled(self, x1, y1, x2, y2):
        """
        Draw a filled rectangle from (*x1*, *y1*) to (*x2*, *y2*).
        """
        ...
    
    def get_xheight(self, font, fontsize, dpi):
        """
        Get the xheight for the given *font* and *fontsize*.
        """
        ...
    
    def get_underline_thickness(self, font, fontsize, dpi):
        """
        Get the line thickness that matches the given font.  Used as a
        base unit for drawing lines such as in a fraction or radical.
        """
        ...
    
    def get_used_characters(self):
        """
        Get the set of characters that were used in the math
        expression.  Used by backends that need to subset fonts so
        they know which glyphs to include.
        """
        ...
    
    def get_results(self, box):
        """
        Get the data needed by the backend to render the math
        expression.  The return value is backend-specific.
        """
        ...
    
    def get_sized_alternatives_for_symbol(self, fontname, sym):
        """
        Override if your font provides multiple sizes of the same
        symbol.  Should return a list of symbols matching *sym* in
        various sizes.  The expression renderer will select the most
        appropriate size for a given situation from this list.
        """
        ...
    


class TruetypeFonts(Fonts):
    """
    A generic base class for all font setups that use Truetype fonts
    (through FT2Font).
    """
    def __init__(self, default_font_prop, mathtext_backend):
        self.glyphd = ...
    
    def destroy(self):
        self.glyphd = ...
    
    def _get_font(self, font):
        ...
    
    def _get_offset(self, font, glyph, fontsize, dpi):
        ...
    
    def _get_info(self, fontname, font_class, sym, fontsize, dpi, math: bool = ...):
        ...
    
    def get_xheight(self, fontname, fontsize, dpi):
        ...
    
    def get_underline_thickness(self, font, fontsize, dpi):
        ...
    
    def get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi):
        ...
    


class BakomaFonts(TruetypeFonts):
    """
    Use the Bakoma TrueType fonts for rendering.

    Symbols are strewn about a number of font files, each of which has
    its own proprietary 8-bit encoding.
    """
    _fontmap = ...
    def __init__(self, *args, **kwargs):
        self.fontmap = ...
    
    _slanted_symbols = ...
    def _get_glyph(self, fontname, font_class, sym, fontsize, math: bool = ...):
        ...
    
    _size_alternatives = ...
    def get_sized_alternatives_for_symbol(self, fontname, sym):
        ...
    


class UnicodeFonts(TruetypeFonts):
    """
    An abstract base class for handling Unicode fonts.

    While some reasonably complete Unicode fonts (such as DejaVu) may
    work in some situations, the only Unicode font I'm aware of with a
    complete set of math symbols is STIX.

    This class will "fallback" on the Bakoma fonts when a required
    symbol can not be found in the font.
    """
    use_cmex = ...
    def __init__(self, *args, **kwargs):
        self.fontmap = ...
    
    _slanted_symbols = ...
    def _map_virtual_font(self, fontname, font_class, uniindex):
        ...
    
    def _get_glyph(self, fontname, font_class, sym, fontsize, math: bool = ...):
        ...
    
    def get_sized_alternatives_for_symbol(self, fontname, sym):
        ...
    


class DejaVuFonts(UnicodeFonts):
    use_cmex = ...
    def __init__(self, *args, **kwargs):
        self.bakoma = ...
        self.fontmap = ...
    
    def _get_glyph(self, fontname, font_class, sym, fontsize, math: bool = ...):
        """ Override prime symbol to use Bakoma """
        ...
    


class DejaVuSerifFonts(DejaVuFonts):
    """
    A font handling class for the DejaVu Serif fonts

    If a glyph is not found it will fallback to Stix Serif
    """
    _fontmap = ...


class DejaVuSansFonts(DejaVuFonts):
    """
    A font handling class for the DejaVu Sans fonts

    If a glyph is not found it will fallback to Stix Sans
    """
    _fontmap = ...


class StixFonts(UnicodeFonts):
    """
    A font handling class for the STIX fonts.

    In addition to what UnicodeFonts provides, this class:

    - supports "virtual fonts" which are complete alpha numeric
      character sets with different font styles at special Unicode
      code points, such as "Blackboard".

    - handles sized alternative characters for the STIXSizeX fonts.
    """
    _fontmap = ...
    use_cmex = ...
    cm_fallback = ...
    _sans = ...
    def __init__(self, *args, **kwargs):
        self.fontmap = ...
    
    def _map_virtual_font(self, fontname, font_class, uniindex):
        ...
    
    _size_alternatives = ...
    def get_sized_alternatives_for_symbol(self, fontname, sym):
        ...
    


class StixSansFonts(StixFonts):
    """
    A font handling class for the STIX fonts (that uses sans-serif
    characters by default).
    """
    _sans = ...


class StandardPsFonts(Fonts):
    """
    Use the standard postscript fonts for rendering to backend_ps

    Unlike the other font classes, BakomaFont and UnicodeFont, this
    one requires the Ps backend.
    """
    basepath = ...
    fontmap = ...
    def __init__(self, default_font_prop):
        self.glyphd = ...
        self.fonts = ...
        self.pswriter = ...
    
    def _get_font(self, font):
        ...
    
    def _get_info(self, fontname, font_class, sym, fontsize, dpi, math: bool = ...):
        'load the cmfont, metrics and glyph with caching'
        ...
    
    def get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi):
        ...
    
    def get_xheight(self, font, fontsize, dpi):
        ...
    
    def get_underline_thickness(self, font, fontsize, dpi):
        ...
    


SHRINK_FACTOR = 0.7
GROW_FACTOR = 1 / SHRINK_FACTOR
NUM_SIZE_LEVELS = 6
class FontConstantsBase(object):
    """
    A set of constants that controls how certain things, such as sub-
    and superscripts are laid out.  These are all metrics that can't
    be reliably retrieved from the font metrics in the font itself.
    """
    script_space = ...
    subdrop = ...
    sup1 = ...
    sub1 = ...
    sub2 = ...
    delta = ...
    delta_slanted = ...
    delta_integral = ...


class ComputerModernFontConstants(FontConstantsBase):
    script_space = ...
    subdrop = ...
    sup1 = ...
    sub1 = ...
    sub2 = ...
    delta = ...
    delta_slanted = ...
    delta_integral = ...


class STIXFontConstants(FontConstantsBase):
    script_space = ...
    sup1 = ...
    sub2 = ...
    delta = ...
    delta_slanted = ...
    delta_integral = ...


class STIXSansFontConstants(FontConstantsBase):
    script_space = ...
    sup1 = ...
    delta_slanted = ...
    delta_integral = ...


class DejaVuSerifFontConstants(FontConstantsBase):
    ...


class DejaVuSansFontConstants(FontConstantsBase):
    ...


_font_constant_mapping = { 'DejaVu Sans': DejaVuSansFontConstants,'DejaVu Sans Mono': DejaVuSansFontConstants,'DejaVu Serif': DejaVuSerifFontConstants,'cmb10': ComputerModernFontConstants,'cmex10': ComputerModernFontConstants,'cmmi10': ComputerModernFontConstants,'cmr10': ComputerModernFontConstants,'cmss10': ComputerModernFontConstants,'cmsy10': ComputerModernFontConstants,'cmtt10': ComputerModernFontConstants,'STIXGeneral': STIXFontConstants,'STIXNonUnicode': STIXFontConstants,'STIXSizeFiveSym': STIXFontConstants,'STIXSizeFourSym': STIXFontConstants,'STIXSizeThreeSym': STIXFontConstants,'STIXSizeTwoSym': STIXFontConstants,'STIXSizeOneSym': STIXFontConstants,'Bitstream Vera Sans': DejaVuSansFontConstants,'Bitstream Vera': DejaVuSansFontConstants }
def _get_font_constant_set(state):
    ...

class MathTextWarning(Warning):
    ...


class Node(object):
    """
    A node in the TeX box model
    """
    def __init__(self):
        self.size = ...
    
    def __repr__(self):
        ...
    
    def __internal_repr__(self):
        ...
    
    def get_kerning(self, next):
        ...
    
    def shrink(self):
        """
        Shrinks one level smaller.  There are only three levels of
        sizes, after which things will no longer get smaller.
        """
        ...
    
    def grow(self):
        """
        Grows one level larger.  There is no limit to how big
        something can get.
        """
        ...
    
    def render(self, x, y):
        ...
    


class Box(Node):
    """
    Represents any node with a physical location.
    """
    def __init__(self, width, height, depth):
        self.width = ...
        self.height = ...
        self.depth = ...
    
    def shrink(self):
        ...
    
    def grow(self):
        ...
    
    def render(self, x1, y1, x2, y2):
        ...
    


class Vbox(Box):
    """
    A box with only height (zero width).
    """
    def __init__(self, height, depth):
        ...
    


class Hbox(Box):
    """
    A box with only width (zero height and depth).
    """
    def __init__(self, width):
        ...
    


class Char(Node):
    """
    Represents a single character.  Unlike TeX, the font information
    and metrics are stored with each :class:`Char` to make it easier
    to lookup the font metrics when needed.  Note that TeX boxes have
    a width, height, and depth, unlike Type1 and Truetype which use a
    full bounding box and an advance in the x-direction.  The metrics
    must be converted to the TeX way, and the advance (if different
    from width) must be converted into a :class:`Kern` node when the
    :class:`Char` is added to its parent :class:`Hlist`.
    """
    def __init__(self, c, state, math: bool = ...):
        self.c = ...
        self.font_output = ...
        self.font = ...
        self.font_class = ...
        self.fontsize = ...
        self.dpi = ...
        self.math = ...
    
    def __internal_repr__(self):
        ...
    
    def _update_metrics(self):
        self.height = ...
        self.depth = ...
    
    def is_slanted(self):
        ...
    
    def get_kerning(self, next):
        """
        Return the amount of kerning between this and the given
        character.  Called when characters are strung together into
        :class:`Hlist` to create :class:`Kern` nodes.
        """
        ...
    
    def render(self, x, y):
        """
        Render the character to the canvas
        """
        ...
    
    def shrink(self):
        ...
    
    def grow(self):
        ...
    


class Accent(Char):
    """
    The font metrics need to be dealt with differently for accents,
    since they are already offset correctly from the baseline in
    TrueType fonts.
    """
    def _update_metrics(self):
        self.width = ...
        self.height = ...
        self.depth = ...
    
    def shrink(self):
        ...
    
    def grow(self):
        ...
    
    def render(self, x, y):
        """
        Render the character to the canvas.
        """
        ...
    


class List(Box):
    """
    A list of nodes (either horizontal or vertical).
    """
    def __init__(self, elements):
        self.shift_amount = ...
        self.children = ...
        self.glue_set = ...
        self.glue_sign = ...
        self.glue_order = ...
    
    def __repr__(self):
        ...
    
    def _determine_order(self, totals):
        """
        A helper function to determine the highest order of glue
        used by the members of this list.  Used by vpack and hpack.
        """
        ...
    
    def _set_glue(self, x, sign, totals, error_type):
        self.glue_order = ...
        self.glue_sign = ...
    
    def shrink(self):
        ...
    
    def grow(self):
        ...
    


class Hlist(List):
    """
    A horizontal list of boxes.
    """
    def __init__(self, elements, w=..., m=..., do_kern: bool = ...):
        ...
    
    def kern(self):
        """
        Insert :class:`Kern` nodes between :class:`Char` nodes to set
        kerning.  The :class:`Char` nodes themselves determine the
        amount of kerning they need (in :meth:`~Char.get_kerning`),
        and this function just creates the linked list in the correct
        way.
        """
        ...
    
    def hpack(self, w=..., m=...):
        """
        The main duty of :meth:`hpack` is to compute the dimensions of
        the resulting boxes, and to adjust the glue if one of those
        dimensions is pre-specified.  The computed sizes normally
        enclose all of the material inside the new box; but some items
        may stick out if negative glue is used, if the box is
        overfull, or if a ``\\vbox`` includes other boxes that have
        been shifted left.

          - *w*: specifies a width

          - *m*: is either 'exactly' or 'additional'.

        Thus, ``hpack(w, 'exactly')`` produces a box whose width is
        exactly *w*, while ``hpack(w, 'additional')`` yields a box
        whose width is the natural width plus *w*.  The default values
        produce a box with the natural width.
        """
        self.height = ...
        self.depth = ...
        self.width = ...
    


class Vlist(List):
    """
    A vertical list of boxes.
    """
    def __init__(self, elements, h=..., m=...):
        ...
    
    def vpack(self, h=..., m=..., l=...):
        """
        The main duty of :meth:`vpack` is to compute the dimensions of
        the resulting boxes, and to adjust the glue if one of those
        dimensions is pre-specified.

          - *h*: specifies a height
          - *m*: is either 'exactly' or 'additional'.
          - *l*: a maximum height

        Thus, ``vpack(h, 'exactly')`` produces a box whose height is
        exactly *h*, while ``vpack(h, 'additional')`` yields a box
        whose height is the natural height plus *h*.  The default
        values produce a box with the natural width.
        """
        self.width = ...
        self.height = ...
    


class Rule(Box):
    """
    A :class:`Rule` node stands for a solid black rectangle; it has
    *width*, *depth*, and *height* fields just as in an
    :class:`Hlist`. However, if any of these dimensions is inf, the
    actual value will be determined by running the rule up to the
    boundary of the innermost enclosing box. This is called a "running
    dimension." The width is never running in an :class:`Hlist`; the
    height and depth are never running in a :class:`Vlist`.
    """
    def __init__(self, width, height, depth, state):
        self.font_output = ...
    
    def render(self, x, y, w, h):
        ...
    


class Hrule(Rule):
    """
    Convenience class to create a horizontal rule.
    """
    def __init__(self, state, thickness: Optional[Any] = ...):
        ...
    


class Vrule(Rule):
    """
    Convenience class to create a vertical rule.
    """
    def __init__(self, state):
        ...
    


class Glue(Node):
    """
    Most of the information in this object is stored in the underlying
    :class:`GlueSpec` class, which is shared between multiple glue objects.  (This
    is a memory optimization which probably doesn't matter anymore, but it's
    easier to stick to what TeX does.)
    """
    def __init__(self, glue_type, copy: bool = ...):
        self.glue_subtype = ...
        self.glue_spec = ...
    
    def shrink(self):
        ...
    
    def grow(self):
        ...
    


class GlueSpec(object):
    """
    See :class:`Glue`.
    """
    def __init__(self, width=..., stretch=..., stretch_order=..., shrink=..., shrink_order=...):
        self.width = ...
        self.stretch = ...
        self.stretch_order = ...
        self.shrink = ...
        self.shrink_order = ...
    
    def copy(self):
        ...
    
    def factory(cls, glue_type):
        ...
    
    factory = ...


class Fil(Glue):
    def __init__(self):
        ...
    


class Fill(Glue):
    def __init__(self):
        ...
    


class Filll(Glue):
    def __init__(self):
        ...
    


class NegFil(Glue):
    def __init__(self):
        ...
    


class NegFill(Glue):
    def __init__(self):
        ...
    


class NegFilll(Glue):
    def __init__(self):
        ...
    


class SsGlue(Glue):
    def __init__(self):
        ...
    


class HCentered(Hlist):
    """
    A convenience class to create an :class:`Hlist` whose contents are
    centered within its enclosing box.
    """
    def __init__(self, elements):
        ...
    


class VCentered(Hlist):
    """
    A convenience class to create a :class:`Vlist` whose contents are
    centered within its enclosing box.
    """
    def __init__(self, elements):
        ...
    


class Kern(Node):
    """
    A :class:`Kern` node has a width field to specify a (normally
    negative) amount of spacing. This spacing correction appears in
    horizontal lists between letters like A and V when the font
    designer said that it looks better to move them closer together or
    further apart. A kern node can also appear in a vertical list,
    when its *width* denotes additional spacing in the vertical
    direction.
    """
    height = ...
    depth = ...
    def __init__(self, width):
        self.width = ...
    
    def __repr__(self):
        ...
    
    def shrink(self):
        ...
    
    def grow(self):
        ...
    


class SubSuperCluster(Hlist):
    """
    :class:`SubSuperCluster` is a sort of hack to get around that fact
    that this code do a two-pass parse like TeX.  This lets us store
    enough information in the hlist itself, namely the nucleus, sub-
    and super-script, such that if another script follows that needs
    to be attached, it can be reconfigured on the fly.
    """
    def __init__(self):
        self.nucleus = ...
        self.sub = ...
        self.super = ...
    


class AutoHeightChar(Hlist):
    """
    :class:`AutoHeightChar` will create a character as close to the
    given height and depth as possible.  When using a font with
    multiple height versions of some characters (such as the BaKoMa
    fonts), the correct glyph will be selected, otherwise this will
    always just return a scaled version of the glyph.
    """
    def __init__(self, c, height, depth, state, always: bool = ..., factor: Optional[Any] = ...):
        self.shift_amount = ...
    


class AutoWidthChar(Hlist):
    """
    :class:`AutoWidthChar` will create a character as close to the
    given width as possible.  When using a font with multiple width
    versions of some characters (such as the BaKoMa fonts), the
    correct glyph will be selected, otherwise this will always just
    return a scaled version of the glyph.
    """
    def __init__(self, c, width, state, always: bool = ..., char_class=...):
        self.width = ...
    


class Ship(object):
    """
    Once the boxes have been set up, this sends them to output.  Since
    boxes can be inside of boxes inside of boxes, the main work of
    :class:`Ship` is done by two mutually recursive routines,
    :meth:`hlist_out` and :meth:`vlist_out`, which traverse the
    :class:`Hlist` nodes and :class:`Vlist` nodes inside of horizontal
    and vertical boxes.  The global variables used in TeX to store
    state as it processes have become member variables here.
    """
    def __call__(self, ox, oy, box):
        self.max_push = ...
        self.cur_s = ...
        self.cur_v = ...
        self.cur_h = ...
        self.off_h = ...
        self.off_v = ...
    
    def clamp(value):
        ...
    
    clamp = ...
    def hlist_out(self, box):
        self.max_push = ...
    
    def vlist_out(self, box):
        self.max_push = ...
    


ship = Ship()
def Error(msg):
    """
    Helper class to raise parser errors.
    """
    ...

class Parser(object):
    """
    This is the pyparsing-based parser for math expressions.  It
    actually parses full strings *containing* math expressions, in
    that raw text may also appear outside of pairs of ``$``.

    The grammar is based directly on that in TeX, though it cuts a few
    corners.
    """
    _math_style_dict = ...
    _binary_operators = ...
    _relation_symbols = ...
    _arrow_symbols = ...
    _spaced_symbols = ...
    _punctuation_symbols = ...
    _overunder_symbols = ...
    _overunder_functions = ...
    _dropsub_symbols = ...
    _fontnames = ...
    _function_names = ...
    _ambi_delim = ...
    _left_delim = ...
    _right_delim = ...
    def __init__(self):
        ...
    
    def parse(self, s, fonts_object, fontsize, dpi):
        """
        Parse expression *s* using the given *fonts_object* for
        output, at the given *fontsize* and *dpi*.

        Returns the parse tree of :class:`Node` instances.
        """
        ...
    
    class State(object):
        """
        Stores the state of the parser.

        States are pushed and popped from a stack as necessary, and
        the "current" state is always at the top of the stack.
        """
        def __init__(self, font_output, font, font_class, fontsize, dpi):
            self.font_output = ...
            self.font_class = ...
            self.fontsize = ...
            self.dpi = ...
        
        def copy(self):
            ...
        
        def _get_font(self):
            ...
        
        def _set_font(self, name):
            ...
        
        font = ...
    
    
    def get_state(self):
        """
        Get the current :class:`State` of the parser.
        """
        ...
    
    def pop_state(self):
        """
        Pop a :class:`State` off of the stack.
        """
        ...
    
    def push_state(self):
        """
        Push a new :class:`State` onto the stack which is just a copy
        of the current state.
        """
        ...
    
    def main(self, s, loc, toks):
        ...
    
    def math_string(self, s, loc, toks):
        ...
    
    def math(self, s, loc, toks):
        ...
    
    def non_math(self, s, loc, toks):
        ...
    
    def _make_space(self, percentage):
        ...
    
    _space_widths = ...
    def space(self, s, loc, toks):
        ...
    
    def customspace(self, s, loc, toks):
        ...
    
    def symbol(self, s, loc, toks):
        ...
    
    snowflake = ...
    def unknown_symbol(self, s, loc, toks):
        ...
    
    _char_over_chars = ...
    def c_over_c(self, s, loc, toks):
        ...
    
    _accent_map = ...
    _wide_accents = ...
    _snowflake = ...
    def accent(self, s, loc, toks):
        ...
    
    def function(self, s, loc, toks):
        ...
    
    def operatorname(self, s, loc, toks):
        ...
    
    def start_group(self, s, loc, toks):
        ...
    
    def group(self, s, loc, toks):
        ...
    
    required_group = ...
    def end_group(self, s, loc, toks):
        ...
    
    def font(self, s, loc, toks):
        ...
    
    def is_overunder(self, nucleus):
        ...
    
    def is_dropsub(self, nucleus):
        ...
    
    def is_slanted(self, nucleus):
        ...
    
    def is_between_brackets(self, s, loc):
        ...
    
    def subsuper(self, s, loc, toks):
        ...
    
    def _genfrac(self, ldelim, rdelim, rule, style, num, den):
        ...
    
    def genfrac(self, s, loc, toks):
        ...
    
    def frac(self, s, loc, toks):
        ...
    
    def dfrac(self, s, loc, toks):
        ...
    
    def stackrel(self, s, loc, toks):
        ...
    
    def binom(self, s, loc, toks):
        ...
    
    def sqrt(self, s, loc, toks):
        ...
    
    def overline(self, s, loc, toks):
        ...
    
    def _auto_sized_delimiter(self, front, middle, back):
        ...
    
    def auto_delim(self, s, loc, toks):
        ...
    


class MathTextParser(object):
    _parser = ...
    _backend_mapping = ...
    _font_type_mapping = ...
    def __init__(self, output):
        """
        Create a MathTextParser for the given backend *output*.
        """
        ...
    
    def parse(self, s, dpi=..., prop: Optional[Any] = ...):
        """
        Parse the given math expression *s* at the given *dpi*.  If
        *prop* is provided, it is a
        :class:`~matplotlib.font_manager.FontProperties` object
        specifying the "default" font to use in the math expression,
        used for all non-math text.

        The results are cached, so multiple calls to :meth:`parse`
        with the same expression should be fast.
        """
        ...
    
    def to_mask(self, texstr, dpi=..., fontsize=...):
        """
        *texstr*
            A valid mathtext string, e.g., r'IQ: $\\sigma_i=15$'

        *dpi*
            The dots-per-inch to render the text

        *fontsize*
            The font size in points

        Returns a tuple (*array*, *depth*)

          - *array* is an NxM uint8 alpha ubyte mask array of
            rasterized tex.

          - depth is the offset of the baseline from the bottom of the
            image in pixels.
        """
        ...
    
    def to_rgba(self, texstr, color=..., dpi=..., fontsize=...):
        """
        *texstr*
            A valid mathtext string, e.g., r'IQ: $\\sigma_i=15$'

        *color*
            Any matplotlib color argument

        *dpi*
            The dots-per-inch to render the text

        *fontsize*
            The font size in points

        Returns a tuple (*array*, *depth*)

          - *array* is an NxM uint8 alpha ubyte mask array of
            rasterized tex.

          - depth is the offset of the baseline from the bottom of the
            image in pixels.
        """
        ...
    
    def to_png(self, filename, texstr, color=..., dpi=..., fontsize=...):
        """
        Writes a tex expression to a PNG file.

        Returns the offset of the baseline from the bottom of the
        image in pixels.

        *filename*
            A writable filename or fileobject

        *texstr*
            A valid mathtext string, e.g., r'IQ: $\\sigma_i=15$'

        *color*
            A valid matplotlib color argument

        *dpi*
            The dots-per-inch to render the text

        *fontsize*
            The font size in points

        Returns the offset of the baseline from the bottom of the
        image in pixels.
        """
        ...
    
    def get_depth(self, texstr, dpi=..., fontsize=...):
        """
        Returns the offset of the baseline from the bottom of the
        image in pixels.

        *texstr*
            A valid mathtext string, e.g., r'IQ: $\\sigma_i=15$'

        *dpi*
            The dots-per-inch to render the text

        *fontsize*
            The font size in points
        """
        ...
    


def math_to_image(s, filename_or_obj, prop: Optional[Any] = ..., dpi: Optional[Any] = ..., format: Optional[Any] = ...):
    """
    Given a math expression, renders it in a closely-clipped bounding
    box to an image file.

    *s*
       A math expression.  The math portion should be enclosed in
       dollar signs.

    *filename_or_obj*
       A filepath or writable file-like object to write the image data
       to.

    *prop*
       If provided, a FontProperties() object describing the size and
       style of the text.

    *dpi*
       Override the output dpi, otherwise use the default associated
       with the output format.

    *format*
       The output format, e.g., 'svg', 'pdf', 'ps' or 'png'.  If not
       provided, will be deduced from the filename.
    """
    ...

