"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from matplotlib import backend_tools as tools, cbook
from typing import Any, Optional

"""
Abstract base classes define the primitives that renderers and
graphics contexts must implement to serve as a matplotlib backend

:class:`RendererBase`
    An abstract base class to handle drawing/rendering operations.

:class:`FigureCanvasBase`
    The abstraction layer that separates the
    :class:`matplotlib.figure.Figure` from the backend specific
    details like a user interface drawing area

:class:`GraphicsContextBase`
    An abstract base class that provides color, line styles, etc...

:class:`Event`
    The base class for all of the matplotlib event
    handling.  Derived classes such as :class:`KeyEvent` and
    :class:`MouseEvent` store the meta data like keys and buttons
    pressed, x and y locations in pixel and
    :class:`~matplotlib.axes.Axes` coordinates.

:class:`ShowBase`
    The base class for the Show class of each interactive backend;
    the 'show' callable is then set to Show.__call__, inherited from
    ShowBase.

:class:`ToolContainerBase`
     The base class for the Toolbar class of each interactive backend.

:class:`StatusbarBase`
    The base class for the messaging area.
"""
_default_filetypes = { 'ps': 'Postscript','eps': 'Encapsulated Postscript','pdf': 'Portable Document Format','pgf': 'PGF code for LaTeX','png': 'Portable Network Graphics','raw': 'Raw RGBA bitmap','rgba': 'Raw RGBA bitmap','svg': 'Scalable Vector Graphics','svgz': 'Scalable Vector Graphics' }
_default_backends = { 'ps': 'matplotlib.backends.backend_ps','eps': 'matplotlib.backends.backend_ps','pdf': 'matplotlib.backends.backend_pdf','pgf': 'matplotlib.backends.backend_pgf','png': 'matplotlib.backends.backend_agg','raw': 'matplotlib.backends.backend_agg','rgba': 'matplotlib.backends.backend_agg','svg': 'matplotlib.backends.backend_svg','svgz': 'matplotlib.backends.backend_svg' }
def register_backend(format, backend, description: Optional[Any] = ...):
    """
    Register a backend for saving to a given file format.

    Parameters
    ----------
    format : str
        File extension

    backend : module string or canvas class
        Backend for handling file output

    description : str, optional
        Description of the file type.  Defaults to an empty string
    """
    ...

def get_registered_canvas_class(format):
    """
    Return the registered default canvas for given file format.
    Handles deferred import of required backend.
    """
    ...

class _Backend(object):
    FigureCanvas = ...
    FigureManager = ...
    trigger_manager_draw = ...
    mainloop = ...
    @classmethod
    def new_figure_manager(cls, num, *args, **kwargs):
        """Create a new figure manager instance.
        """
        ...
    
    @classmethod
    def new_figure_manager_given_figure(cls, num, figure):
        """Create a new figure manager instance for the given figure.
        """
        ...
    
    @classmethod
    def draw_if_interactive(cls):
        ...
    
    @classmethod
    def show(cls, block: Optional[Any] = ...):
        """Show all figures.

        `show` blocks by calling `mainloop` if *block* is ``True``, or if it
        is ``None`` and we are neither in IPython's ``%pylab`` mode, nor in
        `interactive` mode.
        """
        ...
    
    @staticmethod
    def export(cls):
        class Show(ShowBase):
            ...
        
        
    


class ShowBase(_Backend):
    """
    Simple base class to generate a show() callable in backends.

    Subclass must override mainloop() method.
    """
    def __call__(self, block: Optional[Any] = ...):
        ...
    


class RendererBase(object):
    """An abstract base class to handle drawing/rendering operations.

    The following methods must be implemented in the backend for full
    functionality (though just implementing :meth:`draw_path` alone would
    give a highly capable backend):

    * :meth:`draw_path`
    * :meth:`draw_image`
    * :meth:`draw_gouraud_triangle`

    The following methods *should* be implemented in the backend for
    optimization reasons:

    * :meth:`draw_text`
    * :meth:`draw_markers`
    * :meth:`draw_path_collection`
    * :meth:`draw_quad_mesh`

    """
    def __init__(self):
        ...
    
    def open_group(self, s, gid: Optional[Any] = ...):
        """
        Open a grouping element with label *s*. If *gid* is given, use
        *gid* as the id of the group. Is only currently used by
        :mod:`~matplotlib.backends.backend_svg`.
        """
        ...
    
    def close_group(self, s):
        """
        Close a grouping element with label *s*
        Is only currently used by :mod:`~matplotlib.backends.backend_svg`
        """
        ...
    
    def draw_path(self, gc, path, transform, rgbFace: Optional[Any] = ...):
        """
        Draws a :class:`~matplotlib.path.Path` instance using the
        given affine transform.
        """
        ...
    
    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace: Optional[Any] = ...):
        """
        Draws a marker at each of the vertices in path.  This includes
        all vertices, including control points on curves.  To avoid
        that behavior, those vertices should be removed before calling
        this function.

        This provides a fallback implementation of draw_markers that
        makes multiple calls to :meth:`draw_path`.  Some backends may
        want to override this method in order to draw the marker only
        once and reuse it multiple times.

        Parameters
        ----------
        gc : `GraphicsContextBase`
            The graphics context

        marker_trans : `matplotlib.transforms.Transform`
            An affine transform applied to the marker.

        trans : `matplotlib.transforms.Transform`
            An affine transform applied to the path.

        """
        ...
    
    def draw_path_collection(self, gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position):
        """
        Draws a collection of paths selecting drawing properties from
        the lists *facecolors*, *edgecolors*, *linewidths*,
        *linestyles* and *antialiaseds*. *offsets* is a list of
        offsets to apply to each of the paths.  The offsets in
        *offsets* are first transformed by *offsetTrans* before being
        applied.  *offset_position* may be either "screen" or "data"
        depending on the space that the offsets are in.

        This provides a fallback implementation of
        :meth:`draw_path_collection` that makes multiple calls to
        :meth:`draw_path`.  Some backends may want to override this in
        order to render each set of path data only once, and then
        reference that path multiple times with the different offsets,
        colors, styles etc.  The generator methods
        :meth:`_iter_collection_raw_paths` and
        :meth:`_iter_collection` are provided to help with (and
        standardize) the implementation across backends.  It is highly
        recommended to use those generators, so that changes to the
        behavior of :meth:`draw_path_collection` can be made globally.
        """
        ...
    
    def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiased, edgecolors):
        """
        This provides a fallback implementation of
        :meth:`draw_quad_mesh` that generates paths and then calls
        :meth:`draw_path_collection`.
        """
        ...
    
    def draw_gouraud_triangle(self, gc, points, colors, transform):
        """
        Draw a Gouraud-shaded triangle.

        Parameters
        ----------
        points : array_like, shape=(3, 2)
            Array of (x, y) points for the triangle.

        colors : array_like, shape=(3, 4)
            RGBA colors for each point of the triangle.

        transform : `matplotlib.transforms.Transform`
            An affine transform to apply to the points.

        """
        ...
    
    def draw_gouraud_triangles(self, gc, triangles_array, colors_array, transform):
        """
        Draws a series of Gouraud triangles.

        Parameters
        ----------
        points : array_like, shape=(N, 3, 2)
            Array of *N* (x, y) points for the triangles.

        colors : array_like, shape=(N, 3, 4)
            Array of *N* RGBA colors for each point of the triangles.

        transform : `matplotlib.transforms.Transform`
            An affine transform to apply to the points.
        """
        ...
    
    def _iter_collection_raw_paths(self, master_transform, paths, all_transforms):
        """
        This is a helper method (along with :meth:`_iter_collection`) to make
        it easier to write a space-efficient :meth:`draw_path_collection`
        implementation in a backend.

        This method yields all of the base path/transform
        combinations, given a master transform, a list of paths and
        list of transforms.

        The arguments should be exactly what is passed in to
        :meth:`draw_path_collection`.

        The backend should take each yielded path and transform and
        create an object that can be referenced (reused) later.
        """
        ...
    
    def _iter_collection_uses_per_path(self, paths, all_transforms, offsets, facecolors, edgecolors):
        """
        Compute how many times each raw path object returned by
        _iter_collection_raw_paths would be used when calling
        _iter_collection. This is intended for the backend to decide
        on the tradeoff between using the paths in-line and storing
        them once and reusing. Rounds up in case the number of uses
        is not the same for every path.
        """
        ...
    
    def _iter_collection(self, gc, master_transform, all_transforms, path_ids, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position):
        """
        This is a helper method (along with
        :meth:`_iter_collection_raw_paths`) to make it easier to write
        a space-efficient :meth:`draw_path_collection` implementation in a
        backend.

        This method yields all of the path, offset and graphics
        context combinations to draw the path collection.  The caller
        should already have looped over the results of
        :meth:`_iter_collection_raw_paths` to draw this collection.

        The arguments should be the same as that passed into
        :meth:`draw_path_collection`, with the exception of
        *path_ids*, which is a list of arbitrary objects that the
        backend will use to reference one of the paths created in the
        :meth:`_iter_collection_raw_paths` stage.

        Each yielded result is of the form::

           xo, yo, path_id, gc, rgbFace

        where *xo*, *yo* is an offset; *path_id* is one of the elements of
        *path_ids*; *gc* is a graphics context and *rgbFace* is a color to
        use for filling the path.
        """
        ...
    
    def get_image_magnification(self):
        """
        Get the factor by which to magnify images passed to :meth:`draw_image`.
        Allows a backend to have images at a different resolution to other
        artists.
        """
        ...
    
    def draw_image(self, gc, x, y, im, transform: Optional[Any] = ...):
        """
        Draw an RGBA image.

        Parameters
        ----------
        gc : `GraphicsContextBase`
            a graphics context with clipping information.

        x : scalar
            the distance in physical units (i.e., dots or pixels) from the left
            hand side of the canvas.

        y : scalar
            the distance in physical units (i.e., dots or pixels) from the
            bottom side of the canvas.

        im : array_like, shape=(N, M, 4), dtype=np.uint8
            An array of RGBA pixels.

        transform : `matplotlib.transforms.Affine2DBase`
            If and only if the concrete backend is written such that
            :meth:`option_scale_image` returns ``True``, an affine
            transformation *may* be passed to :meth:`draw_image`. It takes the
            form of a :class:`~matplotlib.transforms.Affine2DBase` instance.
            The translation vector of the transformation is given in physical
            units (i.e., dots or pixels). Note that the transformation does not
            override `x` and `y`, and has to be applied *before* translating
            the result by `x` and `y` (this can be accomplished by adding `x`
            and `y` to the translation vector defined by `transform`).
        """
        ...
    
    def option_image_nocomposite(self):
        """
        override this method for renderers that do not necessarily always
        want to rescale and composite raster images. (like SVG, PDF, or PS)
        """
        ...
    
    def option_scale_image(self):
        """
        override this method for renderers that support arbitrary affine
        transformations in :meth:`draw_image` (most vector backends).
        """
        ...
    
    def draw_tex(self, gc, x, y, s, prop, angle, ismath=..., mtext: Optional[Any] = ...):
        """
        """
        ...
    
    def draw_text(self, gc, x, y, s, prop, angle, ismath: bool = ..., mtext: Optional[Any] = ...):
        """
        Draw the text instance

        Parameters
        ----------
        gc : `GraphicsContextBase`
            the graphics context

        x : scalar
            the x location of the text in display coords

        y : scalar
            the y location of the text baseline in display coords

        s : str
            the text string

        prop : `matplotlib.font_manager.FontProperties`
            font properties

        angle : scalar
            the rotation angle in degrees

        mtext : `matplotlib.text.Text`
            the original text object to be rendered

        Notes
        -----
        **backend implementers note**

        When you are trying to determine if you have gotten your bounding box
        right (which is what enables the text layout/alignment to work
        properly), it helps to change the line in text.py::

            if 0: bbox_artist(self, renderer)

        to if 1, and then the actual bounding box will be plotted along with
        your text.
        """
        ...
    
    def _get_text_path_transform(self, x, y, s, prop, angle, ismath):
        """
        return the text path and transform

        Parameters
        ----------
        prop : `matplotlib.font_manager.FontProperties`
          font property

        s : str
          text to be converted

        usetex : bool
          If True, use matplotlib usetex mode.

        ismath : bool
          If True, use mathtext parser. If "TeX", use *usetex* mode.
        """
        ...
    
    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath):
        """
        draw the text by converting them to paths using textpath module.

        Parameters
        ----------
        prop : `matplotlib.font_manager.FontProperties`
          font property

        s : str
          text to be converted

        usetex : bool
          If True, use matplotlib usetex mode.

        ismath : bool
          If True, use mathtext parser. If "TeX", use *usetex* mode.
        """
        ...
    
    def get_text_width_height_descent(self, s, prop, ismath):
        """
        Get the width, height, and descent (offset from the bottom
        to the baseline), in display coords, of the string *s* with
        :class:`~matplotlib.font_manager.FontProperties` *prop*
        """
        ...
    
    def flipy(self):
        """
        Return true if y small numbers are top for renderer Is used
        for drawing text (:mod:`matplotlib.text`) and images
        (:mod:`matplotlib.image`) only
        """
        ...
    
    def get_canvas_width_height(self):
        'return the canvas width and height in display coords'
        ...
    
    def get_texmanager(self):
        """
        return the :class:`matplotlib.texmanager.TexManager` instance
        """
        ...
    
    def new_gc(self):
        """
        Return an instance of a :class:`GraphicsContextBase`
        """
        ...
    
    def points_to_pixels(self, points):
        """
        Convert points to display units

        You need to override this function (unless your backend
        doesn't have a dpi, e.g., postscript or svg).  Some imaging
        systems assume some value for pixels per inch::

            points to pixels = points * pixels_per_inch/72.0 * dpi/72.0

        Parameters
        ----------
        points : scalar or array_like
            a float or a numpy array of float

        Returns
        -------
        Points converted to pixels
        """
        ...
    
    def strip_math(self, s):
        ...
    
    def start_rasterizing(self):
        """
        Used in MixedModeRenderer. Switch to the raster renderer.
        """
        ...
    
    def stop_rasterizing(self):
        """
        Used in MixedModeRenderer. Switch back to the vector renderer
        and draw the contents of the raster renderer as an image on
        the vector renderer.
        """
        ...
    
    def start_filter(self):
        """
        Used in AggRenderer. Switch to a temporary renderer for image
        filtering effects.
        """
        ...
    
    def stop_filter(self, filter_func):
        """
        Used in AggRenderer. Switch back to the original renderer.
        The contents of the temporary renderer is processed with the
        *filter_func* and is drawn on the original renderer as an
        image.
        """
        ...
    


class GraphicsContextBase(object):
    """
    An abstract base class that provides color, line styles, etc...
    """
    def __init__(self):
        ...
    
    def copy_properties(self, gc):
        'Copy properties from gc to self'
        ...
    
    def restore(self):
        """
        Restore the graphics context from the stack - needed only
        for backends that save graphics contexts on a stack
        """
        ...
    
    def get_alpha(self):
        """
        Return the alpha value used for blending - not supported on
        all backends
        """
        ...
    
    def get_antialiased(self):
        "Return true if the object should try to do antialiased rendering"
        ...
    
    def get_capstyle(self):
        """
        Return the capstyle as a string in ('butt', 'round', 'projecting')
        """
        ...
    
    def get_clip_rectangle(self):
        """
        Return the clip rectangle as a :class:`~matplotlib.transforms.Bbox`
        instance
        """
        ...
    
    def get_clip_path(self):
        """
        Return the clip path in the form (path, transform), where path
        is a :class:`~matplotlib.path.Path` instance, and transform is
        an affine transform to apply to the path before clipping.
        """
        ...
    
    def get_dashes(self):
        """
        Return the dash information as an offset dashlist tuple.

        The dash list is a even size list that gives the ink on, ink
        off in pixels.

        See p107 of to PostScript `BLUEBOOK
        <https://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF>`_
        for more info.

        Default value is None
        """
        ...
    
    def get_forced_alpha(self):
        """
        Return whether the value given by get_alpha() should be used to
        override any other alpha-channel values.
        """
        ...
    
    def get_joinstyle(self):
        """
        Return the line join style as one of ('miter', 'round', 'bevel')
        """
        ...
    
    @cbook.deprecated("2.1")
    def get_linestyle(self):
        """
        Return the linestyle: one of ('solid', 'dashed', 'dashdot',
        'dotted').
        """
        ...
    
    def get_linewidth(self):
        """
        Return the line width in points as a scalar
        """
        ...
    
    def get_rgb(self):
        """
        returns a tuple of three or four floats from 0-1.
        """
        ...
    
    def get_url(self):
        """
        returns a url if one is set, None otherwise
        """
        ...
    
    def get_gid(self):
        """
        Return the object identifier if one is set, None otherwise.
        """
        ...
    
    def get_snap(self):
        """
        returns the snap setting which may be:

          * True: snap vertices to the nearest pixel center

          * False: leave vertices as-is

          * None: (auto) If the path contains only rectilinear line
            segments, round to the nearest pixel center
        """
        ...
    
    def set_alpha(self, alpha):
        """
        Set the alpha value used for blending - not supported on all backends.
        If ``alpha=None`` (the default), the alpha components of the
        foreground and fill colors will be used to set their respective
        transparencies (where applicable); otherwise, ``alpha`` will override
        them.
        """
        ...
    
    def set_antialiased(self, b):
        """
        True if object should be drawn with antialiased rendering
        """
        ...
    
    def set_capstyle(self, cs):
        """
        Set the capstyle as a string in ('butt', 'round', 'projecting')
        """
        ...
    
    def set_clip_rectangle(self, rectangle):
        """
        Set the clip rectangle with sequence (left, bottom, width, height)
        """
        ...
    
    def set_clip_path(self, path):
        """
        Set the clip path and transformation.  Path should be a
        :class:`~matplotlib.transforms.TransformedPath` instance.
        """
        ...
    
    def set_dashes(self, dash_offset, dash_list):
        """
        Set the dash style for the gc.

        Parameters
        ----------
        dash_offset : float
            is the offset (usually 0).

        dash_list : array_like
            specifies the on-off sequence as points.
            ``(None, None)`` specifies a solid line

        """
        ...
    
    def set_foreground(self, fg, isRGBA: bool = ...):
        """
        Set the foreground color.  fg can be a MATLAB format string, a
        html hex color string, an rgb or rgba unit tuple, or a float between 0
        and 1.  In the latter case, grayscale is used.

        If you know fg is rgba, set ``isRGBA=True`` for efficiency.
        """
        ...
    
    def set_joinstyle(self, js):
        """
        Set the join style to be one of ('miter', 'round', 'bevel')
        """
        ...
    
    def set_linewidth(self, w):
        """
        Set the linewidth in points
        """
        ...
    
    @cbook.deprecated("2.1")
    def set_linestyle(self, style):
        """
        Set the linestyle to be one of ('solid', 'dashed', 'dashdot',
        'dotted'). These are defined in the rcParams
        `lines.dashed_pattern`, `lines.dashdot_pattern` and
        `lines.dotted_pattern`.  One may also specify customized dash
        styles by providing a tuple of (offset, dash pairs).
        """
        ...
    
    def set_url(self, url):
        """
        Sets the url for links in compatible backends
        """
        ...
    
    def set_gid(self, id):
        """
        Sets the id.
        """
        ...
    
    def set_snap(self, snap):
        """
        Sets the snap setting which may be:

          * True: snap vertices to the nearest pixel center

          * False: leave vertices as-is

          * None: (auto) If the path contains only rectilinear line
            segments, round to the nearest pixel center
        """
        ...
    
    def set_hatch(self, hatch):
        """
        Sets the hatch style for filling
        """
        ...
    
    def get_hatch(self):
        """
        Gets the current hatch style
        """
        ...
    
    def get_hatch_path(self, density=...):
        """
        Returns a Path for the current hatch.
        """
        ...
    
    def get_hatch_color(self):
        """
        Gets the color to use for hatching.
        """
        ...
    
    def set_hatch_color(self, hatch_color):
        """
        sets the color to use for hatching.
        """
        ...
    
    def get_hatch_linewidth(self):
        """
        Gets the linewidth to use for hatching.
        """
        ...
    
    def get_sketch_params(self):
        """
        Returns the sketch parameters for the artist.

        Returns
        -------
        sketch_params : tuple or `None`

        A 3-tuple with the following elements:

          * `scale`: The amplitude of the wiggle perpendicular to the
            source line.

          * `length`: The length of the wiggle along the line.

          * `randomness`: The scale factor by which the length is
            shrunken or expanded.

        May return `None` if no sketch parameters were set.
        """
        ...
    
    def set_sketch_params(self, scale: Optional[Any] = ..., length: Optional[Any] = ..., randomness: Optional[Any] = ...):
        """
        Sets the sketch parameters.

        Parameters
        ----------

        scale : float, optional
            The amplitude of the wiggle perpendicular to the source
            line, in pixels.  If scale is `None`, or not provided, no
            sketch filter will be provided.

        length : float, optional
             The length of the wiggle along the line, in pixels
             (default 128)

        randomness : float, optional
            The scale factor by which the length is shrunken or
            expanded (default 16)
        """
        ...
    


class TimerBase(object):
    '''
    A base class for providing timer events, useful for things animations.
    Backends need to implement a few specific methods in order to use their
    own timing mechanisms so that the timer events are integrated into their
    event loops.

    Mandatory functions that must be implemented:

        * `_timer_start`: Contains backend-specific code for starting
          the timer

        * `_timer_stop`: Contains backend-specific code for stopping
          the timer

    Optional overrides:

        * `_timer_set_single_shot`: Code for setting the timer to
          single shot operating mode, if supported by the timer
          object. If not, the `Timer` class itself will store the flag
          and the `_on_timer` method should be overridden to support
          such behavior.

        * `_timer_set_interval`: Code for setting the interval on the
          timer, if there is a method for doing so on the timer
          object.

        * `_on_timer`: This is the internal function that any timer
          object should call, which will handle the task of running
          all callbacks that have been set.

    Attributes
    ----------
    interval : scalar
        The time between timer events in milliseconds. Default is 1000 ms.

    single_shot : bool
        Boolean flag indicating whether this timer should operate as single
        shot (run once and then stop). Defaults to `False`.

    callbacks : List[Tuple[callable, Tuple, Dict]]
        Stores list of (func, args, kwargs) tuples that will be called upon
        timer events. This list can be manipulated directly, or the
        functions `add_callback` and `remove_callback` can be used.

    '''
    def __init__(self, interval: Optional[Any] = ..., callbacks: Optional[Any] = ...):
        ...
    
    def __del__(self):
        'Need to stop timer and possibly disconnect timer.'
        ...
    
    def start(self, interval: Optional[Any] = ...):
        '''
        Start the timer object. `interval` is optional and will be used
        to reset the timer interval first if provided.
        '''
        ...
    
    def stop(self):
        '''
        Stop the timer.
        '''
        ...
    
    def _timer_start(self):
        ...
    
    def _timer_stop(self):
        ...
    
    def _get_interval(self):
        ...
    
    def _set_interval(self, interval):
        ...
    
    interval = ...
    def _get_single_shot(self):
        ...
    
    def _set_single_shot(self, ss: bool = ...):
        ...
    
    single_shot = ...
    def add_callback(self, func, *args, **kwargs):
        '''
        Register `func` to be called by timer when the event fires. Any
        additional arguments provided will be passed to `func`.
        '''
        ...
    
    def remove_callback(self, func, *args, **kwargs):
        '''
        Remove `func` from list of callbacks. `args` and `kwargs` are optional
        and used to distinguish between copies of the same function registered
        to be called with different arguments.
        '''
        ...
    
    def _timer_set_interval(self):
        """Used to set interval on underlying timer object."""
        ...
    
    def _timer_set_single_shot(self):
        """Used to set single shot on underlying timer object."""
        ...
    
    def _on_timer(self):
        '''
        Runs all function that have been registered as callbacks. Functions
        can return False (or 0) if they should not be called any more. If there
        are no callbacks, the timer is automatically stopped.
        '''
        ...
    


class Event(object):
    """
    A matplotlib event.  Attach additional attributes as defined in
    :meth:`FigureCanvasBase.mpl_connect`.  The following attributes
    are defined and shown with their default values

    Attributes
    ----------
    name : str
        the event name

    canvas : `FigureCanvasBase`
        the backend-specific canvas instance generating the event

    guiEvent
        the GUI event that triggered the matplotlib event

    """
    def __init__(self, name, canvas, guiEvent: Optional[Any] = ...):
        self.name = ...
        self.canvas = ...
        self.guiEvent = ...
    


@cbook.deprecated("2.1")
class IdleEvent(Event):
    """
    An event triggered by the GUI backend when it is idle -- useful
    for passive animation
    """
    ...


class DrawEvent(Event):
    """
    An event triggered by a draw operation on the canvas

    In most backends callbacks subscribed to this callback will be
    fired after the rendering is complete but before the screen is
    updated.  Any extra artists drawn to the canvas's renderer will
    be reflected without an explicit call to ``blit``.

    .. warning ::

       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may
       not be safe with all backends and may cause infinite recursion.

    In addition to the :class:`Event` attributes, the following event
    attributes are defined:

    Attributes
    ----------
    renderer : `RendererBase`
        the renderer for the draw event

    """
    def __init__(self, name, canvas, renderer):
        self.renderer = ...
    


class ResizeEvent(Event):
    """
    An event triggered by a canvas resize

    In addition to the :class:`Event` attributes, the following event
    attributes are defined:

    Attributes
    ----------
    width : scalar
        width of the canvas in pixels

    height : scalar
        height of the canvas in pixels

    """
    def __init__(self, name, canvas):
        ...
    


class CloseEvent(Event):
    """
    An event triggered by a figure being closed

    """
    def __init__(self, name, canvas, guiEvent: Optional[Any] = ...):
        ...
    


class LocationEvent(Event):
    """
    An event that has a screen location

    The following additional attributes are defined and shown with
    their default values.

    In addition to the :class:`Event` attributes, the following
    event attributes are defined:

    Attributes
    ----------
    x : scalar
        x position - pixels from left of canvas

    y : scalar
        y position - pixels from bottom of canvas

    inaxes : bool
        the :class:`~matplotlib.axes.Axes` instance if mouse is over axes

    xdata : scalar
        x coord of mouse in data coords

    ydata : scalar
        y coord of mouse in data coords

    """
    x = ...
    y = ...
    inaxes = ...
    xdata = ...
    ydata = ...
    lastevent = ...
    def __init__(self, name, canvas, x, y, guiEvent: Optional[Any] = ...):
        """
        *x*, *y* in figure coords, 0,0 = bottom, left
        """
        self.x = ...
        self.y = ...
    
    def _update_enter_leave(self):
        'process the figure/axes enter leave events'
        ...
    


class MouseEvent(LocationEvent):
    """
    A mouse event ('button_press_event',
                   'button_release_event',
                   'scroll_event',
                   'motion_notify_event').

    In addition to the :class:`Event` and :class:`LocationEvent`
    attributes, the following attributes are defined:

    Attributes
    ----------
    button : None, scalar, or str
        button pressed None, 1, 2, 3, 'up', 'down' (up and down are used
        for scroll events).  Note that in the nbagg backend, both the
        middle and right clicks return 3 since right clicking will bring
        up the context menu in some browsers.

    key : None, or str
        the key depressed when the mouse event triggered (see
        :class:`KeyEvent`)

    step : scalar
        number of scroll steps (positive for 'up', negative for 'down')

    Examples
    --------
    Usage::

        def on_press(event):
            print('you pressed', event.button, event.xdata, event.ydata)

        cid = fig.canvas.mpl_connect('button_press_event', on_press)

    """
    x = ...
    y = ...
    button = ...
    dblclick = ...
    inaxes = ...
    xdata = ...
    ydata = ...
    step = ...
    def __init__(self, name, canvas, x, y, button: Optional[Any] = ..., key: Optional[Any] = ..., step=..., dblclick: bool = ..., guiEvent: Optional[Any] = ...):
        """
        x, y in figure coords, 0,0 = bottom, left
        button pressed None, 1, 2, 3, 'up', 'down'
        """
        self.button = ...
        self.key = ...
        self.step = ...
        self.dblclick = ...
    
    def __str__(self):
        ...
    


class PickEvent(Event):
    """
    a pick event, fired when the user picks a location on the canvas
    sufficiently close to an artist.

    Attrs: all the :class:`Event` attributes plus

    Attributes
    ----------
    mouseevent : `MouseEvent`
        the mouse event that generated the pick

    artist : `matplotlib.artist.Artist`
        the picked artist

    other
        extra class dependent attrs -- e.g., a
        :class:`~matplotlib.lines.Line2D` pick may define different
        extra attributes than a
        :class:`~matplotlib.collections.PatchCollection` pick event

    Examples
    --------
    Usage::

        ax.plot(np.rand(100), 'o', picker=5)  # 5 points tolerance

        def on_pick(event):
            line = event.artist
            xdata, ydata = line.get_data()
            ind = event.ind
            print('on pick line:', np.array([xdata[ind], ydata[ind]]).T)

        cid = fig.canvas.mpl_connect('pick_event', on_pick)

    """
    def __init__(self, name, canvas, mouseevent, artist, guiEvent: Optional[Any] = ..., **kwargs):
        self.mouseevent = ...
        self.artist = ...
    


class KeyEvent(LocationEvent):
    """
    A key event (key press, key release).

    Attach additional attributes as defined in
    :meth:`FigureCanvasBase.mpl_connect`.

    In addition to the :class:`Event` and :class:`LocationEvent`
    attributes, the following attributes are defined:

    Attributes
    ----------
    key : None or str
        the key(s) pressed. Could be **None**, a single case sensitive ascii
        character ("g", "G", "#", etc.), a special key
        ("control", "shift", "f1", "up", etc.) or a
        combination of the above (e.g., "ctrl+alt+g", "ctrl+alt+G").

    Notes
    -----
    Modifier keys will be prefixed to the pressed key and will be in the order
    "ctrl", "alt", "super". The exception to this rule is when the pressed key
    is itself a modifier key, therefore "ctrl+alt" and "alt+control" can both
    be valid key values.

    Examples
    --------
    Usage::

        def on_key(event):
            print('you pressed', event.key, event.xdata, event.ydata)

        cid = fig.canvas.mpl_connect('key_press_event', on_key)

    """
    def __init__(self, name, canvas, key, x=..., y=..., guiEvent: Optional[Any] = ...):
        self.key = ...
    


class FigureCanvasBase(object):
    """
    The canvas the figure renders into.

    Public attributes

    Attributes
    ----------
    figure : `matplotlib.figure.Figure`
        A high-level figure instance

    """
    events = ...
    supports_blit = ...
    fixed_dpi = ...
    filetypes = ...
    if _has_pil:
        ...
    def __init__(self, figure):
        self.figure = ...
        self.callbacks = ...
        self.widgetlock = ...
        self.button_pick_id = ...
        self.scroll_pick_id = ...
        self.mouse_grabber = ...
        self.toolbar = ...
    
    @contextmanager
    def _idle_draw_cntx(self):
        ...
    
    def is_saving(self):
        """
        Returns whether the renderer is in the process of saving
        to a file, rather than rendering for an on-screen buffer.
        """
        ...
    
    @cbook.deprecated("2.2")
    def onRemove(self, ev):
        """
        Mouse event processor which removes the top artist
        under the cursor.  Connect this to the 'mouse_press_event'
        using::

            canvas.mpl_connect('mouse_press_event',canvas.onRemove)
        """
        ...
    
    def pick(self, mouseevent):
        ...
    
    def blit(self, bbox: Optional[Any] = ...):
        """Blit the canvas in bbox (default entire canvas)."""
        ...
    
    def resize(self, w, h):
        """Set the canvas size in pixels."""
        ...
    
    def draw_event(self, renderer):
        """Pass a `DrawEvent` to all functions connected to ``draw_event``."""
        ...
    
    def resize_event(self):
        """Pass a `ResizeEvent` to all functions connected to ``resize_event``.
        """
        ...
    
    def close_event(self, guiEvent: Optional[Any] = ...):
        """Pass a `CloseEvent` to all functions connected to ``close_event``.
        """
        ...
    
    def key_press_event(self, key, guiEvent: Optional[Any] = ...):
        """Pass a `KeyEvent` to all functions connected to ``key_press_event``.
        """
        ...
    
    def key_release_event(self, key, guiEvent: Optional[Any] = ...):
        """
        Pass a `KeyEvent` to all functions connected to ``key_release_event``.
        """
        ...
    
    def pick_event(self, mouseevent, artist, **kwargs):
        """
        This method will be called by artists who are picked and will
        fire off :class:`PickEvent` callbacks registered listeners
        """
        ...
    
    def scroll_event(self, x, y, step, guiEvent: Optional[Any] = ...):
        """
        Backend derived classes should call this function on any
        scroll wheel event.  x,y are the canvas coords: 0,0 is lower,
        left.  button and key are as defined in MouseEvent.

        This method will be call all functions connected to the
        'scroll_event' with a :class:`MouseEvent` instance.
        """
        ...
    
    def button_press_event(self, x, y, button, dblclick: bool = ..., guiEvent: Optional[Any] = ...):
        """
        Backend derived classes should call this function on any mouse
        button press.  x,y are the canvas coords: 0,0 is lower, left.
        button and key are as defined in :class:`MouseEvent`.

        This method will be call all functions connected to the
        'button_press_event' with a :class:`MouseEvent` instance.
        """
        ...
    
    def button_release_event(self, x, y, button, guiEvent: Optional[Any] = ...):
        """
        Backend derived classes should call this function on any mouse
        button release.

        This method will call all functions connected to the
        'button_release_event' with a :class:`MouseEvent` instance.

        Parameters
        ----------
        x : scalar
            the canvas coordinates where 0=left

        y : scalar
            the canvas coordinates where 0=bottom

        guiEvent
            the native UI event that generated the mpl event

        """
        ...
    
    def motion_notify_event(self, x, y, guiEvent: Optional[Any] = ...):
        """
        Backend derived classes should call this function on any
        motion-notify-event.

        This method will call all functions connected to the
        'motion_notify_event' with a :class:`MouseEvent` instance.

        Parameters
        ----------
        x : scalar
            the canvas coordinates where 0=left

        y : scalar
            the canvas coordinates where 0=bottom

        guiEvent
            the native UI event that generated the mpl event

        """
        ...
    
    def leave_notify_event(self, guiEvent: Optional[Any] = ...):
        """
        Backend derived classes should call this function when leaving
        canvas

        Parameters
        ----------
        guiEvent
            the native UI event that generated the mpl event

        """
        ...
    
    def enter_notify_event(self, guiEvent: Optional[Any] = ..., xy: Optional[Any] = ...):
        """
        Backend derived classes should call this function when entering
        canvas

        Parameters
        ----------
        guiEvent
            the native UI event that generated the mpl event
        xy : tuple of 2 scalars
            the coordinate location of the pointer when the canvas is
            entered

        """
        ...
    
    @cbook.deprecated("2.1")
    def idle_event(self, guiEvent: Optional[Any] = ...):
        """Called when GUI is idle."""
        ...
    
    def grab_mouse(self, ax):
        """
        Set the child axes which are currently grabbing the mouse events.
        Usually called by the widgets themselves.
        It is an error to call this if the mouse is already grabbed by
        another axes.
        """
        self.mouse_grabber = ...
    
    def release_mouse(self, ax):
        """
        Release the mouse grab held by the axes, ax.
        Usually called by the widgets.
        It is ok to call this even if you ax doesn't have the mouse
        grab currently.
        """
        ...
    
    def draw(self, *args, **kwargs):
        """Render the :class:`~matplotlib.figure.Figure`."""
        ...
    
    def draw_idle(self, *args, **kwargs):
        """
        :meth:`draw` only if idle; defaults to draw but backends can override
        """
        ...
    
    def draw_cursor(self, event):
        """
        Draw a cursor in the event.axes if inaxes is not None.  Use
        native GUI drawing for efficiency if possible
        """
        ...
    
    def get_width_height(self):
        """
        Return the figure width and height in points or pixels
        (depending on the backend), truncated to integers
        """
        ...
    
    @classmethod
    def get_supported_filetypes(cls):
        """Return dict of savefig file formats supported by this backend"""
        ...
    
    @classmethod
    def get_supported_filetypes_grouped(cls):
        """Return a dict of savefig file formats supported by this backend,
        where the keys are a file type name, such as 'Joint Photographic
        Experts Group', and the values are a list of filename extensions used
        for that filetype, such as ['jpg', 'jpeg']."""
        ...
    
    def _get_output_canvas(self, fmt):
        """
        Return a canvas suitable for saving figures to a specified file format.

        If necessary, this function will switch to a registered backend that
        supports the format.
        """
        ...
    
    def print_figure(self, filename, dpi: Optional[Any] = ..., facecolor: Optional[Any] = ..., edgecolor: Optional[Any] = ..., orientation=..., format: Optional[Any] = ..., **kwargs):
        """
        Render the figure to hardcopy. Set the figure patch face and edge
        colors.  This is useful because some of the GUIs have a gray figure
        face color background and you'll probably want to override this on
        hardcopy.

        Parameters
        ----------
        filename
            can also be a file object on image backends

        orientation : {'landscape', 'portrait'}, optional
            only currently applies to PostScript printing.

        dpi : scalar, optional
            the dots per inch to save the figure in; if None, use savefig.dpi

        facecolor : color spec or None, optional
            the facecolor of the figure; if None, defaults to savefig.facecolor

        edgecolor : color spec or None, optional
            the edgecolor of the figure; if None, defaults to savefig.edgecolor

        format : str, optional
            when set, forcibly set the file format to save to

        bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
            Bbox in inches. Only the given portion of the figure is
            saved. If 'tight', try to figure out the tight bbox of
            the figure. If None, use savefig.bbox

        pad_inches : scalar, optional
            Amount of padding around the figure when bbox_inches is
            'tight'. If None, use savefig.pad_inches

        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
            A list of extra artists that will be considered when the
            tight bbox is calculated.

        """
        ...
    
    @classmethod
    def get_default_filetype(cls):
        """
        Get the default savefig file format as specified in rcParam
        ``savefig.format``. Returned string excludes period. Overridden
        in backends that only support a single file type.
        """
        ...
    
    def get_window_title(self):
        """
        Get the title text of the window containing the figure.
        Return None if there is no window (e.g., a PS backend).
        """
        ...
    
    def set_window_title(self, title):
        """
        Set the title text of the window containing the figure.  Note that
        this has no effect if there is no window (e.g., a PS backend).
        """
        ...
    
    def get_default_filename(self):
        """
        Return a string, which includes extension, suitable for use as
        a default filename.
        """
        ...
    
    def switch_backends(self, FigureCanvasClass):
        """
        Instantiate an instance of FigureCanvasClass

        This is used for backend switching, e.g., to instantiate a
        FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is
        not done, so any changes to one of the instances (e.g., setting
        figure size or line props), will be reflected in the other
        """
        ...
    
    def mpl_connect(self, s, func):
        """
        Connect event with string *s* to *func*.  The signature of *func* is::

          def func(event)

        where event is a :class:`matplotlib.backend_bases.Event`.  The
        following events are recognized

        - 'button_press_event'
        - 'button_release_event'
        - 'draw_event'
        - 'key_press_event'
        - 'key_release_event'
        - 'motion_notify_event'
        - 'pick_event'
        - 'resize_event'
        - 'scroll_event'
        - 'figure_enter_event',
        - 'figure_leave_event',
        - 'axes_enter_event',
        - 'axes_leave_event'
        - 'close_event'

        For the location events (button and key press/release), if the
        mouse is over the axes, the variable ``event.inaxes`` will be
        set to the :class:`~matplotlib.axes.Axes` the event occurs is
        over, and additionally, the variables ``event.xdata`` and
        ``event.ydata`` will be defined.  This is the mouse location
        in data coords.  See
        :class:`~matplotlib.backend_bases.KeyEvent` and
        :class:`~matplotlib.backend_bases.MouseEvent` for more info.

        Return value is a connection id that can be used with
        :meth:`~matplotlib.backend_bases.Event.mpl_disconnect`.

        Examples
        --------
        Usage::

            def on_press(event):
                print('you pressed', event.button, event.xdata, event.ydata)

            cid = canvas.mpl_connect('button_press_event', on_press)

        """
        ...
    
    def mpl_disconnect(self, cid):
        """
        Disconnect callback id cid

        Examples
        --------
        Usage::

            cid = canvas.mpl_connect('button_press_event', on_press)
            #...later
            canvas.mpl_disconnect(cid)
        """
        ...
    
    def new_timer(self, *args, **kwargs):
        """
        Creates a new backend-specific subclass of
        :class:`backend_bases.Timer`. This is useful for getting periodic
        events through the backend's native event loop. Implemented only for
        backends with GUIs.

        Other Parameters
        ----------------
        interval : scalar
            Timer interval in milliseconds

        callbacks : List[Tuple[callable, Tuple, Dict]]
            Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``
            will be executed by the timer every *interval*.

            callbacks which return ``False`` or ``0`` will be removed from the
            timer.

        Examples
        --------

        >>> timer = fig.canvas.new_timer(callbacks=[(f1, (1, ), {'a': 3}),])

        """
        ...
    
    def flush_events(self):
        """Flush the GUI events for the figure.

        Interactive backends need to reimplement this method.
        """
        ...
    
    def start_event_loop(self, timeout=...):
        """Start a blocking event loop.

        Such an event loop is used by interactive functions, such as `ginput`
        and `waitforbuttonpress`, to wait for events.

        The event loop blocks until a callback function triggers
        `stop_event_loop`, or *timeout* is reached.

        If *timeout* is negative, never timeout.

        Only interactive backends need to reimplement this method and it relies
        on `flush_events` being properly implemented.

        Interactive backends should implement this in a more native way.
        """
        ...
    
    def stop_event_loop(self):
        """Stop the current blocking event loop.

        Interactive backends need to reimplement this to match
        `start_event_loop`
        """
        ...
    
    start_event_loop_default = ...
    stop_event_loop_default = ...


def key_press_handler(event, canvas, toolbar: Optional[Any] = ...):
    """
    Implement the default mpl key bindings for the canvas and toolbar
    described at :ref:`key-event-handling`

    Parameters
    ----------
    event : :class:`KeyEvent`
        a key press/release event
    canvas : :class:`FigureCanvasBase`
        the backend-specific canvas instance
    toolbar : :class:`NavigationToolbar2`
        the navigation cursor toolbar

    """
    ...

class NonGuiException(Exception):
    ...


class FigureManagerBase(object):
    """
    Helper class for pyplot mode, wraps everything up into a neat bundle

    Attributes
    ----------
    canvas : :class:`FigureCanvasBase`
        The backend-specific canvas instance

    num : int or str
        The figure number

    key_press_handler_id : int
        The default key handler cid, when using the toolmanager.  Can be used
        to disable default key press handling ::

            figure.canvas.mpl_disconnect(
                figure.canvas.manager.key_press_handler_id)
    """
    def __init__(self, canvas, num):
        self.canvas = ...
        self.num = ...
        self.key_press_handler_id = ...
    
    def show(self):
        """
        For GUI backends, show the figure window and redraw.
        For non-GUI backends, raise an exception to be caught
        by :meth:`~matplotlib.figure.Figure.show`, for an
        optional warning.
        """
        ...
    
    def destroy(self):
        ...
    
    def full_screen_toggle(self):
        ...
    
    def resize(self, w, h):
        """"For GUI backends, resize the window (in pixels)."""
        ...
    
    def key_press(self, event):
        """
        Implement the default mpl key bindings defined at
        :ref:`key-event-handling`
        """
        ...
    
    @cbook.deprecated("2.2")
    def show_popup(self, msg):
        """Display message in a popup -- GUI only."""
        ...
    
    def get_window_title(self):
        """Get the title text of the window containing the figure.

        Return None for non-GUI (e.g., PS) backends.
        """
        ...
    
    def set_window_title(self, title):
        """Set the title text of the window containing the figure.

        This has no effect for non-GUI (e.g., PS) backends.
        """
        ...
    


cursors = tools.cursors
class NavigationToolbar2(object):
    """
    Base class for the navigation cursor, version 2

    backends must implement a canvas that handles connections for
    'button_press_event' and 'button_release_event'.  See
    :meth:`FigureCanvasBase.mpl_connect` for more information


    They must also define

      :meth:`save_figure`
         save the current figure

      :meth:`set_cursor`
         if you want the pointer icon to change

      :meth:`_init_toolbar`
         create your toolbar widget

      :meth:`draw_rubberband` (optional)
         draw the zoom to rect "rubberband" rectangle

      :meth:`press`  (optional)
         whenever a mouse button is pressed, you'll be notified with
         the event

      :meth:`release` (optional)
         whenever a mouse button is released, you'll be notified with
         the event

      :meth:`set_message` (optional)
         display message

      :meth:`set_history_buttons` (optional)
         you can change the history back / forward buttons to
         indicate disabled / enabled state.

    That's it, we'll do the rest!
    """
    toolitems = ...
    def __init__(self, canvas):
        self.canvas = ...
        self.mode = ...
    
    def set_message(self, s):
        """Display a message on toolbar or in status bar."""
        ...
    
    def back(self, *args):
        """move back up the view lim stack"""
        ...
    
    @cbook.deprecated("2.1", alternative="canvas.draw_idle")
    def dynamic_update(self):
        ...
    
    def draw_rubberband(self, event, x0, y0, x1, y1):
        """Draw a rectangle rubberband to indicate zoom limits.

        Note that it is not guaranteed that ``x0 <= x1`` and ``y0 <= y1``.
        """
        ...
    
    def remove_rubberband(self):
        """Remove the rubberband."""
        ...
    
    def forward(self, *args):
        """Move forward in the view lim stack."""
        ...
    
    def home(self, *args):
        """Restore the original view."""
        ...
    
    def _init_toolbar(self):
        """
        This is where you actually build the GUI widgets (called by
        __init__).  The icons ``home.xpm``, ``back.xpm``, ``forward.xpm``,
        ``hand.xpm``, ``zoom_to_rect.xpm`` and ``filesave.xpm`` are standard
        across backends (there are ppm versions in CVS also).

        You just need to set the callbacks

        home         : self.home
        back         : self.back
        forward      : self.forward
        hand         : self.pan
        zoom_to_rect : self.zoom
        filesave     : self.save_figure

        You only need to define the last one - the others are in the base
        class implementation.

        """
        ...
    
    def _set_cursor(self, event):
        ...
    
    def mouse_move(self, event):
        ...
    
    def pan(self, *args):
        """Activate the pan/zoom tool. pan with left button, zoom with right"""
        ...
    
    def press(self, event):
        """Called whenever a mouse button is pressed."""
        ...
    
    def press_pan(self, event):
        """Callback for mouse button press in pan/zoom mode."""
        ...
    
    def press_zoom(self, event):
        """Callback for mouse button press in zoom to rect mode."""
        ...
    
    def _switch_on_zoom_mode(self, event):
        ...
    
    def _switch_off_zoom_mode(self, event):
        ...
    
    def push_current(self):
        """Push the current view limits and position onto the stack."""
        ...
    
    def release(self, event):
        """Callback for mouse button release."""
        ...
    
    def release_pan(self, event):
        """Callback for mouse button release in pan/zoom mode."""
        ...
    
    def drag_pan(self, event):
        """Callback for dragging in pan/zoom mode."""
        ...
    
    def drag_zoom(self, event):
        """Callback for dragging in zoom mode."""
        ...
    
    def release_zoom(self, event):
        """Callback for mouse button release in zoom to rect mode."""
        ...
    
    def draw(self):
        """Redraw the canvases, update the locators."""
        ...
    
    def _update_view(self):
        """Update the viewlim and position from the view and
        position stack for each axes.
        """
        ...
    
    def save_figure(self, *args):
        """Save the current figure."""
        ...
    
    def set_cursor(self, cursor):
        """Set the current cursor to one of the :class:`Cursors` enums values.

        If required by the backend, this method should trigger an update in
        the backend event loop after the cursor is set, as this method may be
        called e.g. before a long-running task during which the GUI is not
        updated.
        """
        ...
    
    def update(self):
        """Reset the axes stack."""
        ...
    
    def zoom(self, *args):
        """Activate zoom to rect mode."""
        ...
    
    def set_history_buttons(self):
        """Enable or disable the back/forward button."""
        ...
    


class ToolContainerBase(object):
    """
    Base class for all tool containers, e.g. toolbars.

    Attributes
    ----------
    toolmanager : `ToolManager`
        The tools with which this `ToolContainer` wants to communicate.
    """
    _icon_extension = ...
    def __init__(self, toolmanager):
        self.toolmanager = ...
    
    def _tool_toggled_cbk(self, event):
        """
        Captures the 'tool_trigger_[name]'

        This only gets used for toggled tools
        """
        ...
    
    def add_tool(self, tool, group, position=...):
        """
        Adds a tool to this container

        Parameters
        ----------
        tool : tool_like
            The tool to add, see `ToolManager.get_tool`.
        group : str
            The name of the group to add this tool to.
        position : int (optional)
            The position within the group to place this tool.  Defaults to end.
        """
        ...
    
    def _remove_tool_cbk(self, event):
        """Captures the 'tool_removed_event' signal and removes the tool."""
        ...
    
    def _get_image_filename(self, image):
        """Find the image based on its name."""
        ...
    
    def trigger_tool(self, name):
        """
        Trigger the tool

        Parameters
        ----------
        name : String
            Name (id) of the tool triggered from within the container
        """
        ...
    
    def add_toolitem(self, name, group, position, image, description, toggle):
        """
        Add a toolitem to the container

        This method must get implemented per backend

        The callback associated with the button click event,
        must be **EXACTLY** `self.trigger_tool(name)`

        Parameters
        ----------
        name : string
            Name of the tool to add, this gets used as the tool's ID and as the
            default label of the buttons
        group : String
            Name of the group that this tool belongs to
        position : Int
            Position of the tool within its group, if -1 it goes at the End
        image_file : String
            Filename of the image for the button or `None`
        description : String
            Description of the tool, used for the tooltips
        toggle : Bool
            * `True` : The button is a toggle (change the pressed/unpressed
              state between consecutive clicks)
            * `False` : The button is a normal button (returns to unpressed
              state after release)
        """
        ...
    
    def toggle_toolitem(self, name, toggled):
        """
        Toggle the toolitem without firing event

        Parameters
        ----------
        name : String
            Id of the tool to toggle
        toggled : bool
            Whether to set this tool as toggled or not.
        """
        ...
    
    def remove_toolitem(self, name):
        """
        Remove a toolitem from the `ToolContainer`

        This method must get implemented per backend

        Called when `ToolManager` emits a `tool_removed_event`

        Parameters
        ----------
        name : string
            Name of the tool to remove
        """
        ...
    


class StatusbarBase(object):
    """Base class for the statusbar"""
    def __init__(self, toolmanager):
        self.toolmanager = ...
    
    def _message_cbk(self, event):
        """Captures the 'tool_message_event' and set the message"""
        ...
    
    def set_message(self, s):
        """
        Display a message on toolbar or in status bar

        Parameters
        ----------
        s : str
            Message text
        """
        ...
    


